<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Swift 5.0 正则的使用 | 叶落花开的博客</title><meta name="keywords" content="Swift"><meta name="author" content="叶落花开"><meta name="copyright" content="叶落花开"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Swift 5.0 正则的使用一、正则表达式的用途（搜索和替换）   1.1.正则表达式（regular expression,简称regex）是一种工具，和其他的工具是一样的，它是人们为了解决某一类问题而发明的，要想理解正则表达式及其功用，最好的办法是了解它们可以解决什么样的问题。    1.2. 在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串或者替换一些字符串。正则表达式就是用">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift 5.0 正则的使用">
<meta property="og:url" content="https://www.yeluohuakai.com/posts/2022/12/c00cef82.html">
<meta property="og:site_name" content="叶落花开的博客">
<meta property="og:description" content="Swift 5.0 正则的使用一、正则表达式的用途（搜索和替换）   1.1.正则表达式（regular expression,简称regex）是一种工具，和其他的工具是一样的，它是人们为了解决某一类问题而发明的，要想理解正则表达式及其功用，最好的办法是了解它们可以解决什么样的问题。    1.2. 在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串或者替换一些字符串。正则表达式就是用">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-12-02T05:04:00.000Z">
<meta property="article:modified_time" content="2022-12-02T05:19:42.994Z">
<meta property="article:author" content="叶落花开">
<meta property="article:tag" content="Swift">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/favicon.png"><link rel="canonical" href="https://www.yeluohuakai.com/posts/2022/12/c00cef82"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?2f8a615b51582cf280e790200f3527e6";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-LB2ZMBR4ZN"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-LB2ZMBR4ZN');
</script><script>(function(){
var el = document.createElement("script");
el.src = "https://lf1-cdn-tos.bytegoofy.com/goofy/ttzz/push.js?18da2b25537eeea1b5c8819ad9a03fc2279abb7e5ff9fdb01a2409cbd77b8f1db3e414cba65c376eba389ba56d9ee0846cad2206506a6529fe6ee21a7373effb434c445cf6444b10ea9756ea44e128a6";
el.id = "ttzz";
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(el, s);
})(window)
</script><script async="async" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6673854567363222"></script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":false,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Swift 5.0 正则的使用',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-02 13:19:42'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/index_code.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/ava.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">186</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://support.qq.com/product/377343"><i class="fa-fw fa fa-paper-plane"></i><span> 反馈</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">叶落花开的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://support.qq.com/product/377343"><i class="fa-fw fa fa-paper-plane"></i><span> 反馈</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Swift 5.0 正则的使用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-02T05:04:00.000Z" title="发表于 2022-12-02 13:04:00">2022-12-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-02T05:19:42.994Z" title="更新于 2022-12-02 13:19:42">2022-12-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/">客户端开发</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/Swift%E5%BC%80%E5%8F%91/">Swift开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span id="" data-flag-title="Swift 5.0 正则的使用"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="Swift-5-0-正则的使用"><a href="#Swift-5-0-正则的使用" class="headerlink" title="Swift 5.0 正则的使用"></a>Swift 5.0 正则的使用</h2><h5 id="一、正则表达式的用途（搜索和替换）"><a href="#一、正则表达式的用途（搜索和替换）" class="headerlink" title="一、正则表达式的用途（搜索和替换）"></a>一、正则表达式的用途（搜索和替换）</h5><ul>
<li><p>  1.1.正则表达式（<code>regular expression</code>,简称<code>regex</code>）是一种工具，和其他的工具是一样的，它是人们为了解决某一类问题而发明的，要想理解正则表达式及其功用，最好的办法是了解它们可以解决什么样的问题。</p>
</li>
<li><p>  1.2. 在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串或者替换一些字符串。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码</p>
</li>
<li><p>  1.3.正则表达式是对字符串操作的一种逻辑公式，用事先定义好的一些特定字符、及这些特定字符的组合，组成一个”规则字符串”，这个”规则字符串”用来表达对字符串的一种过滤逻辑。</p>
</li>
<li><p>  1.4.－几乎所有的程序设计语言都支持正则表达式，例如：<code>OC</code>，<code>java</code>，<code>c#</code>，<code>python</code>，<code>js</code>等</p>
</li>
<li><p>  1.5.在很多文本编辑器里，可以使用正则表达式进行检索，正则表达式是文本处理方面功能最强大的工具之一，正则表达式语言来构造正则表达式（最终构造出来的字符串就称为正则表达式），正则表达式用来完成<strong>搜索</strong>和<strong>替换</strong>的操作，当然，Xcode同样支持正则表达式！</p>
<span id="more"></span>
<h5 id="二、匹配单个字符-下面的都将调用textRegex-方法"><a href="#二、匹配单个字符-下面的都将调用textRegex-方法" class="headerlink" title="二、匹配单个字符(下面的都将调用textRegex()方法)"></a>二、匹配单个字符(下面的都将调用textRegex()方法)</h5></li>
<li><p>2.1.匹配纯文本(<code>&quot;ben&quot;</code>)  </p>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-119.png" alt="">

<p>  匹配纯文本</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line"></span><br><span class="line">  override func viewDidLoad() &#123;</span><br><span class="line">     super.viewDidLoad()</span><br><span class="line">     // 匹配单个字符</span><br><span class="line">     view.addSubview(label)</span><br><span class="line">     let str = &quot;Hello, my name is Ben. Please visit my ben website at https://www.forta.com/.&quot;</span><br><span class="line">     label.attributedText = textRegex(pattern: &quot;.a.&quot;,str: str, font: 22)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 1.匹配纯文本</span><br><span class="line">  func textRegex(pattern: String,str: String,font: CGFloat) -&gt; NSMutableAttributedString&#123;</span><br><span class="line"></span><br><span class="line">    //富文本设置</span><br><span class="line">    let attributeString = NSMutableAttributedString(string:str)</span><br><span class="line">    do &#123;</span><br><span class="line">       // 1.1.定义规则</span><br><span class="line">       //let pattern = &quot;ben&quot;</span><br><span class="line">       // 1.2.创建正则表达式对象</span><br><span class="line">       let regex = try NSRegularExpression(pattern: pattern, options: NSRegularExpression.Options.caseInsensitive)</span><br><span class="line">       // 1.3.开始匹配</span><br><span class="line">       let res = regex.matches(in: str, options: NSRegularExpression.MatchingOptions(rawValue: 0), range: NSMakeRange(0, str.count))</span><br><span class="line"></span><br><span class="line">       for checkingRes in res</span><br><span class="line">       &#123;</span><br><span class="line">          print(&quot;range\(checkingRes.range)&quot;)</span><br><span class="line">          // substring 截取符合规定规则的字符串</span><br><span class="line">          print((str as NSString).substring(with: checkingRes.range))</span><br><span class="line">          //从文本checkingRes.range个字符字体HelveticaNeue-Bold</span><br><span class="line">          attributeString.addAttribute(NSAttributedStringKey.font, value: UIFont(name: &quot;HelveticaNeue-Bold&quot;, size: 22)!,range: checkingRes.range)</span><br><span class="line">          //设置字体颜色</span><br><span class="line">          attributeString.addAttribute(NSAttributedStringKey.foregroundColor, value: UIColor.blue,range: checkingRes.range)</span><br><span class="line">          //设置文字背景颜色</span><br><span class="line">          attributeString.addAttribute(NSAttributedStringKey.backgroundColor, value: UIColor.green,range: checkingRes.range)</span><br><span class="line">         &#125;</span><br><span class="line">        return attributeString</span><br><span class="line"></span><br><span class="line">        &#125; catch &#123;</span><br><span class="line">    </span><br><span class="line">          print(error)</span><br><span class="line">        &#125;</span><br><span class="line">     return attributeString</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   lazy var label: UILabel = &#123;</span><br><span class="line"></span><br><span class="line">     let label1: UILabel = UILabel(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.size.width, height: UIScreen.main.bounds.size.height))</span><br><span class="line">     label1.font = UIFont.systemFont(ofSize: 22)</span><br><span class="line">     label1.numberOfLines = 0</span><br><span class="line">     label1.backgroundColor = UIColor.white</span><br><span class="line">     return label1</span><br><span class="line">   &#125;()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.2.匹配任意字符(注意：下面的两句代码调了textRegex方法)</p>
<p>  前面见到的正则表达式都是一些静态的纯文本，它们根本体现不出来正则表达式的威力，下面，我们一起来看看如何用正则表达式去匹配不可预知的字符。在正则表达式里，特殊字符（或字符集合）用来给出要搜索的东西。**”.”字符（英文句号）可以匹配任何一个单个的字符**。  </p>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-120.png" alt="">
  
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str = &quot;Hello, my name is Ben. Please visit my ben website at https://www.forta.com/.&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;.a.&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>
</li>
<li><p>  2.3. 用正则表达式w.t进行的搜索将匹配到wht和wat(还能匹配到一些毫无意义的单词)</p>
</li>
</ul>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-121.png" alt="">
    
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str = &quot;HellomynameisBen.whtareyouwatoulikeme&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;w.t&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li>  2.4. “.”字符可以匹配任何单个的字符，字母，数字甚至只“.”字符本身</li>
</ul>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-122.png" alt="">
    
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str = &quot;HellomynameisBen.whtareyouwatoulikeme&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;n.&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li>2.5.匹配特殊字符<ul>
<li>“.”字符在正则表达式里面有着特殊的含义，如果模式里需要一个“.”,就要想办法告诉正则表达式你需要的是“.”字符本身而不是它在正则表达式里的特殊含义。为此，你必须在“.”前面加一个(反斜杠)字符来对它进行转义。\是一个元字符（metacharacter,表示“这个字符有特殊的含义”）。</li>
<li>  在正则表达式里面，\字符永远出现在一个有着特殊含义的字符串序列的开头，这个序列可以由一个或者多个字符构成。下面看到的是<code>\.</code>序列，在后面的章节里面还会看到更多使用了\字符的例子。  </li>
</ul>
</li>
</ul>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-123.png" alt="">
        
<pre><code>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str = &quot;Hellomynamei.sBen.whtarbyouwatoulikea.se&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;.e.\\.s&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>
    
-   注意：如果需要搜索\\本身，就必须对\\字符进行转义；相应的转义序列是两个连续的反斜杠字符`\\`。
    
</code></pre>
<h5 id="三、匹配一组字符-下面会涉及字符集合"><a href="#三、匹配一组字符-下面会涉及字符集合" class="headerlink" title="三、匹配一组字符(下面会涉及字符集合)"></a>三、匹配一组字符(下面会涉及字符集合)</h5><ul>
<li>3.1.说明字符集合则能匹配特定的字符和字符区间。</li>
<li>  3.2.匹配多个字符中的某一个</li>
</ul>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-124.png" alt="">
    
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str = &quot;Hellomynamei.sBen.whtareb.syouwatoulikea.se&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;[mk]e.\\.s&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>

解释：`&quot;[mk]e.\\.s&quot;` 是 `e`的前面只能是 字母`m`或者`k`
</code></pre>
<ul>
<li>3.2.利用字符集合区间  A-Z: 匹配从A到Zdenka所有大写字母<br>  a-z: 匹配a-z的所有小写的字母<br>  A-F: 匹配从A到F所有大写字母<br>  A-z: 匹配ASCII字符A到ASCII字符z的所有字母。这个模式一般不常用，因为它还包含着[^等在ASCII字符表里面排列在z和a之间的字符。字符区间的首、尾字符可以是ASCII字符表里的任意字符。但在实际工作中，最长哟个的字符区间还是数字字符区间和字母字符区间。  <strong>提示</strong>：在定义一个字符区间一定要避免这个区间的尾字符小于它的首字符（例如：[3-1]）。这种区间是没有意义的，二往往会让整个模式失效。<br>  <code>-</code>(连字符)：是一个特殊的元字符，作为元字符它只能用在[和]之间。在字符集合意外的地方，“-”只是一个普通的字符，只能与“-”本身相匹配。因此，在正则表达式里面，“-”字符不需要被转义。  </li>
</ul>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-125.png" alt="">
    
<pre><code>利用字符集合区间

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str = &quot;&lt;BODY BGCOLOR=#336633 TEXT=#FFFFFF MARGINWIDTH=0 MARGINHEIGHT=0 TOPMARGIN=0 LEFTMARGIN=0&gt;&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;#[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>

-   分析：这里使用的模式以普通字符`#`开头，随后是6个同样的`[0-9A-Fa-f]`字符集合。这将匹配一个由字符`#`开头，然后6个数字或字母A-F(大小写均可)的字符串
</code></pre>
<ul>
<li>3.3.取非匹配  字符集合通常用来指定一组必须匹配其中之一的字符。但在某些场合，我们需要反过来做给出一组不需要得到的字符，换句话说，<strong>除了那个字符集合的字符，其他的字符都可以匹配</strong>。我们可以用元字符<code>^</code><br>  来表明你想对一个字符集合进行取非匹配。这与逻辑运算很相似，只是这里的操作数是字符集合而已。  <img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-126.png" alt="">
  
  取非匹配  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str = &quot;Real Love is n2 just instin1t, but intent.&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;[no][^a-zA-Z]&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>
<ul>
<li>解释：<code>[no]</code>意思是第一个取<code>n</code>或者<code>o</code>都可以，<code>[^a-zA-Z]</code>意思是除了小写<code>a~z</code>和大写<code>A~Z</code>的都不可以取，<code>^</code>是非的意思<br>  <code>^</code>的效果将作用于给定字符集合里的所有字符或字符区间，而不是仅限于紧跟在<code>^</code>字符后面的那一个字符或者字符区间。</li>
</ul>
</li>
<li>3.4.总结<br>  元字符[和]用来定义一个字符集合，其含义是必须匹配该集合里的字符之一。定义一个字符集合的具体的做法有两种：1、把所有的字符都列举出来；2、是利用元字符<code>-</code>以字符区间的方式给出。字符集合可以用元字符<code>^</code>来求非；这将把给定的字符集合强行排除在匹配操作以外，除了该字符集合里的字符，其他字符都可以进行匹配。</li>
</ul>
<h5 id="四、使用元字符（利用元字符去匹配特定的字符或字符类型）"><a href="#四、使用元字符（利用元字符去匹配特定的字符或字符类型）" class="headerlink" title="四、使用元字符（利用元字符去匹配特定的字符或字符类型）"></a>四、使用元字符（利用元字符去匹配特定的字符或字符类型）</h5><ul>
<li>4.1.对特定的字符进行转义  <strong>元字符</strong>是一些在正则表达式里有着特殊含义的字符。英文句号<code>.</code>是一个元字符，他可以用来<strong>匹配任意一个单个字符</strong>，类似地，在方括号<code>[</code>也是一个元字符，它标志着<strong>一个字符集合的开始</strong>。<br>  <strong>元字符</strong>是无法用来替代它们本身，因为在正则表达式里面有着特殊的含义，比如，你不能用一个<code>[</code>来匹配<code>[</code>本身，也不能使用<code>.</code>来匹配<code>.</code>本身，看下面的例子  <img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-127.png" alt="">
  
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str = &quot;var myArray = new Array() if (myArray[0] = 0)&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;myArray[0]&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>
  说明：为什么没有匹配到<code>myArray[0]</code>呢？因为：[和]在正则表达式里是用来定义一个字符集合（而不是[和]本身）的元字符，所以，<code>myArray[0]</code>将匹配<code>myArray</code>后面跟着一个该集合成员的情况，而那个集合只有一个成员<code>0</code>.因此，<code>myArray[0]</code>只能匹配到<code>myArray0</code>。</li>
<li>4.2. 如何才能匹配到**myArray[0]**呢？？？  答案是对元字符进行转义 前面加 <code>\\</code>反斜杠,这样就可以匹配本身了，<code>[</code>和<code>]</code>就不再是元字符。  <img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-128.png" alt="">
  
  反斜杠  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str = &quot;var myArray = new Array() if (myArray[0] = 0)&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;myArray\\[0]&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>
  如果想匹配到0-9之间的数字都可以匹配的话，就需要对集合进行匹配了<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-129.png" alt="">
  
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str = &quot;var myArray[8] = new Array() if (myArray[0] = 0)&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;myArray\\[[0-9]]&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>任何一个元字符都可以通过给它加上一个反斜杠字符 <code>\</code>作为前缀的办法来转义，对元字符进行转义需要用到<code>\</code>字符也是一个元字符，它的特殊含义是对其他的额字符进行转义，在需要匹配本身的时候，我们必须把它转移为<code>\\</code><br><img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-130.png" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;\\Users\\wangchong\\Desktop\\&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;\\\\&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>

<ul>
<li>4.2.匹配空白字符  元字符大多分为2种，一种是用来匹配文本的（比如<code>.</code>）,另一种是正则表达式的语法所要求的（比如[和]）。随着学习的深入，我们会发现越来越多的这两种语法，下面是匹配空白字符的元字符。  </li>
</ul>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-131.png" alt="">
    
<pre><code>特殊元字符
</code></pre>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-132.png" alt="">
    
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;Oviri is an \n\n 1894 ceramic sculpture by the French artist Paul Gauguin.&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;\n\n&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>

`\n\n`作为文本结束的标签

-   元字符我们已经见了好几个了，但是差异性我们真的链接吗？比如`.`和`[`是元字符（前提是没有对他们进行转义）；`f`、`n`、`r`、`t`、也是元字符(前提是对它们进行了转义)，否则它们将被视为普通的字符，从而也只能匹配它们本身。
</code></pre>
<ul>
<li><p>4.3.匹配特定的字符类别</p>
<ul>
<li><p><code>.</code>匹配任意字符</p>
</li>
<li><p><code>[和]</code>多个字符中的某一个</p>
</li>
<li><p><code>^</code>取非匹配</p>
</li>
<li><p>字符集合(匹配多个字符中的某一个)是最常见的匹配形式，而一些常用的<strong>字符集合可以用特殊的元字符来代替</strong>。这些元字符匹配的是某一类别的字符（术语为字符类）。看下面的例子</p>
</li>
<li><p>4.3.1. 匹配数字（与非数字）</p>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-133.png" alt="">
  
<p>  数字元字符</p>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-134.png" alt="">
  
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;Oviri is an 1894 ceramic scu1lpture by the French artist Paul Gauguin.&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;\\d&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>
</li>
<li><p>提示：正则表达式的语法是区分字母大小写的。<code>\d匹配数字</code>，<code>\D</code>匹配非数字，它们正好相反。其他的元字符也一样</p>
</li>
<li><p>4.3.2.匹配字母和数字（与非字母和数字）</p>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-135.png" alt="">
  
<p>  字母数字元字符</p>
</li>
<li><p>例如</p>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-136.png" alt="">
  
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;你%￥吗()==12_3&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;\\W&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.3.3.匹配空字符串（与空白字符）</p>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-138.png" alt="">

  
<p>  看下面的例子</p>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-139.png" alt="">
  
<p>  匹配空字符串</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;11213 A1C2E3 48075 48237 M14F2 90046 H1H2H2&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;\\s&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>
<p>  提示：用来匹配退格字符的<code>[\b]</code>元字符就是一个特例；它不在类元字符<code>\s</code>的覆盖范围内，当然也就没有被排除在类元字符<code>\S</code>的覆盖范围外。</p>
</li>
</ul>
</li>
<li><p>4.4.使用POSIX字符类</p>
</li>
</ul>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-140.png" alt="">

<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-141.png" alt="">
    
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;K$P1-21_3@&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;[:alnum:]&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>
</code></pre>
<h5 id="五、重复匹配"><a href="#五、重复匹配" class="headerlink" title="五、重复匹配"></a>五、重复匹配</h5><ul>
<li>5.1.匹配一个或者多个字符（<code>+</code>）<ul>
<li>  <code>+</code>号匹配一个或多个字符（至少一个；不匹配<code>0</code>个字符的情况），比如<code>c</code>匹配<code>c</code>本身，<code>c+</code>将匹配一个或多个连续出现的<code>c</code>。类似地，<code>[0-9]</code>匹配任意单个数字，<code>[0-9]+</code>将匹配一个或多个连续的数字。  </li>
</ul>
</li>
</ul>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-142.png" alt="">
        
<pre><code>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;The world for.text@text.text is a fine place, and worth fighting The world is a finefor.hext@tdxt.text place, and worth fighting for.&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;\\w+@\\w+\\.\\w+&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>
    
    -   如何把上面的`for`也匹配上  
</code></pre>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-143.png" alt="">
            
<pre><code>        <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;The world for.text@text.text is a fine place, and worth fighting The world is a finefor hext@tdxt.text place, and worth fighting for.&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;[\\w.]+@\\w+\\.\\w+&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>
        
    
    说明：上面没有对字符集合`[\w.]`里的`.`字符进行转义。尽管如此，它还是把原始文本里的`.`字符匹配出来了。一般来说，**当在字符集合里使用的时候，像`.`和`+`这样的元字符将被解释为普通的字符，不需要被转义，但转义了也没有坏处**。`[\w.]`的使用效果与`[\w.\.]`是一样的
    
</code></pre>
<ul>
<li>  5.2.匹配零个或多个字符</li>
</ul>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-144.png" alt="">
    
<pre><code>匹配零个或多个字符

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;The world .text@text.com is a fine place, and worth fighting The world is a finefor hext@tdxt.text place, and worth fighting for.&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;\\w+[\\w.]*@[\\w.]+\\.\\w+&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>

`*`与`+`的区别是：`+`匹配一个或者多个字符（或字符集合），最少也要匹配一次；`*`匹配零个或任意多个字符（或字符集合），可以没有匹配。  
`*`是一个元字符。如果需要匹配`*`本身，就必须对它进行转义。
</code></pre>
<ul>
<li>5.3.匹配零个或者一个字符（ <code>?</code> ）<br>  <code>?</code>只能匹配一个字符（或字符集合）的零次或一次出现，最多不超过一次，如果需要在一段文本里匹配某个特定的字符（或字符集合）而该字符可能出现，也可能不出现，<code>?</code>无疑是最佳的选择。  </li>
</ul>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-145.png" alt="">
    
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;The URL is http://www.forta.com/, to connect securely use https://www.forta.com/ instand.&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;https?://[\\w.]+&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>

同样`?`也是一个元字符，匹配本身的话也需要进行转义。
</code></pre>
<ul>
<li>5.4.匹配的重复的次数<ul>
<li>  5.4.1、为重复匹配次数设定一个精确的值</li>
</ul>
</li>
</ul>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-146.png" alt="">
        
<pre><code>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;&lt;BODY BGCOLOR=#336633&gt; TEXT=#FFFFFF MARGINWIDTH=0 MARGINHEIGHT=0 TOPMARGIN=0&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;[0-9A-Fa-f]&#123;6&#125;&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>
    
    `&#123;6&#125;`:意味着要连续匹配6次`[0-9A-Fa-f]`区间的值
    
-   5.4.2、为重复匹配次数设定一个区间
    
    `&#123;&#125;`：语法不仅仅可以设置匹配的次数，还可以设置匹配的**最小**和**最大**次数  
    如： &#123;1，3&#125;代表连续匹配1~3次之间，当然之前的？其实就是等价于 `?`\=`&#123;0,1&#125;`
    
-   5.4.3、匹配“至少重复多少次”  
    `&#123;&#125;`语法还可以设置至少重复的次数，也就是不用设置最大重复的次数，比如`&#123;2,&#125;`  
</code></pre>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-147.png" alt="">
        
<pre><code>    匹配“至少重复多少次”
    
    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;1001: $496.80 1002: $1290.69 1003: $26.43 1004: $613.42 1007&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;\\d+: \\$\\d&#123;3,&#125;\\.\\d&#123;2&#125;&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>
    
    注意：`&#123;3,&#125;`中的逗号千万别漏掉，否则就变成了精准匹配3位了。
    
</code></pre>
<ul>
<li>5.5.防止过度匹配<br>  <code>?</code>只能匹配0个或者一个字符，{n}和{m,n}也有一个重复次数的上限，之前的例子都没有上限，下面举一个例子来说明  </li>
</ul>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-148.png" alt="">
    
<pre><code>贪婪型和懒惰型

说明：贪婪型为什么会匹配and,那是因为贪婪型元字符在进行匹配的时候是多多益善而不是适可而止。它们会尽可能地从一段文本的开头一直匹配到这段文本的末尾，而不是从这段文本的开头匹配到第一个匹配为止。

-   解决办法是：在贪婪型元字符的后面加上 `?`
-   下面是常用的贪婪型元字符和他们的懒惰型版本
</code></pre>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-149.png" alt="">
        
<ul>
<li>5.6.总结<br>  <strong>正则表达式</strong>的真正威力体现在重复次数匹配方面。上面介绍了<code>+</code>(匹配字符或字符集合的一次或多次重复出现)，<code>*</code>(匹配字符或字符集合的0次或多次重复出现)，<code>?</code>(匹配字符或字符集合的0次或一次出现)等几个元字符的用法。要想获得更精准的控制，你可以使用<code>&#123;&#125;</code>语法来精确地设定一个重复次数或是重复次数的最小值和最大值。元字符分“贪婪型”和“懒惰型”两种，使用时要防止过度匹配时候可以使用懒惰型元字符来创造适合自己的表达式。</li>
</ul>
<h5 id="六、位置匹配"><a href="#六、位置匹配" class="headerlink" title="六、位置匹配"></a>六、位置匹配</h5><ul>
<li>6.1.边界  下面的例子只是想配<code>cat</code>这个单词，但是<code>scattered</code>也被匹配到了,这不是我们想要的结果，后面再解决。  </li>
</ul>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-150.png" alt="">
    
<pre><code>边界

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;The cat scattered his food all over the room.&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;cat&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li>6.2.单词边界  <code>\b</code>可以用来限制单词的边界，也就是规定单词的开头和结尾。，如下所示</li>
</ul>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-151.png" alt="">
    
<pre><code>\\b单词边界

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;The cat scattered his food all over the room.&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;\\bcat\\b&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>

说明：`\b`:匹配的是这样一个位置，这个位置位于一个能够用来构成单词的字符(字母，数字，下划线，也就是与`\w`相匹配的字符)和一个不能用来构成单词的字符（也就是与\\w相匹配的字符）之间。  
注意：要想精准的匹配某一个单词必须在其前后都要加上`\b单词\b`
</code></pre>
<ul>
<li><p>如果不想匹配一个单词的边界，那么就可以使用<code>\B</code>了，看下面的例子  </p>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-152.png" alt="">
  
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;Please enter the nine-digit id as it appears on your color - coded pass-key.&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;\\B-\\B&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>
<p>  <code>\\B-\\B</code>: 将匹配一个前后都不是单词边界的连字符。<code>nine-digit</code>和<code>pass-key</code>不能与之匹配，但<code>color - coded</code>中的连字符可以与之匹配。<br>  <strong>匹配单词</strong>的还有<code>\\&lt;单词\\&gt;</code>,但是swift4.0不支持，本人已经验证过了。</p>
</li>
<li><p>6.3、字符的边界</p>
<p>  单词边界可以用来进行与单词有关位置的匹配（单词的开头，单词的结束，整个单词等）。字符串边界有着类似的用途，只不过是用来进行与字符串有关的位置匹配而已（字符串的开头，字符串的结束，整个字符串等）。用来定义字符串边界的元字符有两个：一个是用来定义字符串开头的<code>^</code>,另一个是用来定义字符串结尾的<code>$</code>.</p>
</li>
<li><p>  总结：<strong>正则表达式</strong>不仅仅可以用来匹配任意长度的文本块，还可以用来匹配出现在字符串中特定位置的文本。<code>\b</code>用来指定一个单词的边界（<code>\B</code>刚好相反）。<code>^</code>和<code>$</code>用来指定字符串的边界（字符串的开头和字符串的结束）。如果与<code>（?m）</code>配合使用，<code>^</code>和<code>$</code>还将匹配在一个换行处开头或结束的字符串（此时，换行符将被视为一个字符串分隔符）。</p>
</li>
</ul>
<h5 id="七、使用字表达式-元字符和字符是正则表达式的基本构件"><a href="#七、使用字表达式-元字符和字符是正则表达式的基本构件" class="headerlink" title="七、使用字表达式(元字符和字符是正则表达式的基本构件)"></a>七、使用字表达式(<code>元字符</code>和<code>字符</code>是<code>正则表达式</code>的<code>基本构件</code>)</h5><ul>
<li>7.1、什么是子表达式？<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-153.png" alt="">
  
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;Hello, my name is Ben&amp;nbsp;Forta, and I am the author of books on SQL, ColdFusion, WAP, Windows&amp;nbsp;&amp;nbsp;2000, and other subjects.&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;&amp;nbsp;&#123;2,&#125;&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>
  <code>&amp;nbsp;</code>：是HTML语言中的非换行空格字符。在这里使用模式<code>&amp;nbsp;&#123;2,&#125;</code>的本意是希望它能把 连续两次或更多次的重复出现找出来，但它没能给出我们所预期的结果。为什么会这样？因为**{2,}只作用于紧挨着它的前一个字符**，那是一个分号。如此一来，这个模式只能匹配像<code>&amp;nbsp;;;;</code>这样的文本，但无法匹配<code>&amp;nbsp;&amp;nbsp</code>。</li>
<li>7.2、子表达式  <strong>字表达式</strong>：是一个更大的表达式的一部分；把一个表达式划分为一系列表达式的目的是为了把那些字表达式当做一个独立元素来使用。字表达式必须用<code>()</code>括起来。<code>()</code>是元字符。如果要匹配<code>()</code>的话需要进行对它转义。看下面的例子  <img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-154.png" alt="">
  
  ()的使用  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;Hello, my name is Ben&amp;nbsp;Forta, and I am the author of books on SQL, ColdFusion, WAP, Windows&amp;nbsp;&amp;nbsp;2000, and other subjects.&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;(&amp;nbsp;)&#123;2,&#125;&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>
  解释：<code>(&amp;nbsp;)</code>是一个字表达式，它将被视为一个独立的元素，而紧跟着在它后面的<code>&#123;2,&#125;</code>将做用于这个字表达式而不是仅仅作用于<code>;</code>。  </li>
</ul>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-155.png" alt="">
    
<pre><code>&quot;(\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;&quot;

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;Pinging hog.forta.com [12.159.46.200] with 32 bytes of data:&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;(\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>

上面的例子中 `(\\d&#123;1,3&#125;\\.)`是一个**子表达式**，上面的匹配规则还可以写为`&quot;(\\d&#123;1,3&#125;\\.?)&#123;4&#125;&quot;`和`&quot;(\\d&#123;1,3&#125;\\.)&#123;3&#125;(\\d&#123;1,3&#125;)&quot;`。

-   下面再写一个子表达式的匹配
</code></pre>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-156.png" alt="">
        
<pre><code>    子表达式的匹配
    
    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;Hope clouds 1987-09-02 observation.&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;(19|20)\\d&#123;2&#125;&quot;,str: str, font: 22)</span><br></pre></td></tr></table></figure>
    

解释：`|`是**或**的意思。
</code></pre>
<ul>
<li>7.3、子表达式的嵌套(下面的例子没有正确匹配：<strong>待解决</strong>)<br>  子表达式是允许嵌套的，实际上，子表达式允许多重嵌套，这种嵌套的层次在理论上没有限制，但在实际上应该合理的嵌套。下面的例子将全面的展示  <img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-157.png" alt="">
  
  子表达式的嵌套  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;Pinging hog.forta.com [12.159.46.200] with 32 bytes of data:&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;(((\\d&#123;1,2&#125;)|(1\\d&#123;2&#125;)|(2[0-4]\\d)|(25[0-5]))\\.)&#123;3&#125;(((25[0-5])|(2[0-4]\\d)|(1\\d&#123;2&#125;)|\\d&#123;1,2&#125;))&quot; ,str: str, font: 22)</span><br></pre></td></tr></table></figure>
  注意：最后一个匹配的时候三位数要放到前面，否则的话匹配到<strong>两位数</strong>，<code>200</code>的最后一个<code>0</code>就不能匹配上了</li>
<li>7.4、总结<br>  <strong>子表达式</strong>的作用是把同一个表达式的各个相关部分组合在一起。子表达式必须用<code>()</code>来定义。子表达式的常见用途包括: 对重复次数元字符的作用对象作出精确的设定和控制、对<code>|</code>操作符条件作出准确额定义等，如有必要，子表达式还允许嵌套使用。</li>
</ul>
<h5 id="八、回溯引用，前后一致匹配"><a href="#八、回溯引用，前后一致匹配" class="headerlink" title="八、回溯引用，前后一致匹配"></a>八、回溯引用，前后一致匹配</h5><ul>
<li>8.1、回溯引用的作用（看下面的例子）<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-158.png" alt="">
  
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;&lt;BODY&gt;&lt;H1&gt;Welcom to my Homepage&lt;/H1&gt;\nContent is divided into two sections:&lt;BR&gt;\n &lt;H2&gt;ColodFusion&lt;/H2&gt;\nInformation about Macromedia ColodFusion.\n &lt;H2&gt;Wrieless&lt;/H2&gt;\n Information about Buletooth, 802.11, and more.\n &lt;H2&gt;This is not valid HTML&lt;/H3&gt;\n&lt;/BODY&gt;&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;&lt;[Hh][1-6]&gt;.*?&lt;/[Hh][1-6]&gt;&quot; ,str: str, font: 22)</span><br></pre></td></tr></table></figure>
  解释：上面匹配按照规则是正确的，但是按照语法最后一个匹配是不正确的，因为H2和H3是不对应的标签。为了解决这个问题，下面阐述：<strong>回溯引用</strong></li>
<li>8.2、回溯引用匹配<ul>
<li>8.2.1、寻找连着的两个相同单词<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-159.png" alt="">
  
  寻找连着的两个相同单词  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;This is a block of of text,serveral words here are repeated,and and they should not not be.&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;[ ]+(\\w+)[ ]+\\1&quot; ,str: str, font: 22)</span><br></pre></td></tr></table></figure>
  解释：<code>[ ]+</code>匹配一个或多个空格，<code>\w+</code>匹配一个或多个字母数字字符，<code>[ ]+</code>匹配随后的空格，注意 <code>\w+</code>是括在括号里的，它是一个子表达式。这个子表达式不是用来进行重复匹配的，这里不涉及到重复匹配的问题。这个子表达式只是把整个模式的一部分单独划分出来以便在后面引用。这个模式的最后一部分是<code>\1</code>;这是一个回溯引用。而它引用的正是前面划分出来的那个子表达式；当<code>(\w+)</code>匹配到单子<code>of</code>的时候，<code>\1</code>也匹配单词<code>of</code>;当<code>(\w+)</code>匹配到单词and的时候，<code>\1</code>也匹配到单词<code>and</code>。<br>  <strong>回溯引用</strong>指的是模式的后半部分引用在前半部分中定义的子表达式。<br>  <code>\1</code>代表模式里的第一个子表达式，<code>\2</code>代表模式里的第<code>2</code>个子表达式，以此类推，上面的例子将匹配到同一个单词的连续两次重复出现。</li>
<li>  8.2.2、解决8.1的最后一个不正确标签的匹配</li>
</ul>
</li>
</ul>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-160.png" alt="">
        
<pre><code>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;&lt;BODY&gt;&lt;H1&gt;Welcom to my Homepage&lt;/H1&gt;\nContent is divided into two sections:&lt;BR&gt;\n &lt;H2&gt;ColodFusion&lt;/H2&gt;\nInformation about Macromedia ColodFusion.\n &lt;H2&gt;Wrieless&lt;/H2&gt;\n Information about Buletooth, 802.11, and more.\n &lt;H2&gt;This is not valid HTML&lt;/H3&gt;\n&lt;/BODY&gt;&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;&lt;[Hh]([1-6])&gt;.*?&lt;/[Hh]\\1&gt;&quot; ,str: str, font: 22)</span><br></pre></td></tr></table></figure>
    

解释：`([1-6])`是一个集合的子表达式，`\1`匹配前面匹配到的`([1-6])`,所以说`H2`只能匹配到`H2`  
注意：**不同的正则表达式在实现回溯引用的语法方面往往有着巨大的差异。**  
提示：**回溯引用只能用来引用模式里的子表达式（（用（和））括起来的正则表达式片段）。**回溯引用通常从1开始计数（\\1、\\2等）。在许多实现里，第0个匹配（\\0）可以用来代表整个正则表达式。其实子表达式是通过它们的相对位置来引用的：\\1对应着第1个子表达式，\\5对应着第5个子表达式等等。这种语法是有问题的：如果子表达式的相对位置发生了变化，整个模式也许就不能再完成原来的工作，删除或者添加子表达式的后果可能更为严重。解决办法：是运用**命令捕获**。
</code></pre>
<ul>
<li>8.3、回溯引用在替换操作中的应用（没理解透）</li>
<li>  8.4.大小写转换  </li>
</ul>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-161.png" alt="">
    
<pre><code>大小写转换
</code></pre>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-162.png" alt="">
    
<pre><code>查找

  
替换使用： `$\\U$2\E$3`

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;&lt;BODY&gt;&lt;H1&gt;Welcom to my Homepage&lt;/H1&gt;\nContent is divided into two sections:&lt;BR&gt;\n &lt;H2&gt;ColodFusion&lt;/H2&gt;\nInformation about Macromedia ColodFusion.&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;(&lt;[Hh]1&gt;)(.*?)(&lt;/[Hh]1&gt;)&quot; ,str: str, font: 22)</span><br></pre></td></tr></table></figure>

分析：`&quot;(&lt;[Hh]1&gt;)(.*?)(&lt;/[Hh]1&gt;)&quot;`是三个子表达式就是为了使用回溯引用，说一下替换部分：`$1`包含着开始标签，`U$2\E`把第二个子表达式（b标题文字）转换为大写，`$3`包含着结束标签。
</code></pre>
<ul>
<li>8.5、总结  子表达式用来定义字符或表达式的集合。除了可以用在重复匹配操作中意外，子表达式还可以在模式的内部被引用。这种引用被称为回溯引用。回溯引用的语法在不同的正则表达式实现里有很大的差异。回溯引用在文本匹配和文本替换操作里非常有用。</li>
</ul>
<h5 id="九、前后查找"><a href="#九、前后查找" class="headerlink" title="九、前后查找"></a>九、前后查找</h5><ul>
<li>9.1、向前查找<br>  <strong>向前查找</strong>指定了一个必须匹配但不在结果中返回的模式。向前查找实际就是一个子表达式，而且从格式上看也确实如此。从语法上看，一个<strong>向前查找模式其实就是一个以<code>?=</code>开头的子表达式，需要匹配的文本跟在<code>=</code>后面</strong>  </li>
</ul>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-163.png" alt="">

<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-164.png" alt="">
    
<pre><code>在向前查找里，被匹配的文本包含在最终返回的匹配结果里，被称为**“不消费”**。反之为**消费**。xiang  
注意：向前查找和向后查找匹配本身其实是有返回结果的，只是这个结果的字节长度永远是0而已。因此，前后查找操作有时也被称为**零宽度匹配操作**。  
**其实**，任何一个子表达式都可以转换为一个向前查找表达式，只要给它加上一个`?=`前缀即可。在同一个搜索模式里可以使用多个向前查找表达式，它们可以出现在模式里的任意位置（而不仅仅是出现在整个模式的开头，就像你们在上面看到的那样。）
</code></pre>
<ul>
<li>9.2、向后查找  <code>?=</code>被称为向前查找的操作符，许多正则表达式还支持向后查找，也就是查找出现在被匹配文本之前的字符（但不消费它也就是不包含其后的文本），向后查找操作符是<code>?&lt;=</code>。<br>  <code>?&lt;=</code>与<code>?=</code>使用方法大同小异，它必须在一个子表达式里，而且后跟要匹配的文本。  </li>
</ul>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-165.png" alt="">
    
<pre><code>向后查找

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;ABC01: $23.45\nHGG42: $5.31\nCFMX1: $899.00\nXTC99: $69.96\nTotal items founf : 4&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;(?&lt;=\\$)[0-9.]+&quot; ,str: str, font: 22)</span><br></pre></td></tr></table></figure>

我们想要的是以`$`为基础匹配后面的消费金额，显然最后一种匹配最好。  
提示：向前查找模式长度是可变的，它们可以包含.和+之类的元字符，所以非常灵活，而向后查找的模式只能是固定长度，这是一条几乎所有的正则表达式实现都遵循的限制。
</code></pre>
<ul>
<li>  9.3.把向前查找和向后查找结合起来</li>
</ul>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-166.png" alt="">
    
<pre><code>把向前查找和向后查找结合起来

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;&lt;HEAD&gt;\n&lt;TITLE&gt;Ben Forta&#x27;s Homepage&lt;/TITLE&gt;\n&lt;HEAD&gt;&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;(?&lt;=&lt;[tT][iI][tT][lL][eE]&gt;).*(?=&lt;/[tT][iI][tT][lL][eE]&gt;)&quot; ,str: str, font: 18)</span><br></pre></td></tr></table></figure>

说明：眼睛尖锐的大家可能已经看到了，上面我读`&lt;`进行了转义，再强调一下，向前查找`?=`(不消费)和向后查找`?&lt;=`(不消费)都是针对的子表达式来操作的。
</code></pre>
<ul>
<li>  9.4、对前后查找取非</li>
</ul>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-167.png" alt="">
    
<pre><code>各种前后取非操作符

一般来说，凡是支持**正向前查找**的正则表达式也是支持**负向前查找**的，反之，凡是只是**正向后查找**的，也是支持**负向后查找**的。  
</code></pre>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-168.png" alt="">
    
<pre><code>对前后查找取非

上面大家可能看到了`\b`,单词的边界，去`\b`会有问题的，有兴趣的可以自己验证下。
</code></pre>
<ul>
<li>9.5、总结  有了前后查找，我们就可以对最终的匹配结果包含哪些内容做出更精确的控制。前后查找操作使我们可以利用子表达式来指定文本操作的发生位置，并收到只匹配不消费的效果。正向前查找要用<code>(?=)</code>来定义，负向前查找要用<code>(?!)</code>来定义。有些正则表达式实现还支持正向后查找（响应的操作符是<code>(?&lt;=)</code>）和负向后查找（相应的操作符是<code>(?!&lt;)</code>）。</li>
</ul>
<h5 id="十、嵌入条件"><a href="#十、嵌入条件" class="headerlink" title="十、嵌入条件"></a>十、嵌入条件</h5><ul>
<li>10.1、为什么要嵌入条件？(看下面的例子)  <code>(123)456-7890</code>和<code>123-456-7890</code>都是可以接收的北美电话号码格式，而<code>1234567890</code>、<code>(123)-456-789</code>和<code>(123-456-7890)</code>虽然都包含着数字正确的字符，但是格式不对，看下面的匹配  </li>
</ul>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-169.png" alt="">
    
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;123-456-7890\n(123)456-7890\n(123)-456-7890\n(123-456-7890\n1234567890\n123 456 7890&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;\\(?\\d&#123;3&#125;\\)?-?\\d&#123;3&#125;-\\d&#123;4&#125;&quot; ,str: str, font: 24)</span><br></pre></td></tr></table></figure>

分析：`\\(?`匹配的是一个可选的左括号， 请注意，这里必须对`(`进行转义； `\d&#123;3&#125;`匹配前三位数字；`\)?`匹配的是一个可选的右括号；`-？`匹配的是一个可选的连字符  
上面的匹配`\\)?-`如果换做`[\\)-]?`这样的话`)`与`-`只能出现一个就能排除第三行，但是无法排除第4行，正确的匹配应该是：只在电话号码里有一个左括号（的时候才去匹配）。更准确地说，应该是如果电话号码里有一个左括号`（`，我们的模式必须去匹配`）`；如果不是这样，它就必须去匹配`-`,总之这种匹配需要条件。
</code></pre>
<ul>
<li>10.2、正则表达式里的条件  正则表达式里的条件要用<code>?</code>来定义。事实上，你们已经见过几种非常特定的条件了。<ul>
<li><code>?</code>匹配前一个字符或者表达式，如果它存在的话（可有可无）。</li>
<li><code>?=</code>和<code>?&lt;=</code>匹配前面或后面的文本，如果它存在的话。<br>  嵌入条件语法也是用了<code>?</code>,这并没有什么让人感到吃惊的地方，因为嵌入条件不外乎以下两种情况。<ul>
<li>  根据前一个回溯引用来进行条件处理。</li>
<li>  根据前后查找来进行条件处理。</li>
</ul>
</li>
<li>10.2.1、回溯引用条件<br>  回溯引用条件只在一个前面的表达式搜索去的成功的情况下才允许使用一个表达式。看下面的例子，我们需要把一段文本里<code>&lt;IMG&gt;</code>标签全部都找出来；不仅仅如此，如果某个<code>&lt;IMG&gt;</code>标签是一个链接(被括在<A>和</A>标签之间)的话，你还要把整个链接标签匹配出来。<br>  用来定义这种条件的语法是<code>(?(backrefence)truepregex)</code>,其中<code>?</code>表明这是一个条件，括号里的 <code>backrefence</code>是一个回溯引用，<code>truepregex</code>是一个只在<code>backrefence</code>存在时才会被执行的表达式。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;&lt;!-- Nav bar --&gt;\n&lt;TD&gt;\n&lt;A HREF=/home&gt;&lt;IMG SRC=/imges/home.gif&gt;&lt;/A&gt;\n&lt;IMG SRC=/images/spacer.gif&gt;\n&lt;A HREF=/search&gt;&lt;IMG SRC=/imges/home.gif&gt;&lt;/A&gt;\n&lt;/A&gt;\n&lt;IMG SRC=/images/spacer.gif&gt;\n&lt;A HREF=/help&gt;&lt;IMG SRC=/imges/home.gif&gt;\n&lt;/TD&gt;&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;(&lt;[Aa]\\s+[^&gt;]+&gt;\\s*)?&lt;[Ii][Mm][Gg]\\s+[^&gt;]+&gt;(?(1)\\s*&lt;/[Aa]&gt;)&quot; ,str: str, font: 24)</span><br></pre></td></tr></table></figure>
  分析：这个模式不解释是不容易看明白的。<code>(&lt;[Aa]\\s+[^&gt;]+&gt;\\s*)?</code>将匹配一个<code>&lt;A&gt;</code>或<code>&lt;a&gt;</code>(以及<A>或<a>标签的任意属性)，这个标签可有可无（因为这个子表达式的最后有一个<code>?</code>）接下来，<code>&lt;[Ii][Mm][Gg]\\s+[^&gt;]+&gt;</code>匹配一个<code>&lt;IMG&gt;</code>(大小写均可)及其任意属性。<code>(?(1)\\s*&lt;/[Aa]&gt;)</code>是一个回溯引用条件，<code>?(1)</code>的含义是：如果第一个回溯引用条件（局具体到上面就是<A>标签）存在，则使用<code>\s*&lt;/[Aa]&gt;</code>继续进行匹配（换句话说，只有当前面的<A>标签匹配成功，才继续进行后面的匹配）。如果(1)存在，<code>\s*&lt;/[Aa]&gt;</code>将匹配结束标签<code>&lt;/A&gt;</code>之后出现的任意空白字符。<br>  注意：<code>(1)</code>检查第一个回溯引用是否存在，在条件里，回溯引用编号（本例中的1）不需要被转义。因此，<code>?(1)</code>是正确的，<code>?(\\1)</code>不正确（但是也能用）。<br>  我们刚才使用的模式只在给定的条件得到满足时候才执行一个表达式。条件还可以有否表达式，否则表达式只在给定的回溯引用不存在（也就是条件没有得到满足）时才会执行。用来定义这种条件的语法是<code>(?(backrefence)true-regex|false-regex)</code>,这个语法接受一个条件和两个将分别在这个条件得到满足和没有得到满足时执行的表达式。（下面就可以解决上面10.1电话号码的问题）  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;123-456-7890\n(123)456-7890\n(123)-456-7890\n(123-456-7890\n1234567890\n123 456 7890&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;(\\()?\\d&#123;3&#125;(?(1)\\)|-)\\d&#123;3&#125;-\\d&#123;4&#125;&quot; ,str: str, font: 24)</span><br></pre></td></tr></table></figure></li>
</ul>
  分析：从结果上看，这个模式解决了问题，但它是如何解决问题呢？和前面一样，<code>(\\()?</code>也匹配一个可选的左括号，但我们这次把它用括号括起来得到一个子表达式。随后的<code>\d&#123;3&#125;</code>匹配一位数字的区号。<code>(?(1)\\)|-)</code>是一个回溯引用条件，它将根据条件是否得到满足而去匹配<code>)</code>或<code>-</code>:如果<code>(1)</code>存在（也就是找到了一个左括号），<code>\\)</code>必须被匹配；否则，<code>-</code>必须被匹配。这样一来，只有配对出现的括号才会被匹配；如果没有使用括号或括号不配对，电话号码中的区域和其余数字之间的<code>-</code>必须被匹配。</li>
<li>10.2.2、前后查找条件  前后查找条件只在一个向前查找或向后查找操作取得成功的情况下才允许一个表达式被使用。定义一个前后查找条件的语法与定义一个回溯引用的条件的语法大同小异，只需要把回溯引用（括号里的回溯引用标号）替换为一个完整的前后查找表达式就行了。<ul>
<li>  例子一美国邮政编码匹配</li>
</ul>
</li>
</ul>
<img src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-170.png" alt="">
        
<pre><code>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;11111\n22222\n33333-\n44444-4444&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;\\d&#123;5&#125;(-\\d&#123;4&#125;)?&quot; ,str: str, font: 24)</span><br></pre></td></tr></table></figure>
    
    上面例子的更正：
    
    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: String = &quot;11111\n22222\n33333-\n44444-4444&quot;</span><br><span class="line">label.attributedText = textRegex(pattern: &quot;\\d&#123;5&#125;(?(?=-)-\\d&#123;4&#125;)&quot; ,str: str, font: 24)</span><br></pre></td></tr></table></figure>
    
    分析：`\d&#123;5&#125;`匹配前五位数字，接下来是一个`(?(?=-)-\\d&#123;4&#125;)`形式的向前查找条件。这个条件使用了`?=-`来匹配（但不消费）一个连字符，如果条件得到满足(那个连字符存在),`-\\d&#123;4&#125;`将匹配那个连字符和随后的4位数字。这样一来，`33333-`将被排除在最终的匹配结果之外（它有一个连字符，所以满足给定的条件，但那个连字符后面没有必须出现在那里的4位数字）。平时工作中嵌入查找的模式相当少见，这是因为我们往往可以用最简单的办法来达到同样的目的。
    
</code></pre>
<ul>
<li>10.3、总结  在正则表达式里面可以嵌入条件，只有相当条件得到（或者没有得到）满足时，相应的表达式才会被执行。这种条件可以是一个回溯引用（含义是检查该回溯引用是否存在），也可以是一个前后查找的操作。</li>
</ul>
<h5 id="十一、元字符表"><a href="#十一、元字符表" class="headerlink" title="十一、元字符表"></a>十一、元字符表</h5><ul>
<li>11.1、基本的元字符<ul>
<li>  <code>.</code> 匹配任意单个字符</li>
<li>  <code>|</code> 逻辑或操作符</li>
<li>  <code>[]</code> 匹配字符集合中的一个字符</li>
<li>  <code>[^]</code>对集合求非</li>
<li>  <code>-</code> 定义一个区间，如<code>[a-z]</code></li>
<li>  <code>\</code>对下一个字符转义</li>
</ul>
</li>
<li>11.2、数量元字符<ul>
<li>  <code>*</code>匹配前一个字符（子表达式）零次或者多次</li>
<li>  <code>*?</code> 是 <code>*</code>的懒惰型版本</li>
<li>  <code>+</code> 匹配前一个字符（子表达式）的一次或多次重复</li>
<li>  <code>+?</code> 是 <code>+</code>的懒惰型版本</li>
<li>  <code>?</code> 前一个字符可以可无，也就是最多匹配一次</li>
<li>  <code>&#123;n&#125;</code> 匹配前一个字符或者表达式n次</li>
<li>  <code>&#123;m,n&#125;</code>匹配前一个字符或表达式最少m次,最多n次</li>
<li>  <code>&#123;m,&#125;</code>匹配前一个字符至少m次</li>
<li>  <code>&#123;m,&#125;?</code> {m,}的懒惰型版本</li>
</ul>
</li>
<li>11.3、位置元字符<ul>
<li>  <code>^</code>匹配字符串的开头</li>
<li>  <code>\A</code>匹配字符串的开头</li>
<li>  <code>$</code>匹配字符串的结束</li>
<li>  <code>\z</code>匹配字符串的结束</li>
<li>  <code>\&lt;</code>单词匹配的开始</li>
<li>  <code>\&gt;</code>单词匹配的结束</li>
<li>  <code>\b</code> 单词匹配的边界（开头和结束）</li>
<li>  <code>\B</code>是 <code>\b</code>的反义</li>
</ul>
</li>
<li>11.4、特殊字符元字符<ul>
<li>  <code>[\b]</code>退格字符</li>
<li>  <code>\c</code> 匹配一个控制字符</li>
<li>  <code>\d</code> 匹配任意数字字符</li>
<li>  <code>\D</code> 匹配任意非数字字符</li>
<li>  <code>\f</code> 换页符</li>
<li>  <code>\n</code> 换行符</li>
<li>  <code>\r</code> 回车符</li>
<li>  <code>\s</code> 匹配一个空白字符</li>
<li>  <code>\S</code> 匹配一个非空白字符</li>
<li>  <code>\t</code> 制表符（Tab字符）</li>
<li>  <code>\v</code>垂直制表符</li>
<li>  <code>\w</code> 匹配任意数字、字母、下划线以及中文汉字</li>
<li>  <code>\W</code> 匹配任意非数字、非字母、非下划线以及非中文汉字</li>
<li>  <code>\x</code> 匹配一个十六进制数字</li>
<li>  <code>\0</code> 匹配一个八进制数字</li>
</ul>
</li>
<li>11.5、回溯引用和前后查找<ul>
<li>  <code>()</code>定义一个子表达式</li>
<li>  <code>\1</code>匹配第一个子表达式 <code>\2</code>代表匹配第二个子表达式</li>
<li>  <code>?=</code> 向前查找</li>
<li>  <code>?&lt;=</code> 向后查找</li>
<li>  <code>?!</code> 负向前查找</li>
<li>  <code>?&lt;!</code> 负向后查找</li>
<li>  <code>?()</code> 条件 （if then）</li>
<li>  <code>?()|</code> 条件（if then else）</li>
</ul>
</li>
<li>11.6、大小写转换</li>
<li><code>\E</code> 结束\L或\U转换</li>
<li><code>\l</code>把下一个字符转换为小写</li>
<li><code>\L</code>把后面的字符转换为小写直到遇见\E为止</li>
<li><code>\u</code> 把下一个字符转换为大写</li>
<li><code>\U</code> 把后面的字符转换为大写直到遇见\E为止</li>
<li>11.7、匹配模式<ul>
<li>  <code>(?m)</code>分行匹配模式</li>
</ul>
</li>
</ul>
<h5 id="十二、多规则匹配"><a href="#十二、多规则匹配" class="headerlink" title="十二、多规则匹配"></a>十二、多规则匹配</h5><ul>
<li>主要阐述多规则匹配的用法 <code>let pattern = pattern1 + &quot;|&quot; + pattern2 + &quot;|&quot; + pattern3</code> 看下面  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> let str = &quot;@joanking:【周杰伦的歌曲】#大眼睛#小猫咪这么尖叫[偷笑]、@老北: 蝉叫、狼这么尖叫[吃惊]、@乐不思蜀:达芬奇#烧饼#妙的笑到最后[挖鼻屎]！~ http://www.baidu.com&quot;</span><br><span class="line"> do&#123;</span><br><span class="line">   // 1.创建规则</span><br><span class="line">   let pattern1 = &quot;\\[.*?\\]&quot;</span><br><span class="line">   let pattern2 = &quot;@.*?:&quot;</span><br><span class="line">   let pattern3 = &quot;#.*?#&quot;</span><br><span class="line"> </span><br><span class="line">   // 多个规则之间使用 | 符号连接</span><br><span class="line">   let pattern = pattern1 + &quot;|&quot; + pattern2 + &quot;|&quot; + pattern3</span><br><span class="line"> </span><br><span class="line">   // 2.创建正则表达式对象</span><br><span class="line">   let regex = try NSRegularExpression(pattern: pattern, options: NSRegularExpression.Options.caseInsensitive)</span><br><span class="line">   // 3.开始匹配</span><br><span class="line">   let res = regex.matches(in: str, options: NSRegularExpression.MatchingOptions(rawValue: 0), range: NSMakeRange(0, str.count))</span><br><span class="line">   // 4取出结果</span><br><span class="line">   for checkingRes in res</span><br><span class="line">   &#123;</span><br><span class="line">     // print(checkingRes.range)</span><br><span class="line">     print((str as NSString).substring(with: checkingRes.range))</span><br><span class="line">   &#125;</span><br><span class="line">&#125;catch</span><br><span class="line">&#123;</span><br><span class="line">    print(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="十三、正则练习的demo（有心的人可以看看，可以一起讨论一下回溯引用方面的知识，自己理解的不是很好）"><a href="#十三、正则练习的demo（有心的人可以看看，可以一起讨论一下回溯引用方面的知识，自己理解的不是很好）" class="headerlink" title="十三、正则练习的demo（有心的人可以看看，可以一起讨论一下回溯引用方面的知识，自己理解的不是很好）"></a>十三、正则练习的demo（有心的人可以看看，可以一起讨论一下回溯引用方面的知识，自己理解的不是很好）</h5><ul>
<li>  测试用的<a target="_blank" rel="noopener" href="https://gitee.com/JKWC/JKRegex.git">JKRegex</a>demo</li>
</ul>
<p>转载自：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/56da83a4e0ab">https://www.jianshu.com/p/56da83a4e0ab</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">叶落花开</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.yeluohuakai.com/posts/2022/12/c00cef82.html">https://www.yeluohuakai.com/posts/2022/12/c00cef82.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.yeluohuakai.com" target="_blank">叶落花开的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Swift/">Swift</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/2022/12/cbfa38db.html"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Swift - 封装一个正则表达式工具类（附：正则替换、正则匹配样例）</div></div></a></div><div class="next-post pull-right"><a href="/posts/2022/12/3cdeeeb7.html"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Swift 文件读取和写入</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/ava.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">叶落花开</div><div class="author-info__description">持续学习，记录后端技术、web技术，以及对认知、技术变现的思考。</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">186</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div></div></div><div class="card-widget user-map" id="user-map"><div class="item-headline"><i class="fas fa-link"></i><span>友情链接</span></div><div class="item-content"><ul class="entry"><li><a href="/bszs" title="各大高校博士招生信息">各大高校博士招生信息</a></li><li><a target="_blank" rel="noopener" href="https://www.xiaoxinsoft.com" title="小新软件服务">小新软件安装服务</a></li></ul></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Swift-5-0-%E6%AD%A3%E5%88%99%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">Swift 5.0 正则的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%94%A8%E9%80%94%EF%BC%88%E6%90%9C%E7%B4%A2%E5%92%8C%E6%9B%BF%E6%8D%A2%EF%BC%89"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">一、正则表达式的用途（搜索和替换）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8C%B9%E9%85%8D%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6-%E4%B8%8B%E9%9D%A2%E7%9A%84%E9%83%BD%E5%B0%86%E8%B0%83%E7%94%A8textRegex-%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.0.2.</span> <span class="toc-text">二、匹配单个字符(下面的都将调用textRegex()方法)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%8C%B9%E9%85%8D%E4%B8%80%E7%BB%84%E5%AD%97%E7%AC%A6-%E4%B8%8B%E9%9D%A2%E4%BC%9A%E6%B6%89%E5%8F%8A%E5%AD%97%E7%AC%A6%E9%9B%86%E5%90%88"><span class="toc-number">1.0.0.3.</span> <span class="toc-text">三、匹配一组字符(下面会涉及字符集合)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BD%BF%E7%94%A8%E5%85%83%E5%AD%97%E7%AC%A6%EF%BC%88%E5%88%A9%E7%94%A8%E5%85%83%E5%AD%97%E7%AC%A6%E5%8E%BB%E5%8C%B9%E9%85%8D%E7%89%B9%E5%AE%9A%E7%9A%84%E5%AD%97%E7%AC%A6%E6%88%96%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-number">1.0.0.4.</span> <span class="toc-text">四、使用元字符（利用元字符去匹配特定的字符或字符类型）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%87%8D%E5%A4%8D%E5%8C%B9%E9%85%8D"><span class="toc-number">1.0.0.5.</span> <span class="toc-text">五、重复匹配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%BD%8D%E7%BD%AE%E5%8C%B9%E9%85%8D"><span class="toc-number">1.0.0.6.</span> <span class="toc-text">六、位置匹配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E4%BD%BF%E7%94%A8%E5%AD%97%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%85%83%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E6%98%AF%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9E%84%E4%BB%B6"><span class="toc-number">1.0.0.7.</span> <span class="toc-text">七、使用字表达式(元字符和字符是正则表达式的基本构件)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%9B%9E%E6%BA%AF%E5%BC%95%E7%94%A8%EF%BC%8C%E5%89%8D%E5%90%8E%E4%B8%80%E8%87%B4%E5%8C%B9%E9%85%8D"><span class="toc-number">1.0.0.8.</span> <span class="toc-text">八、回溯引用，前后一致匹配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%89%8D%E5%90%8E%E6%9F%A5%E6%89%BE"><span class="toc-number">1.0.0.9.</span> <span class="toc-text">九、前后查找</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%B5%8C%E5%85%A5%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.0.0.10.</span> <span class="toc-text">十、嵌入条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E5%85%83%E5%AD%97%E7%AC%A6%E8%A1%A8"><span class="toc-number">1.0.0.11.</span> <span class="toc-text">十一、元字符表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E5%A4%9A%E8%A7%84%E5%88%99%E5%8C%B9%E9%85%8D"><span class="toc-number">1.0.0.12.</span> <span class="toc-text">十二、多规则匹配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E6%AD%A3%E5%88%99%E7%BB%83%E4%B9%A0%E7%9A%84demo%EF%BC%88%E6%9C%89%E5%BF%83%E7%9A%84%E4%BA%BA%E5%8F%AF%E4%BB%A5%E7%9C%8B%E7%9C%8B%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%B8%80%E8%B5%B7%E8%AE%A8%E8%AE%BA%E4%B8%80%E4%B8%8B%E5%9B%9E%E6%BA%AF%E5%BC%95%E7%94%A8%E6%96%B9%E9%9D%A2%E7%9A%84%E7%9F%A5%E8%AF%86%EF%BC%8C%E8%87%AA%E5%B7%B1%E7%90%86%E8%A7%A3%E7%9A%84%E4%B8%8D%E6%98%AF%E5%BE%88%E5%A5%BD%EF%BC%89"><span class="toc-number">1.0.0.13.</span> <span class="toc-text">十三、正则练习的demo（有心的人可以看看，可以一起讨论一下回溯引用方面的知识，自己理解的不是很好）</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 叶落花开</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'freecloud-0gzubvbebcf38cf6',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.vemoji)'))
      }
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'freecloud-0gzubvbebcf38cf6',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      document.getElementById('twikoo-count').innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://fastly.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>