<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Swift - Realm数据库的使用详解（附样例） | 叶落花开的博客</title><meta name="keywords" content="Swift,Realm,RealmSwift"><meta name="author" content="叶落花开"><meta name="copyright" content="叶落花开"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文代码已升级至Swift4 1，什么是RealmRealm 于2014 年7月发布，是一个跨平台的移动数据库引擎，专门为移动应用的数据持久化而生。其目的是要取代 Core Data 和 SQLite。   2，关于Realm，你要知道下面几点：（1）使用简单，大部分常用的功能（比如插入、查询等）都可以用一行简单的代码轻松完成，学习成本低。（2）Realm 不是基于 Core Data，也不是基于">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift - Realm数据库的使用详解（附样例）">
<meta property="og:url" content="https://www.yeluohuakai.com/posts/2024/09/b294a51a.html">
<meta property="og:site_name" content="叶落花开的博客">
<meta property="og:description" content="本文代码已升级至Swift4 1，什么是RealmRealm 于2014 年7月发布，是一个跨平台的移动数据库引擎，专门为移动应用的数据持久化而生。其目的是要取代 Core Data 和 SQLite。   2，关于Realm，你要知道下面几点：（1）使用简单，大部分常用的功能（比如插入、查询等）都可以用一行简单的代码轻松完成，学习成本低。（2）Realm 不是基于 Core Data，也不是基于">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-09-17T23:46:00.000Z">
<meta property="article:modified_time" content="2024-09-18T03:15:30.242Z">
<meta property="article:author" content="叶落花开">
<meta property="article:tag" content="Swift">
<meta property="article:tag" content="Realm">
<meta property="article:tag" content="RealmSwift">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/favicon.png"><link rel="canonical" href="https://www.yeluohuakai.com/posts/2024/09/b294a51a"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?2f8a615b51582cf280e790200f3527e6";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-LB2ZMBR4ZN"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-LB2ZMBR4ZN');
</script><script>(function(){
var el = document.createElement("script");
el.src = "https://lf1-cdn-tos.bytegoofy.com/goofy/ttzz/push.js?18da2b25537eeea1b5c8819ad9a03fc2279abb7e5ff9fdb01a2409cbd77b8f1db3e414cba65c376eba389ba56d9ee0846cad2206506a6529fe6ee21a7373effb434c445cf6444b10ea9756ea44e128a6";
el.id = "ttzz";
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(el, s);
})(window)
</script><script async="async" crossorigin="anonymous" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6673854567363222"></script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":false,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Swift - Realm数据库的使用详解（附样例）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-09-18 11:15:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/index_code.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/ava.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">258</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">101</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">34</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://support.qq.com/product/377343"><i class="fa-fw fa fa-paper-plane"></i><span> 反馈</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">叶落花开的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://support.qq.com/product/377343"><i class="fa-fw fa fa-paper-plane"></i><span> 反馈</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Swift - Realm数据库的使用详解（附样例）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-17T23:46:00.000Z" title="发表于 2024-09-18 07:46:00">2024-09-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-18T03:15:30.242Z" title="更新于 2024-09-18 11:15:30">2024-09-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/">客户端开发</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/Swift%E5%BC%80%E5%8F%91/">Swift开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span id="" data-flag-title="Swift - Realm数据库的使用详解（附样例）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"></span></span></div></div></div><article class="post-content" id="article-container"><p><code>本文代码已升级至Swift4</code></p>
<p>1，什么是Realm<br>Realm 于2014 年7月发布，是一个跨平台的移动数据库引擎，专门为移动应用的数据持久化而生。其目的是要取代 Core Data 和 SQLite。  </p>
<p>2，关于Realm，你要知道下面几点：<br>（1）使用简单，大部分常用的功能（比如插入、查询等）都可以用一行简单的代码轻松完成，学习成本低。<br>（2）Realm 不是基于 Core Data，也不是基于 SQLite 封装构建的。它有自己的数据库存储引擎。<br>（3）Realm 具有良好的跨平台特性，可以在 iOS 和 Android 平台上共同使用。代码可以使用 Swift 、 Objective-C 以及 Java 语言来编写。<br>（4）Realm 还提供了一个轻量级的数据库查看工具（Realm Browser）。你也可以用它进行一些简单的编辑操作（比如插入和删除操作）  </p>
<p>3，支持的类型</p>
<p>（1）Realm 支持以下的属性类型：Bool、Int8、Int16、Int32、Int64、Double、Float、String、Date（精度到秒）以及Data.</p>
<p>（2）也可以使用 <code>List&lt;object&gt;</code> 和 <code>Object</code> 来建立诸如一对多、一对一之类的关系模型，此外 Object 的子类也支持此功能。</p>
<p>4，Realm的安装配置 </p>
<span id="more"></span>
<p>（1）先去 Realm 的官网去下载最新框架：<a target="_blank" rel="noopener" href="http://static.realm.io/downloads/swift/latest">http://static.realm.io/downloads/swift/latest</a></p>
<p>（2）拖拽 RealmSwift.framework 和 Realm.framework 文件到”Embedded Binaries”选项中。选中 Copy items if needed 并点击 Finish</p>
<p><a target="_blank" rel="noopener" href="https://www.hangge.com/blog/cache/detail_891.html#"><img src="/img/loading.gif" data-original="https://www.hangge.com/blog_uploads/201510/2015100722175619580.png" alt="原文:Swift - Realm数据库的使用详解（附样例）"></a></p>
<p>5，将数据插入到数据库中</p>
<p>下面代码判断默认数据库中是否有数据，如果没有的话将几个自定义对像插入到数据库中。</p>
<p>（1）这里以个人消费记录为例，我们先定义消费类别类，和具体消费记录类  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Foundation</span><br><span class="line">import RealmSwift</span><br><span class="line"> </span><br><span class="line">//消费类型</span><br><span class="line">class ConsumeType:Object &#123;</span><br><span class="line">    //类型名</span><br><span class="line">    @objc dynamic var name = &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//消费条目</span><br><span class="line">class ConsumeItem:Object &#123;</span><br><span class="line">    //条目名</span><br><span class="line">    @objc dynamic var name = &quot;&quot;</span><br><span class="line">    //金额</span><br><span class="line">    @objc dynamic var cost = 0.00</span><br><span class="line">    //时间</span><br><span class="line">    @objc dynamic var date = Date()</span><br><span class="line">    //所属消费类别</span><br><span class="line">    @objc dynamic var type:ConsumeType?</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2）判断数据库记录是否为空，空的话则插入数据库（这里以默认数据库为例）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import RealmSwift</span><br><span class="line"> </span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">     </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">         </span><br><span class="line">        //使用默认的数据库</span><br><span class="line">        let realm = try! Realm()</span><br><span class="line">        //查询所有的消费记录</span><br><span class="line">        let items = realm.objects(ConsumeItem.self)</span><br><span class="line">        //已经有记录的话就不插入了</span><br><span class="line">        if items.count&gt;0 &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        //创建两个消费类型</span><br><span class="line">        let type1 = ConsumeType()</span><br><span class="line">        type1.name = &quot;购物&quot;</span><br><span class="line">        let type2 = ConsumeType()</span><br><span class="line">        type2.name = &quot;娱乐&quot;</span><br><span class="line">         </span><br><span class="line">        //创建三个消费记录</span><br><span class="line">        let item1 = ConsumeItem(value: [&quot;买一台电脑&quot;,5999.00,Date(),type1]) //可使用数组创建</span><br><span class="line">         </span><br><span class="line">        let item2 = ConsumeItem()</span><br><span class="line">        item2.name = &quot;看一场电影&quot;</span><br><span class="line">        item2.cost = 30.00</span><br><span class="line">        item2.date = Date(timeIntervalSinceNow: -36000)</span><br><span class="line">        item2.type = type2</span><br><span class="line">         </span><br><span class="line">        let item3 = ConsumeItem()</span><br><span class="line">        item3.name = &quot;买一包泡面&quot;</span><br><span class="line">        item3.cost = 2.50</span><br><span class="line">        item3.date = Date(timeIntervalSinceNow: -72000)</span><br><span class="line">        item3.type = type1</span><br><span class="line">         </span><br><span class="line">        // 数据持久化操作（类型记录也会自动添加的）</span><br><span class="line">        try! realm.write &#123;</span><br><span class="line">            realm.add(item1)</span><br><span class="line">            realm.add(item2)</span><br><span class="line">            realm.add(item3)</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        //打印出数据库地址</span><br><span class="line">        print(realm.configuration.fileURL ?? &quot;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    override func didReceiveMemoryWarning() &#123;</span><br><span class="line">        super.didReceiveMemoryWarning()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>6，Data类型数据的存取<br>参考另一篇文章：<a target="_blank" rel="noopener" href="https://www.hangge.com/blog/cache/detail_891.htmldetail_1641.html">Swift - Realm数据库中图片的插入、读取（Data类型数据的存储）</a> </p>
<p>7，使用Realm Browser查看数据库  </p>
<p>（1）默认数据库是应用的 Documents 文件夹下的一个名为“default.realm”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//打印出数据库地址</span><br><span class="line">print(realm.configuration.fileURL ?? &quot;&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2）使用 Realm Browser 工具可以很方便的对.realm数据库进行读取和编辑（在 App Store 中搜索 Realm Browser 即可下载）。</p>
<p>可以看到，上面的几个对象已经成功的插入到数据库中来。</p>
<p><a target="_blank" rel="noopener" href="https://www.hangge.com/blog/cache/detail_891.html#"><img src="/img/loading.gif" data-original="https://www.hangge.com/blog_uploads/201510/2015100722181150977.png" alt="原文:Swift - Realm数据库的使用详解（附样例）"></a></p>
<p><a target="_blank" rel="noopener" href="https://www.hangge.com/blog/cache/detail_891.html#"><img src="/img/loading.gif" data-original="https://www.hangge.com/blog_uploads/201510/2015100722181987659.png" alt="原文:Swift - Realm数据库的使用详解（附样例）"></a></p>
<p>8，从数据库中读取记录并显示到表格中来</p>
<p>（1）通过查询操作，Realm 将会返回包含 Object 集合的 Results 实例。Results 的表现和 Array 十分相似，并且包含在 Results 中的对象能够通过索引下标进行访问。 </p>
<p>（2）所有的查询（包括查询和属性访问）在 Realm 中都是延迟加载的，只有当属性被访问时，才能够读取相应的数据。 </p>
<p>（3）查询结果并不是数据的拷贝：修改查询结果（在写入事务中）会直接修改硬盘上的数据。</p>
<p>下面我们把库里的数据加载出来，并通过表格显示出来。</p>
<p>效果图如下：</p>
<p><a target="_blank" rel="noopener" href="https://www.hangge.com/blog/cache/detail_891.html#"><img src="/img/loading.gif" data-original="https://www.hangge.com/blog_uploads/201510/2015100809455074293.png" alt="原文:Swift - Realm数据库的使用详解（附样例）"></a></p>
<p>代码如下：  </p>
<figure class="highlight plaintext"><figcaption><span>UIKit</span></figcaption><table><tr><td class="code"><pre><span class="line">import RealmSwift</span><br><span class="line"> </span><br><span class="line">class ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource  &#123;</span><br><span class="line">     </span><br><span class="line">    @IBOutlet weak var tableView: UITableView!</span><br><span class="line">     </span><br><span class="line">    var dformatter = DateFormatter()</span><br><span class="line">     </span><br><span class="line">    //保存从数据库中查询出来的结果集</span><br><span class="line">    var consumeItems:Results&lt;ConsumeItem&gt;?</span><br><span class="line">     </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">         </span><br><span class="line">        self.dformatter.dateFormat = &quot;MM月dd日 HH:mm&quot;</span><br><span class="line">         </span><br><span class="line">        self.tableView!.delegate = self</span><br><span class="line">        self.tableView!.dataSource = self</span><br><span class="line">        //创建一个重用的单元格</span><br><span class="line">        self.tableView!.register(UITableViewCell.self, forCellReuseIdentifier: &quot;MyCell&quot;)</span><br><span class="line">         </span><br><span class="line">        //使用默认的数据库</span><br><span class="line">        let realm = try! Realm()</span><br><span class="line">        //查询所有的消费记录</span><br><span class="line">        consumeItems = realm.objects(ConsumeItem.self)</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    //在本例中，只有一个分区</span><br><span class="line">    func numberOfSections(in tableView: UITableView) -&gt; Int &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    //返回表格行数（也就是返回控件数）</span><br><span class="line">    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;</span><br><span class="line">        return self.consumeItems!.count</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    //创建各单元显示内容(创建参数indexPath指定的单元）</span><br><span class="line">    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath)</span><br><span class="line">        -&gt; UITableViewCell &#123;</span><br><span class="line">        //同一形式的单元格重复使用，在声明时已注册</span><br><span class="line">        let cell = UITableViewCell(style: .value1, reuseIdentifier: &quot;MyCell&quot;)</span><br><span class="line">        let item = self.consumeItems![indexPath.row]</span><br><span class="line">        cell.textLabel?.text = item.name + &quot; ￥&quot; + String(format: &quot;%.1f&quot;, item.cost)</span><br><span class="line">        cell.detailTextLabel?.text = self.dformatter.string(from: item.date)</span><br><span class="line">        return cell</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    override func didReceiveMemoryWarning() &#123;</span><br><span class="line">        super.didReceiveMemoryWarning()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>9，查询前N条数据<br>Realm无法直接限制查询数量。所以我们如果想要查出部分数据（比如前5条记录），也是全部查出来后在结果集中捞取。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//查询并取出前5条数据</span><br><span class="line">let dogs = try! Realm().objects(Dog.self)</span><br><span class="line">for i in 0..&lt;5 &#123;</span><br><span class="line">    let dog = dogs[i]</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<blockquote>
<p>Realm为何无法限制查询数量？<br>通常查询数据库数据时，我们可以在sql语句中添加一些限制语句（比如rownum，limit，top等）来限制返回的结果集的行数。<br>但我们使用Realm会发现，它没有这种分页功能，感觉不管查什么都是把所有的结果都捞出来。比如我们只要User表的前10条数据，那么做法是先查询出所有的User数据，再从结果集中取出前10条数据。<br>有人可能会担心，如果数据库中数据非常多，那每次都这么查不会影响性能吗？<br>其实大可放心，由于Realm都是延迟加载的，只有当属性被访问时，才能够读取相应的数据。不像通常数据库，查询后，查询结果是从数据库拷贝一份出来放在内存中的。而Realm的查询结果应该说是数据库数据的引用，就算你查出来，如果不用也不会占用什么内存。</p>
</blockquote>
<p>10，支持断言查询(Predicate)，这样可以通过条件查询特定数据<br>同时可以使用链式查询数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//查询花费超过10元的消费记录(使用断言字符串查询)</span><br><span class="line">consumeItems = realm.objects(ConsumeItem.self).filter(&quot;cost &gt; 10&quot;)</span><br><span class="line"> </span><br><span class="line">//查询花费超过10元的购物记录(使用 NSPredicate 查询)</span><br><span class="line">let predicate = NSPredicate(format: &quot;type.name = &#x27;购物&#x27; AND cost &gt; 10&quot;)</span><br><span class="line">consumeItems = realm.objects(ConsumeItem.self).filter(predicate)</span><br><span class="line"> </span><br><span class="line">//使用链式查询</span><br><span class="line">consumeItems = realm.objects(ConsumeItem.self).filter(&quot;cost &gt; 10&quot;).filter(&quot;type.name = &#x27;购物&#x27;&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>支持的断言：</p>
<ul>
<li>  比较操作数(comparison operand)可以是属性名称或者某个常量，但至少有一个操作数必须是属性名称；</li>
<li>  比较操作符 ==、&lt;=、&lt;、&gt;=、&gt;、!=, 以及 BETWEEN 支持 int、long、long long、float、double 以及 NSDate 属性类型的比较，比如说 age == 45；</li>
<li>  相等比较 ==以及!=，比如说Results<Employee>().filter(“company == %@”, company)</li>
<li>  比较操作符 == and != 支持布尔属性；</li>
<li>  对于 NSString 和 NSData 属性来说，我们支持 ==、!=、BEGINSWITH、CONTAINS 以及 ENDSWITH 操作符，比如说 name CONTAINS ‘Ja’；</li>
<li>  字符串支持忽略大小写的比较方式，比如说 name CONTAINS[c] ‘Ja’ ，注意到其中字符的大小写将被忽略；</li>
<li>  Realm 支持以下复合操作符：“AND”、“OR” 以及 “NOT”。比如说 name BEGINSWITH ‘J’ AND age &gt;= 32；</li>
<li>  包含操作符 IN，比如说 name IN {‘Lisa’, ‘Spike’, ‘Hachi’}；</li>
<li>  ==、!=支持与 nil 比较，比如说 Results<Company>().filter(“ceo == nil”)。注意到这只适用于有关系的对象，这里 ceo 是 Company 模型的一个属性。</li>
<li>  ANY 比较，比如说 ANY student.age &lt; 21</li>
<li>注意，虽然我们不支持复合表达式类型(aggregate expression type)，但是我们支持对对象的值使用 BETWEEN 操作符类型。比如说，Results<Person>.filter(“age BETWEEN %@”, [42, 43]])。</li>
</ul>
<p>11，查询结果的排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//查询花费超过10元的消费记录,并按升序排列</span><br><span class="line">consumeItems = realm.objects(ConsumeItem.self).filter(&quot;cost &gt; 10&quot;).sorted(byKeyPath: &quot;cost&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>12，使用List实现一对多关系<br>List 中可以包含简单类型的 Object，表面上和可变的 Array 非常类似。<br>注意：List 只能够包含 Object 类型，不能包含诸如String之类的基础类型。<br>如果打算给我们的 Person 数据模型添加一个“dogs”属性，以便能够和多个“dogs”建立关系，也就是表明一个 Person 可以有多个 Dog，那么我们可以声明一个List类型的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person: Object &#123;</span><br><span class="line">    ... // 其余的属性声明</span><br><span class="line">    let dogs = List&lt;Dog&gt;()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 这里我们就可以使用已存在的狗狗对象来完成初始化</span><br><span class="line">let aPerson = Person(value: [&quot;李四&quot;, 30, [aDog, anotherDog]])</span><br><span class="line"> </span><br><span class="line">// 还可以使用多重嵌套</span><br><span class="line">let aPerson = Person(value: [&quot;李四&quot;, 30, [[&quot;小黑&quot;, 5], [&quot;旺财&quot;, 6]]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以和之前一样，对 List 属性进行访问和赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let someDogs = realm.objects(Dog.self).filter(&quot;name contains &#x27;小白&#x27;&quot;)</span><br><span class="line">ZhangSan.dogs.append(objectsIn: someDogs)</span><br><span class="line">ZhangSan.dogs.append(dahuang)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>反向关系(Inverse Relationship)</p>
<p>通过反向关系(也被称为反向链接(backlink))，您可以通过一个特定的属性获取和给定对象有关系的所有对象。 Realm 提供了“链接对象 (linking objects)” 属性来表示这些反向关系。借助链接对象属性，您可以通过指定的属性来获取所有链接到指定对象的对象。</p>
<p>例如，一个 Dog 对象可以拥有一个名为 owners 的链接对象属性，这个属性中包含了某些 Person 对象，而这些 Person 对象在其 dogs 属性中包含了这一个确定的 Dog 对象。您可以将 owners 属性设置为 LinkingObjects 类型，然后指定其关系，说明其当中包含了 Person 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Dog: Object &#123;</span><br><span class="line">    @objc dynamic var name = &quot;&quot;</span><br><span class="line">    @objc dynamic var age = 0</span><br><span class="line">     </span><br><span class="line">    // Realm 并不会存储这个属性，因为这个属性只定义了 getter</span><br><span class="line">    // 定义“owners”，和 Person.dogs 建立反向关系</span><br><span class="line">    let owners = LinkingObjects(fromType: Person.self, property: &quot;dogs&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>13，添加主键(Primary Keys) </p>
<p>重写 Object.primaryKey() 可以设置模型的主键。</p>
<p>声明主键之后，对象将被允许查询，更新速度更加高效，并且要求每个对象保持唯一性。</p>
<p>一旦带有主键的对象被添加到 Realm 之后，该对象的主键将不可修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person: Object &#123;</span><br><span class="line">    @objc dynamic var id = 0</span><br><span class="line">    @objc dynamic var name = &quot;&quot;</span><br><span class="line">     </span><br><span class="line">    override static func primaryKey() -&gt; String? &#123;</span><br><span class="line">        return &quot;id&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>14，添加索引属性(Indexed Properties)<br>重写 Object.indexedProperties() 方法可以为数据模型中需要添加索引的属性建立索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Book: Object &#123;</span><br><span class="line">    @objc dynamic var price = 0</span><br><span class="line">    @objc dynamic var title = &quot;&quot;</span><br><span class="line">     </span><br><span class="line">    override static func indexedProperties() -&gt; [String] &#123;</span><br><span class="line">        return [&quot;title&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>15，设置忽略属性(Ignored Properties)</p>
<p>重写 Object.ignoredProperties() 可以防止 Realm 存储数据模型的某个属性。Realm 将不会干涉这些属性的常规操作，它们将由成员变量(var)提供支持，并且您能够轻易重写它们的 setter 和 getter。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person: Object &#123;</span><br><span class="line">    @objc dynamic var tmpID = 0</span><br><span class="line">    var name: String &#123; // 计算属性将被自动忽略</span><br><span class="line">        return &quot;\(firstName) \(lastName)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    @objc dynamic var firstName = &quot;&quot;</span><br><span class="line">    @objc dynamic var lastName = &quot;&quot;</span><br><span class="line">     </span><br><span class="line">    override static func ignoredProperties() -&gt; [String] &#123;</span><br><span class="line">        return [&quot;tmpID&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>16，修改更新数据 </p>
<p>（1）直接更新内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 在一个事务中更新对象</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">  consumeItem.name = &quot;去北京旅行&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2）通过主键更新<br>如果您的数据模型中设置了主键的话，那么您可以使用 Realm().add(_:update:) 来更新对象（当对象不存在时也会自动插入新的对象。）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/****** 方式1 ***/</span><br><span class="line">// 创建一个带有主键的“书籍”对象，作为事先存储的书籍</span><br><span class="line">let cheeseBook = Book()</span><br><span class="line">cheeseBook.title = &quot;奶酪食谱&quot;</span><br><span class="line">cheeseBook.price = 9000</span><br><span class="line">cheeseBook.id = 1</span><br><span class="line"> </span><br><span class="line">// 通过 id = 1 更新该书籍</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    realm.add(cheeseBook, update: true)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/****** 方式2 ***/</span><br><span class="line">// 假设带有主键值 `1` 的“书籍”对象已经存在</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    realm.create(Book.self, value: [&quot;id&quot;: 1, &quot;price&quot;: 22], update: true)</span><br><span class="line">    // 这本书的`title`属性不会被改变</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（3）键值编码 </p>
<p>这个是在运行时才能决定哪个属性需要更新的时候，这个对于大量更新的对象极为有用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let persons = realm.objects(Person.self)</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">    // 更新第一个</span><br><span class="line">    persons.first?.setValue(true, forKeyPath: &quot;isFirst&quot;)</span><br><span class="line">    // 将每个人的 planet 属性设置为“地球”</span><br><span class="line">    persons.setValue(&quot;地球&quot;, forKeyPath: &quot;planet&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>17，删除数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let cheeseBook = ... // 存储在 Realm 中的 Book 对象</span><br><span class="line"> </span><br><span class="line">// 在事务中删除一个对象</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">  realm.delete(cheeseBook)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也能够删除数据库中的所有数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 从 Realm 中删除所有数据</span><br><span class="line">try! realm.write &#123;</span><br><span class="line">  realm.deleteAll()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>18，Realm数据库配置 </p>
<p>（1）修改默认的的数据库</p>
<p>通过调用 Realm() 来初始化以及访问我们的 realm 变量。其指向的是应用的 Documents 文件夹下的一个名为“default.realm”的文件。</p>
<p>通过对默认配置进行更改，我们可以使用不同的数据库。比如给每个用户帐号创建一个特有的 Realm 文件，通过切换配置，就可以直接使用默认的 Realm 数据库来直接访问各自数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func setDefaultRealmForUser(username: String) &#123;</span><br><span class="line">    var config = Realm.Configuration()</span><br><span class="line">     </span><br><span class="line">    // 使用默认的目录，但是使用用户名来替换默认的文件名</span><br><span class="line">    config.fileURL = config.fileURL!.deletingLastPathComponent()</span><br><span class="line">        .appendingPathComponent(&quot;\(username).realm&quot;)</span><br><span class="line">     </span><br><span class="line">    // 将这个配置应用到默认的 Realm 数据库当中</span><br><span class="line">    Realm.Configuration.defaultConfiguration = config</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（2）打包进项目里的数据库的使用<br>如果需要将应用的某些数据（比如配置信息，初始化信息等）打包到一个 Realm 文件中，作为主要 Realm 数据库的扩展，操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let config = Realm.Configuration(</span><br><span class="line">    // 获取需要打包文件的 URL 路径</span><br><span class="line">    fileURL: Bundle.main.url(forResource: &quot;MyBundledData&quot;, withExtension: &quot;realm&quot;),</span><br><span class="line">    // 以只读模式打开文件，因为应用数据包并不可写</span><br><span class="line">    readOnly: true)</span><br><span class="line"> </span><br><span class="line">// 通过配置打开 Realm 数据库</span><br><span class="line">let realm = try! Realm(configuration: config)</span><br><span class="line"> </span><br><span class="line">// 通过配置打开 Realm 数据库</span><br><span class="line">let results = realm.objects(Dog.self).filter(&quot;age &gt; 5&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（3）内存数据库<br>内存数据库在每次程序运行期间都不会保存数据。但是，这不会妨碍到 Realm 的其他功能，包括查询、关系以及线程安全。 假如您需要灵活的数据读写但又不想储存数据的话，那么内存数据库对您来说一定是一个不错的选择。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let realm = try! Realm(configuration: Realm.Configuration(inMemoryIdentifier: &quot;MyInMemoryRealm&quot;))</span><br></pre></td></tr></table></figure>
<p>19，加密数据库 </p>
<p>（1）加密后的 Realm文件不能跨平台使用（因为 NSFileProtection 只有 iOS 才可以使用） </p>
<p>（2）Realm 文件不能在没有密码保护的 iOS 设备中进行加密。为了避免这些问题（或者您想构建一个 OS X 的应用），可以使用 Realm 提供的加密方法。 </p>
<p>（3）加密过的 Realm 只会带来很少的额外资源占用（通常最多只会比平常慢10%）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*****   在创建 Realm 数据库时采用64位的密钥对数据库文件进行 AES-256+SHA2 加密   ****/</span><br><span class="line">// 产生随机密钥</span><br><span class="line">var key = Data(count: 64)</span><br><span class="line">_ = key.withUnsafeMutableBytes &#123; bytes in</span><br><span class="line">    SecRandomCopyBytes(kSecRandomDefault, 64, bytes)</span><br><span class="line">&#125;</span><br><span class="line">         </span><br><span class="line">// 打开加密文件</span><br><span class="line">let config = Realm.Configuration(encryptionKey: key)</span><br><span class="line">let realm:Realm</span><br><span class="line">do &#123;</span><br><span class="line">    realm = try Realm(configuration: config)</span><br><span class="line">&#125; catch let error as NSError &#123;</span><br><span class="line">    // 如果密钥错误，`error` 会提示数据库不可访问</span><br><span class="line">    fatalError(&quot;Error opening realm: \(error)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 和往常一样使用 Realm 即可</span><br><span class="line">let dogs = realm.objects(Book.self).filter(&quot;name contains &#x27;Fido&#x27;&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>20，数据迁移(Migration)<br>（1）为何要迁移<br>比如原来有如下 Person 模型：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person: Object &#123;</span><br><span class="line">    @objc dynamic var firstName = &quot;&quot;</span><br><span class="line">    @objc dynamic var lastName = &quot;&quot;</span><br><span class="line">    @objc dynamic var age = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假如我们想要更新数据模型，给它添加一个 fullname 属性， 而不是将“姓”和“名”分离开来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person: Object &#123;</span><br><span class="line">    @objc dynamic var fullName = &quot;&quot;</span><br><span class="line">    @objc dynamic var age = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个时候如果您在数据模型更新之前就已经保存了数据的话，那么 Realm 就会注意到代码和硬盘上数据不匹配。 每当这时，您必须进行数据迁移，否则当您试图打开这个文件的话 Realm 就会抛出错误。</p>
<p>（2）如何进行数据迁移<br>假设我们想要把上面所声明 Person 数据模型进行迁移。如下所示是最简单的数据迁移的必需流程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 在(application:didFinishLaunchingWithOptions:)中进行配置</span><br><span class="line"> </span><br><span class="line">let config = Realm.Configuration(</span><br><span class="line">  // 设置新的架构版本。这个版本号必须高于之前所用的版本号</span><br><span class="line">  // （如果您之前从未设置过架构版本，那么这个版本号设置为 0）</span><br><span class="line">  schemaVersion: 1,</span><br><span class="line"> </span><br><span class="line">  // 设置闭包，这个闭包将会在打开低于上面所设置版本号的 Realm 数据库的时候被自动调用</span><br><span class="line">  migrationBlock: &#123; migration, oldSchemaVersion in</span><br><span class="line">    // 目前我们还未进行数据迁移，因此 oldSchemaVersion == 0</span><br><span class="line">    if (oldSchemaVersion &lt; 1) &#123;</span><br><span class="line">      // 什么都不要做！Realm 会自行检测新增和需要移除的属性，然后自动更新硬盘上的数据库架构</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line">// 告诉 Realm 为默认的 Realm 数据库使用这个新的配置对象</span><br><span class="line">Realm.Configuration.defaultConfiguration = config</span><br><span class="line"> </span><br><span class="line">// 现在我们已经告诉了 Realm 如何处理架构的变化，打开文件之后将会自动执行迁移</span><br><span class="line">let realm = try! Realm()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>虽然这个迁移操作是最精简的了，但是我们需要让这个闭包能够自行计算新的属性（这里指的是 fullName），这样才有意义。 在迁移闭包中，我们能够调用Migration().enumerateObjects(_:_:) 来枚举特定类型的每个 Object 对象，然后执行必要的迁移逻辑。注意，对枚举中每个已存在的 Object 实例来说，应该是通过访问 oldObject 对象进行访问，而更新之后的实例应该通过 newObject 进行访问：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 在 application(application:didFinishLaunchingWithOptions:) 中进行配置</span><br><span class="line"> </span><br><span class="line">Realm.Configuration.defaultConfiguration = Realm.Configuration(</span><br><span class="line">  schemaVersion: 1,</span><br><span class="line">  migrationBlock: &#123; migration, oldSchemaVersion in</span><br><span class="line">    if (oldSchemaVersion &lt; 1) &#123;</span><br><span class="line">      // enumerateObjects(ofType:_:) 方法遍历了存储在 Realm 文件中的每一个“Person”对象</span><br><span class="line">      migration.enumerateObjects(ofType: Person.className()) &#123; oldObject, newObject in</span><br><span class="line">        // 将名字进行合并，存放在 fullName 域中</span><br><span class="line">        let firstName = oldObject![&quot;firstName&quot;] as! String</span><br><span class="line">        let lastName = oldObject![&quot;lastName&quot;] as! String</span><br><span class="line">        newObject![&quot;fullName&quot;] = &quot;\(firstName) \(lastName)&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>21，使用带有 REST API 功能的 Realm 数据库示例<br>我们将从 豆瓣FM的API 那里获取一组 JSON 格式的频道数据，然后将它以 Realm Objects 的形式储存到默认的 Realm 数据库里。 </p>
<p>（1）json数据格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line"> &quot;channels&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name_en&quot;: &quot;Personal Radio&quot;,</span><br><span class="line">            &quot;seq_id&quot;: 0,</span><br><span class="line">            &quot;abbr_en&quot;: &quot;My&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;私人兆赫&quot;,</span><br><span class="line">            &quot;channel_id&quot;: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;华语&quot;,</span><br><span class="line">            &quot;seq_id&quot;: 0,</span><br><span class="line">            &quot;abbr_en&quot;: &quot;&quot;,</span><br><span class="line">            &quot;channel_id&quot;: &quot;1&quot;,</span><br><span class="line">            &quot;name_en&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;欧美&quot;,</span><br><span class="line">            &quot;seq_id&quot;: 1,</span><br><span class="line">            &quot;abbr_en&quot;: &quot;&quot;,</span><br><span class="line">            &quot;channel_id&quot;: &quot;2&quot;,</span><br><span class="line">            &quot;name_en&quot;: &quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2）我们将直接把 Dictionary 插入到 Realm 中，然后让 Realm 自行快速地将其映射到 Object 上。</p>
<p>（从 iOS9 起，新特性要求App访问网络请求，要采用 HTTPS 协议。直接请求HTTP数据会报错，解决办法可以参照的我另一篇文章：<a target="_blank" rel="noopener" href="https://www.hangge.com/blog/cache/detail_891.htmldetail_822.html">Swift - 网络请求报App Transport Security has blocked a cleartext错</a>）<br>为了确保示例能够成功，我们需要一个所有属性完全匹配 JSON 键结构的 Object 结构体。如果 JSON 的键结构不匹配 Object 结构体属性结构的话，那么就会在插入时被忽略。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import RealmSwift</span><br><span class="line"> </span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">     </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">         </span><br><span class="line">        // 调用API</span><br><span class="line">        let url = URL(string: &quot;http://www.douban.com/j/app/radio/channels&quot;)!</span><br><span class="line">        let response = try! Data(contentsOf: url)</span><br><span class="line">         </span><br><span class="line">        // 对 JSON 的回应数据进行反序列化操作</span><br><span class="line">        let json = try! JSONSerialization.jsonObject(with: response,</span><br><span class="line">                                         options: .allowFragments) as! [String:Any]</span><br><span class="line">        let channels = json[&quot;channels&quot;] as! [[String:Any]]</span><br><span class="line">         </span><br><span class="line">        let realm = try! Realm()</span><br><span class="line">        try! realm.write &#123;</span><br><span class="line">            // 为数组中的每个元素保存一个对象（以及其依赖对象）</span><br><span class="line">            for channel in channels &#123;</span><br><span class="line">                if channel[&quot;seq_id&quot;] as! Int == 0 &#123;continue&#125; //第一个频道数据有问题,丢弃掉</span><br><span class="line">                realm.create(DoubanChannel.self, value: channel, update: true)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        print(realm.configuration.fileURL ?? &quot;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    override func didReceiveMemoryWarning() &#123;</span><br><span class="line">        super.didReceiveMemoryWarning()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//豆瓣频道</span><br><span class="line">class DoubanChannel:Object &#123;</span><br><span class="line">    //频道id</span><br><span class="line">    @objc dynamic var channel_id = &quot;&quot;</span><br><span class="line">    //频道名称</span><br><span class="line">    @objc dynamic var name = &quot;&quot;</span><br><span class="line">    //频道英文名称</span><br><span class="line">    @objc dynamic var name_en = &quot;&quot;</span><br><span class="line">    //排序</span><br><span class="line">    @objc dynamic var seq_id = 0</span><br><span class="line">    @objc dynamic var abbr_en = &quot;&quot;</span><br><span class="line">     </span><br><span class="line">    //设置主键</span><br><span class="line">    override static func primaryKey() -&gt; String? &#123;</span><br><span class="line">        return &quot;channel_id&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）可以看到数据已经成功插入到库中了</p>
<p><a target="_blank" rel="noopener" href="https://www.hangge.com/blog/cache/detail_891.html#"><img src="/img/loading.gif" data-original="https://www.hangge.com/blog_uploads/201510/2015100815102987949.png" alt="原文:Swift - Realm数据库的使用详解（附样例）"></a></p>
<p>22，当前版本的限制</p>
<p>Realm 致力于平衡数据库读取的灵活性和性能。为了实现这个目标，在 Realm 中所存储的信息的各个方面都有基本的限制。例如：</p>
<p>（1）类名称的长度最大只能存储 57 个 UTF8 字符。</p>
<p>（2）属性名称的长度最大只能支持 63 个 UTF8 字符。</p>
<p>（3）NSData 以及 String 属性不能保存超过 16 MB 大小的数据。如果要存储大量的数据，可通过将其分解为16MB 大小的块，或者直接存储在文件系统中，然后将文件路径存储在 Realm 中。如果您的应用试图存储一个大于 16MB 的单一属性，系统将在运行时抛出异常。</p>
<p>（4）对字符串进行排序以及不区分大小写查询只支持“基础拉丁字符集”、“拉丁字符补充集”、“拉丁文扩展字符集 A” 以及”拉丁文扩展字符集 B“（UTF-8 的范围在 0~591 之间）。</p>
<p>原文地址：<a target="_blank" rel="noopener" href="https://www.hangge.com/blog/cache/detail_891.html">https://www.hangge.com/blog/cache/detail_891.html</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">叶落花开</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.yeluohuakai.com/posts/2024/09/b294a51a.html">https://www.yeluohuakai.com/posts/2024/09/b294a51a.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.yeluohuakai.com" target="_blank">叶落花开的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Swift/">Swift</a><a class="post-meta__tags" href="/tags/Realm/">Realm</a><a class="post-meta__tags" href="/tags/RealmSwift/">RealmSwift</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/2024/09/4d4367cb.html"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">国内用户一键安装Docker并配置镜像源</div></div></a></div><div class="next-post pull-right"><a href="/posts/2024/09/1b218757.html"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">分拆 View Controller 中的自动布局代码</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/ava.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">叶落花开</div><div class="author-info__description">持续学习，记录后端技术、web技术，以及对认知、技术变现的思考。</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">258</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">101</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">34</div></a></div></div></div><div class="card-widget user-map" id="user-map"><div class="item-headline"><i class="fas fa-link"></i><span>友情链接</span></div><div class="item-content"><ul class="entry"><li><a href="/bszs" title="各大高校博士招生信息">各大高校博士招生信息</a></li><li><a target="_blank" rel="noopener" href="https://www.xiaoxinsoft.com" title="小新软件服务">小新软件安装服务</a></li></ul></div></div><div class="sticky_layout"></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 叶落花开</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'freecloud-0gzubvbebcf38cf6',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.vemoji)'))
      }
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'freecloud-0gzubvbebcf38cf6',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      document.getElementById('twikoo-count').innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://fastly.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>