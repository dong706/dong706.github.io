<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>iOS开发 - Swift实现检测网络连接状态及网络类型</title>
      <link href="/posts/2022/11/3e32d1cc.html"/>
      <url>/posts/2022/11/3e32d1cc.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在移动开发中，检测网络的连接状态尤其检测网络的类型尤为重要。本文将介绍在iOS开发中，如何使用Swift检测网络连接状态及网络类型（移动网络、Wifi）。</p><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><p>Reachability.swift 是一个使用Swift写的第三方网络检测类，可以用来检测网络连接状态及网络类型（移动网络、Wifi）功能。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><ol><li>使用Cocopod安装Reachability.swift<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use_frameworks!</span><br><span class="line">pod &#x27;ReachabilitySwift&#x27;</span><br></pre></td></tr></table></figure><span id="more"></span></li><li>基本使用代码示例</li></ol><p>使用前记得导入ReachabilitySwift类，下面代码放在viewDidLoad()方法中即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var reachability: Reachability!</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">    reachability = try Reachability.reachabilityForInternetConnection()</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    print(&quot;Unable to create Reachability&quot;)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检测网络连接状态</span><br><span class="line">if reachability.isReachable() &#123;</span><br><span class="line">    print(&quot;网络连接：可用&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    print(&quot;网络连接：不可用&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检测网络类型</span><br><span class="line">if reachability.isReachableViaWiFi() &#123;</span><br><span class="line">    print(&quot;网络类型：Wifi&quot;)</span><br><span class="line">&#125; else if reachability.isReachableViaWWAN() &#123;</span><br><span class="line">    print(&quot;网络类型：移动网络&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    print(&quot;网络类型：无网络连接&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>监听网络变化  </li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 网络可用或切换网络类型时执行</span><br><span class="line">reachability.whenReachable = &#123; reachability in</span><br><span class="line"></span><br><span class="line">    // 判断网络状态及类型</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 网络不可用时执行</span><br><span class="line">reachability.whenUnreachable = &#123; reachability in</span><br><span class="line"></span><br><span class="line">    // 判断网络状态及类型</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">    // 开始监听</span><br><span class="line">    try reachability.startNotifier()</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    print(&quot;Unable to start notifier&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>停止监听调用reachability.stopNotifier()即可。</p><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p>Github地址：<a href="https://github.com/ashleymills/Reachability.swift">https://github.com/ashleymills/Reachability.swift</a></p>]]></content>
      
      
      <categories>
          
          <category> 客户端开发 </category>
          
          <category> Swift开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决ANKI启动时OpenGL的问题</title>
      <link href="/posts/2022/11/935d04a.html"/>
      <url>/posts/2022/11/935d04a.html</url>
      
        <content type="html"><![CDATA[<p>在Win10上启动了anki 2.1.22版，出现了<code>Install a driver providing OpenGL 2.0 or higher, or, if this is not possible</code>的错误提醒。类似的问题可见   <a href="https://anki.tenderapp.com/discussions/ankidesktop/36598-installation-issue-with-opengl-file">https://anki.tenderapp.com/discussions/ankidesktop/36598-installation-issue-with-opengl-file</a><br>解决方法：<br>官方的指导文件（ <a href="https://changes.ankiweb.net/#/known-issues%EF%BC%89%E4%B8%AD%E7%9A%84Text">https://changes.ankiweb.net/#/known-issues）中的Text</a> size节中给出了解决方法<br>新建文档，输入以下内容:  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set ANKI_WEBSCALE=0.75</span><br><span class="line">start &quot;Anki&quot; &quot;C:\Program Files\Anki\anki&quot;</span><br></pre></td></tr></table></figure><p>最后保存成startanki.bat，发送快捷方式到桌面,以后都用startant.bat启动ant即可</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> IT技术 </category>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Anki </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot Maven插件打包后，包内没有BOOT-INF目录</title>
      <link href="/posts/2022/11/e2848ec1.html"/>
      <url>/posts/2022/11/e2848ec1.html</url>
      
        <content type="html"><![CDATA[<p>使用maven插件打包后，发现包很小100来kb，显然是不对，包内缺少BOOT-INF目录，BOOT-INF是用于存放引用的外部lib的，所以缺少，打出来的包根本不能运行 。 </p><p>首先尝试使用maven-assembly-plugin来打包，依赖是成功引入了，但是启动会报如下错误</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Caused by: org.springframework.context.ApplicationContextException: </span><br><span class="line">Unable to start ServletWebServerApplicationContext due to missing ServletWebServerFactory bean</span><br></pre></td></tr></table></figure><span id="more"></span> <h3 id="最终解决办法"><a href="#最终解决办法" class="headerlink" title="最终解决办法"></a>最终解决办法</h3><p>在自己项目的pom中，或者父pom中，在plugin中添加executions节点代码，重新打包即可解决。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;repackage&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s创建持久化存储PV和PVC(kubernetes v1.23)</title>
      <link href="/posts/2022/11/26993213.html"/>
      <url>/posts/2022/11/26993213.html</url>
      
        <content type="html"><![CDATA[<h4 id="一、临时存储"><a href="#一、临时存储" class="headerlink" title="一、临时存储"></a>一、临时存储</h4><p>  当pod的存储方案设定为emptydir的时候，pod启动时就会在pod所在节点的磁盘空间开辟出一块空卷，pod启动后容器产生的数据会存放到那个空卷中，供pod内的容器读取和写入数据，一旦pod容器消失，节点上开辟出的这个临时空间就会随着pod销毁。</p><h4 id="二、半持久化存储"><a href="#二、半持久化存储" class="headerlink" title="二、半持久化存储"></a>二、半持久化存储</h4><p>hostpath类型则是映射node文件系统中的文件或者目录到pod里。因为在k8s中pod会漂移，当pod漂移到其他node节点的时候，pod不会跨节点的去读取目录。所以说是一种半持久化的存储方式</p><h4 id="三、持久化存储"><a href="#三、持久化存储" class="headerlink" title="三、持久化存储"></a>三、持久化存储</h4><p>PV是集群中的一块存储，是集群资源，是持久化存储，对存储资源进行抽象。和普通的 Volume 一样，也是使用卷插件来实现的，只是它们拥有独立于任何使用 PV 的 Pod 的生命周期。</p><span id="more"></span> <p>PVC是用户对存储的请求。概念上与 Pod 类似。 Pod 会耗用节点资源，而 PVC 申领会耗用 PV 资源。Pod 可以请求特定数量的资源（CPU 和内存）；同样 PVC 可以请求特定的大小和访问模式。</p><p>PV、PVC生命周期<br><code>Provisioning ——-&gt; Binding ——–&gt;Using——&gt;Releasing——&gt;Recycling</code></p><p>PV和PVC是最常见的使用存储的方式。</p><h5 id="k8s-PV-是什么？"><a href="#k8s-PV-是什么？" class="headerlink" title="k8s PV 是什么？"></a>k8s PV 是什么？</h5><p>PersistentVolume（PV）是群集中的一块存储，由管理员配置或使用存储类动态配置。 它是集群中的资源，就像 pod 是 k8s 集群资源一样。 PV 是容量插件，如 Volumes，其生命周期独立于使用 PV 的任何单个 pod。</p><h5 id="k8s-PVC-是什么？"><a href="#k8s-PVC-是什么？" class="headerlink" title="k8s PVC 是什么？"></a>k8s PVC 是什么？</h5><p> PersistentVolumeClaim（PVC）是一个持久化存储卷，我们在创建 pod 时可以定义这个类型的存储卷。 它类似于一个 pod。 Pod 消耗节点资源，PVC 消耗 PV 资源。 Pod 可以请求特定级别的资源（CPU 和内存）。 pvc 在申请 pv 的时候也可以请求特定的大小和访问模式（例如，可以一次读写或多次只读）。</p><h5 id="创建一个使用PV和PVC的Pod"><a href="#创建一个使用PV和PVC的Pod" class="headerlink" title="创建一个使用PV和PVC的Pod"></a>创建一个使用PV和PVC的Pod</h5><ul><li>配置nfs服务:</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]# yum install nfs-utils rpcbind –y</span><br><span class="line">[root@k8s-master ~]# mkdir /pv-pvc</span><br><span class="line">[root@k8s-master ~]# vi /etc/exports</span><br><span class="line">[root@k8s-master ~]# cat /etc/exports</span><br><span class="line">/pv-pvc *(rw,sync,no_root_squash)</span><br><span class="line">/cloud-demo *(rw,sync,no_root_squash)</span><br></pre></td></tr></table></figure><p>/etc/exports文件参数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/cloud-demo：共享目录</span><br><span class="line">　　*：所有主机能访问</span><br><span class="line">　　rw：读写权限</span><br><span class="line">　　ro：只读</span><br><span class="line">　　sync：同步</span><br><span class="line">　　no_root_squash：不降低root的权限</span><br></pre></td></tr></table></figure><ul><li>重启nfs服务：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]# systemctl restart rpcbind</span><br><span class="line">[root@k8s-master ~]# systemctl restart nfs</span><br><span class="line">[root@k8s-master ~]# systemctl restart nfs-server</span><br></pre></td></tr></table></figure></li><li>查看nfs服务：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]# showmount</span><br><span class="line">Hosts on k8s-master:</span><br><span class="line">[root@k8s-master ~]# showmount -e</span><br><span class="line">Export list for k8s-master:</span><br><span class="line">/cloud-demo *</span><br><span class="line">/pv-pvc     *</span><br></pre></td></tr></table></figure></li><li>开放端口：<br>另外，特别注意，开放端口，不然其他主机不能访问<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcp    111</span><br><span class="line">udp    111</span><br><span class="line">tcp    2049</span><br><span class="line">udp    4046</span><br></pre></td></tr></table></figure></li><li>进入挂载目录创建 pv1 目录 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@master ~]# cd /pv-pvc/</span><br><span class="line">[root@master pv-pvc]# mkdir pv1</span><br><span class="line">[root@master pv-pvc]# ls</span><br><span class="line">pv1</span><br></pre></td></tr></table></figure></li><li>创建PV<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@master tmp]# vi pv1.yaml</span><br><span class="line">[root@master tmp]# kubectl apply -f pv1.yaml</span><br><span class="line">persistentvolume/mypv created</span><br><span class="line">[root@master tmp]# cat pv1.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume   #注意类型</span><br><span class="line">metadata:</span><br><span class="line">  name: mypv    #PVC要调用</span><br><span class="line">spec:</span><br><span class="line">  capacity:     #指定PV容量</span><br><span class="line">    storage: 1Gi</span><br><span class="line">  accessModes:     #指定访问模式</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  persistentVolumeReclaimPolicy: Recycle    #指定回收策略</span><br><span class="line">  nfs:           #配置nfs服务器信息</span><br><span class="line">    path: /cloud-demo/data1</span><br><span class="line">    server: 10.100.57.178</span><br></pre></td></tr></table></figure>————————————————————————————————————————————————<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">accessModes</span><br><span class="line">    ReadWriteOnce: 该卷能够以读写模式被加载到一个节点上。</span><br><span class="line">    ReadOnlyMany： 该卷能够以只读模式加载到多个节点上。</span><br><span class="line">    ReadWriteMany: 改卷能够以读写模式加载到多个节点上。</span><br><span class="line">persistentVolumeReclaimPolicy</span><br><span class="line">    Retain（保留） ：不删除，需手动回收</span><br><span class="line">    Recycle（回收）：基本擦除，类似rm -rf ,使它可供其他PVC申请。</span><br><span class="line">    Delete（删除） ：关联存储将被删除。</span><br></pre></td></tr></table></figure></li><li>查看PV</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@master tmp]# kubectl get pv</span><br><span class="line">NAME   CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE</span><br><span class="line">mypv   1Gi        RWX            Recycle          Available                                   22s</span><br></pre></td></tr></table></figure><ul><li>创建 PVC<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@master tmp]# vi pvc1.yaml</span><br><span class="line">[root@master tmp]# kubectl apply -f pvc1.yaml</span><br><span class="line">persistentvolumeclaim/mypvc created</span><br><span class="line">[root@master tmp]# cat pvc1.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: mypvc</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">   - ReadWriteMany</span><br><span class="line">  volumeName: mypv</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 1Gi</span><br></pre></td></tr></table></figure></li><li>对比查看PV的状态从Avilable变为Bound,pvc的状态也是Bound。  </li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@master tmp]# kubectl get pvc</span><br><span class="line">NAME    STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">mypvc   Bound    mypv     1Gi        RWX                           47s</span><br><span class="line">[root@master tmp]# kubectl get pv</span><br><span class="line">NAME   CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM           STORAGECLASS   REASON   AGE</span><br><span class="line">mypv   1Gi        RWX            Recycle          Bound    default/mypvc                           30m</span><br></pre></td></tr></table></figure><ul><li>创建Pod，使用该PVC<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@master tmp]# vi testpod.yaml</span><br><span class="line">[root@master tmp]# kubectl apply -f testpod.yaml</span><br><span class="line">pod/pvc-pod created</span><br><span class="line">[root@master tmp]# cat testpod.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pvc-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: pvc-pod</span><br><span class="line">    args:</span><br><span class="line">    - /bin/sh</span><br><span class="line">    - -c</span><br><span class="line">    - sleep 30000;</span><br><span class="line">    image: centos</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: /pv-pvc</span><br><span class="line">      name: pvc-volume</span><br><span class="line">  volumes:</span><br><span class="line">    - name: pvc-volume</span><br><span class="line">      persistentVolumeClaim:</span><br><span class="line">        claimName: mypvc</span><br></pre></td></tr></table></figure></li><li>另一个使用PVC示例：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: newshomebg</span><br><span class="line">  namespace: mod</span><br><span class="line">  labels:</span><br><span class="line">    app: newshomebg</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: newshomebg</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: newshomebg</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: newshomebg</span><br><span class="line">        image: xxx</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8080</span><br><span class="line">        env:</span><br><span class="line">        - name: SPRING_DATASOURCE_USERNAME</span><br><span class="line">          value: &#x27;root&#x27;</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: nfs-volume            #设置的名称，和下面的name要一样的</span><br><span class="line">          mountPath: /home/uploads    #需要挂载的目录</span><br><span class="line">          subPath: newshomebg         #卷的子目录，也就是在nfs服务目录里生成这个子目录</span><br><span class="line">      volumes:</span><br><span class="line">      - name: nfs-volume              #这个卷的名称，和上面的name要一样的</span><br><span class="line">        nfs:                          #这里是nfs挂载</span><br><span class="line">          server: 192.168.1.2         #nfs服务器的ip或者域名</span><br><span class="line">          path: &quot;/data&quot;               #nfs服务配置的挂载目录</span><br><span class="line">      imagePullSecrets:</span><br><span class="line">      - name: xxx</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8s </tag>
            
            <tag> 存储卷 </tag>
            
            <tag> PVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s的各种命令(v1.23)</title>
      <link href="/posts/2022/11/8c1fadce.html"/>
      <url>/posts/2022/11/8c1fadce.html</url>
      
        <content type="html"><![CDATA[<ul><li><p><strong>列出所有运行的Pod信息</strong><br><code> kubectl get pods</code></p></li><li><p><strong>列出Pod以及运行Pod节点信息。（#加-o可以把node列出来，也就是pod在哪个节点上能列出来）</strong><br><code>kubectl get pods -o wide</code></p></li><li><p><strong>列出指定NAME的 replication controller信息</strong><br><code>kubectl get replicationcontroller web</code></p></li><li><p><strong>以JSON格式输出一个pod信息</strong><br><code>kubectl get -o json pod web-pod-13je7</code></p><span id="more"></span></li><li><p><strong>以“pod.yaml”配置文件中指定资源对象和名称输出JSON格式的Pod信息</strong><br><code>kubectl get -f pod.yaml -o json</code></p></li><li><p><strong>返回指定pod的相位值</strong><br><code>kubectl get -o template pod/web-pod-13je7 --template=&#123;&#123;.status.phase&#125;&#125;</code></p></li><li><p><strong>列出所有replication controllers和service信息</strong><br><code>kubectl get rc,services</code></p></li><li><p><strong>按其资源和名称列出相应信息</strong><br><code>kubectl get rc/web service/frontend pods/web-pod-13je7</code></p></li><li><p><strong>列出所有不同的资源对象</strong><br><code>kubectl get all</code></p></li><li><p><strong>查看ip和端口，也叫端点</strong><br><code>kubectl get ep　　　　 #获取service的endpoint信息</code></p></li><li><p><strong>进入POD内部命令行</strong>： </p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># nacos-0为pod名称</span><br><span class="line">kubectl exec -it nacos-0 bash</span><br></pre></td></tr></table></figure><p>会提示：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl exec [POD] [COMMAND] is DEPRECATED and will be removed in a future version. Use kubectl exec [POD] -- [COMMAND] instead.</span><br></pre></td></tr></table></figure><p>用新版本的命令代替即可:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl exec --stdin --tty nacos-0 -- /bin/bash</span><br></pre></td></tr></table></figure><ul><li><strong>查看 kube-dns 的服务详情</strong>  </li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get svc kube-dns -n kube-system</span><br></pre></td></tr></table></figure><p>Kubernetes 集群中部署了一套 DNS 服务，通过 kube-dns 的服务名暴露 DNS 服务。<br>服务后端是两个名为 coredns（下文会介绍 CoreDNS 解析原理） 的 Pod。您可执行以下命令查看 coredns 的 Pod 详情。  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get deployment coredns -n kube-system</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift - 延时执行的四种方式</title>
      <link href="/posts/2022/11/6d94e118.html"/>
      <url>/posts/2022/11/6d94e118.html</url>
      
        <content type="html"><![CDATA[<p>Swift - 延时执行的四种方式  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1.perform(必须在主线程中执行)</span><br><span class="line">self.perform(#selector(delayExecution), with: nil, afterDelay: 3)</span><br><span class="line">// 取消</span><br><span class="line">NSObject.cancelPreviousPerformRequests(withTarget: self)</span><br><span class="line"></span><br><span class="line">// 2.timer(必须在主线程中执行)</span><br><span class="line">Timer.scheduledTimer(timeInterval: 3, target: self, selector: #selector(delayExecution), userInfo: nil, repeats: false)</span><br><span class="line"></span><br><span class="line">// 3.Thread (在主线程会卡主界面)</span><br><span class="line">Thread.sleep(forTimeInterval: 3)</span><br><span class="line">self.delayExecution()</span><br><span class="line"></span><br><span class="line">// 4.GCD 主线程/子线程</span><br><span class="line">DispatchQueue.main.asyncAfter(deadline: .now() + 3) &#123;</span><br><span class="line">    self.delayExecution()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DispatchQueue.global().asyncAfter(deadline: .now() + 3) &#123;</span><br><span class="line">    self.delayExecution()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span> ]]></content>
      
      
      <categories>
          
          <category> 客户端开发 </category>
          
          <category> Swift开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows下hexo博客迁移</title>
      <link href="/posts/2022/11/6b073e5.html"/>
      <url>/posts/2022/11/6b073e5.html</url>
      
        <content type="html"><![CDATA[<h3 id="Hexo用户指南-博客迁移"><a href="#Hexo用户指南-博客迁移" class="headerlink" title="Hexo用户指南 - 博客迁移"></a>Hexo用户指南 - 博客迁移</h3><p>GitHub+Hexo搭建博客的过程比较平滑，但是它的配置却非常耗时，一旦电脑出现问题或者需要在另外一台电脑上写博客，那么Hexo博客的迁移非常就让人头疼。下面参考其他博客的方法，针对类似问题，整理出一个能在平时就管理重要文件的方法，方便随时迁移。  </p><h4 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h4><h5 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h5><p>1、安装Git客户端</p><p>2、安装node.JS</p><span id="more"></span> <h5 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h5><p>在cmd任意路径下输入下面指令安装hexo:</p><p><code>npm install hexo-cli -g  </code></p><h5 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h5><p>在D:/MyBlog目录下执行 <code>hexo init</code></p><h5 id="源文件拷贝"><a href="#源文件拷贝" class="headerlink" title="源文件拷贝"></a>源文件拷贝</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_config.yml</span><br><span class="line"></span><br><span class="line">package.json</span><br><span class="line"></span><br><span class="line">scaffolds/</span><br><span class="line"></span><br><span class="line">source/</span><br><span class="line"></span><br><span class="line">themes/</span><br><span class="line"></span><br><span class="line">.ssh (这个文件在Administrator目录下)</span><br></pre></td></tr></table></figure><h5 id="安装相关模块"><a href="#安装相关模块" class="headerlink" title="安装相关模块"></a>安装相关模块</h5><p>执行<code>npm install</code>安装相关模块</p><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>这个时候就可以用<code>hexo s</code>来看到你的博客是否迁移成功</p><h5 id="部署发布文章"><a href="#部署发布文章" class="headerlink" title="部署发布文章"></a>部署发布文章</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean // 清除缓存 网页正常情况下可以忽略此条命令</span><br><span class="line"></span><br><span class="line">hexo g // 生成静态网页</span><br><span class="line"></span><br><span class="line">hexo d // 开始部署</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web技术 </category>
          
          <category> Hexo搭建博客教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-admin设置用户名及密码</title>
      <link href="/posts/2022/11/2e087959.html"/>
      <url>/posts/2022/11/2e087959.html</url>
      
        <content type="html"><![CDATA[<h3 id="安装hexo插件"><a href="#安装hexo插件" class="headerlink" title="安装hexo插件"></a>安装hexo插件</h3><h4 id="安装并使用hexo-admin"><a href="#安装并使用hexo-admin" class="headerlink" title="安装并使用hexo-admin"></a>安装并使用hexo-admin</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-admin</span><br><span class="line">hexo -s</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以运行hexo，接下来在浏览器地址栏粘贴这个地址，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:4000/admin/</span><br></pre></td></tr></table></figure><p>就可以直接在浏览器里用markdown写博文了。  </p><span id="more"></span> <p>但是为了安全，在进入/admin时，增加一层账户密码的校验逻辑，插件也提供了安全验证 。 </p><h4 id="设置后台密码"><a href="#设置后台密码" class="headerlink" title="设置后台密码"></a>设置后台密码</h4><p>1 得到你的password_hash，进入Settings &gt; Setup authentification，如下图所示：</p><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-41.png" alt=""> <p>得到如下图所示内容：</p><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-42.png" alt=""><p>修改站点配置文件_config.yml，将上面得到的内容粘贴进去:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># admin</span><br><span class="line">admin:</span><br><span class="line">  username: ****</span><br><span class="line">  password_hash: ZwrRbx0gZl8myLbI9/oA4T4TxgSxE.</span><br><span class="line">  secret: *****</span><br></pre></td></tr></table></figure><p>然后<code>hexo s</code>重新启动服务，访问<code>http://localhost:4000/admin/</code>就打开登录界面了。<br>至此，为hexo-admin设置用户名和密码完成。</p>]]></content>
      
      
      <categories>
          
          <category> Web技术 </category>
          
          <category> Hexo搭建博客教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署Tomcat和Web应用及整体打包镜像</title>
      <link href="/posts/2022/05/768a9d0d.html"/>
      <url>/posts/2022/05/768a9d0d.html</url>
      
        <content type="html"><![CDATA[<h3 id="拉取Tomcat镜像"><a href="#拉取Tomcat镜像" class="headerlink" title="拉取Tomcat镜像"></a>拉取Tomcat镜像</h3><p>这里只拉取一个Tomcat容器，运行一个简单的web项目，确保整个docker可以正常运行。</p><p>查看Tomcat镜像：<code>docker search tomcat</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-03 ~]# docker search tomcat</span><br><span class="line">NAME                                           DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">tomcat                                         Apache Tomcat is an open source implementati…   3326      [OK]</span><br><span class="line">tomee                                          Apache TomEE is an all-Apache Java EE certif…   97        [OK]</span><br><span class="line">bitnami/tomcat                                 Bitnami Tomcat Docker Image                     45                   [OK]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><span id="more"></span> <p>下载下来官方的镜像Starts最高的那个: <code>docker pull tomcat</code>,默认下载最新版本tomcat。但是我们需要的是8.5版本的tomcat，所以指定一下版本号：<code>docker pull tomcat:8.5.50</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-03 ~]# docker pull tomcat:8.5.50</span><br><span class="line">8.5.50: Pulling from library/tomcat</span><br><span class="line">dc65f448a2e2: Pull complete</span><br><span class="line">346ffb2b67d7: Pull complete</span><br><span class="line">dea4ecac934f: Pull complete</span><br><span class="line">8ac92ddf84b3: Pull complete</span><br><span class="line">d8ef64070a18: Pull complete</span><br><span class="line">6577248b0d6e: Pull complete</span><br><span class="line">576c0a3a6af9: Pull complete</span><br><span class="line">6e0159bd18db: Pull complete</span><br><span class="line">944191e51caa: Pull complete</span><br><span class="line">9ee6a5ca751e: Pull complete</span><br><span class="line">Digest: sha256:d53c2079ea67db92f6d7c39e9450f641610336016fdddef5392c5afd41518e5e</span><br><span class="line">Status: Downloaded newer image for tomcat:8.5.50</span><br><span class="line">docker.io/library/tomcat:8.5.50</span><br></pre></td></tr></table></figure><p>完成后查看本地镜像：<code>docker images</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-03 ~]# docker images</span><br><span class="line">REPOSITORY                                                        TAG           IMAGE ID       CREATED         SIZE</span><br><span class="line">tomcat                                                            latest        5eb506608219   8 days ago      685MB</span><br><span class="line">tomcat                                                            8.5.50        b56d8850aed5   2 years ago     529MB</span><br></pre></td></tr></table></figure><p>启动tomcat镜像，创建一个容器<br><code>docker run --name tomcat -d -p 8080:8080 tomcat:8.5.50</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-03 ~]# docker run --name tomcat -d -p 8080:8080 tomcat:8.5.50</span><br><span class="line">88ec3e189e60238d791bb3195e3d58d30ec1ecdb2721f8a567d597e26c54431b</span><br></pre></td></tr></table></figure><p>查看进程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-03 ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS          PORTS                    NAMES</span><br><span class="line">d0224f53abaf   tomcat:8.5.50   &quot;catalina.sh run&quot;   12 minutes ago   Up 12 minutes   0.0.0.0:8080-&gt;8080/tcp   tomcat</span><br></pre></td></tr></table></figure><p>查看8080端口是否已监听</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-03 ~]# netstat -anp|grep 8080</span><br><span class="line">tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      5289/docker-proxy</span><br></pre></td></tr></table></figure><p>在主机中 ，实时查看docker容器日志</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker logs -f -t --tail 行数 容器名[containerID]  </span><br><span class="line">-f  按日志输出</span><br><span class="line">-t  显示时间戳</span><br></pre></td></tr></table></figure><p>通过docker ps命令查到containerID为 d0224f53abaf ,敲入如下命令查看日志：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker logs -f -t --tail 1000 d0224f53abaf</span><br></pre></td></tr></table></figure><p>进入容器（containerID 是容器的ID）：<code>docker exec -it containerID /bin/bash</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it d0224f53abaf /bin/bash</span><br></pre></td></tr></table></figure><h3 id="加载web应用"><a href="#加载web应用" class="headerlink" title="加载web应用"></a>加载web应用</h3><p>将准备的工程直接上传到服务器(我这里是ROOT.zip,上传到/root目录下，然后解压)。</p><p>通过docker的cp功能将文件复制到容器中去:<br><code>docker cp ROOT d0224f53abaf:/usr/local/tomcat/webapps</code>  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-03 ~]# docker cp ROOT d0224f53abaf:/usr/local/tomcat/webapps</span><br><span class="line">[root@k8s-03 ~]# docker exec -it d0224f53abaf /bin/bash</span><br><span class="line">root@d0224f53abaf:/usr/local/tomcat# cd webapps</span><br><span class="line">root@d0224f53abaf:/usr/local/tomcat/webapps# ls</span><br><span class="line">ROOT</span><br></pre></td></tr></table></figure><p>这里复制完成后Tomcat容器不需要重启就会自动编译运行项目，看Tomcat日志:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2022-05-26T09:21:58.377404648Z 26-May-2022 09:21:58.376 INFO [localhost-startStop-2] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory [/usr/local/tomcat/webapps/ROOT]</span><br><span class="line">2022-05-26T09:22:00.412601936Z 26-May-2022 09:22:00.412 INFO [localhost-startStop-2] org.apache.jasper.servlet.TldScanner.scanJars At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.</span><br><span class="line">2022-05-26T09:22:06.579693865Z 26-May-2022 09:22:06.579 INFO [localhost-startStop-2] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [/usr/local/tomcat/webapps/ROOT] has finished in [8,203] ms</span><br></pre></td></tr></table></figure><p>现在通过 <a href="http://ip:8080/">http://ip:8080/</a> 就能访问目标服务器上的tomcat服务了。</p><h3 id="重新运行镜像"><a href="#重新运行镜像" class="headerlink" title="重新运行镜像"></a>重新运行镜像</h3><p>重新运行镜像要先停止镜像然后删除，之后才能重新运行镜像。<br>停止运行镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#docker container kill [containerID]  #手動停止容器</span><br><span class="line">docker container kill d0224f53abaf</span><br></pre></td></tr></table></figure><p>删除容器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rm tomcat</span><br></pre></td></tr></table></figure><p>另外，还有个删除镜像的命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#docker rmi CONTAINERID</span><br><span class="line">docker rmi  d0224f53abaf</span><br></pre></td></tr></table></figure><h3 id="打包新镜像"><a href="#打包新镜像" class="headerlink" title="打包新镜像"></a>打包新镜像</h3><p>从容器创建一个新的镜像。</p><p>使用的命令：commit</p><p>语法：docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</p><p>OPTIONS可添加属性说明：</p><p>   -a :提交的镜像作者；</p><p>   -c :使用Dockerfile指令来创建镜像；</p><p>   -m :提交时的说明文字；</p><p>   -p :在commit时，将容器暂停。</p><p>这里我们使用已经添加了Java Web项目的Tomcat容器创建镜像：</p><p><code>docker commit -a &quot;dx&quot; -m &quot;tomcat-web-demo&quot; d0224f53abaf tomcatwebdemo:v1.0</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-03 ~]# docker commit -a &quot;dx&quot; -m &quot;tomcat-web-demo&quot; d0224f53abaf tomcatwebdemo:v1.0</span><br><span class="line">sha256:a562a5fc5062871190cedc4e6a2e517affba1c59845210bb7a7942fb86b098d7</span><br></pre></td></tr></table></figure><p>创建完查看本地镜像：docker images可以看到我们新创建的镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-03 ~]# docker images</span><br><span class="line">REPOSITORY                                                        TAG           IMAGE ID       CREATED          SIZE</span><br><span class="line">tomcatwebdemo                                                     v1.0          a562a5fc5062   57 seconds ago   535MB</span><br></pre></td></tr></table></figure><p>现在来直接运行这个新镜像:<br><code>docker run --name tomcatwebdemo -d -p 8081:8080 tomcatwebdemo:v1.0</code></p><p>浏览器访问新容器端口;测试成功。<br><code>http://ip:8080/</code></p><p>至此，我们就完成了一次多层镜像的创建。</p><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><h4 id="推送镜像到仓库"><a href="#推送镜像到仓库" class="headerlink" title="推送镜像到仓库"></a>推送镜像到仓库</h4><p>打标签 <code>docker tag tomcatwebdemo:v2.0 10.100.57.178:5000/jfinaldemo:v2.0</code><br>推送 <code>docker push 10.100.57.178:5000/jfinaldemo:v2.0</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker commit -a &quot;dx&quot; -m &quot;jfinalauthdemo&quot; d0224f53abaf jfinalauthdemo:v4.0  </span><br><span class="line">docker run --name jfinalauthdemo -d -p 7999:7999 jfinalauthdemo:v4.0  </span><br><span class="line">#打标签  </span><br><span class="line">docker tag jfinalauthdemo:v4.0 10.100.57.178:5000/jfinalauthdemo:v4.0</span><br><span class="line">#推送到仓库  </span><br><span class="line">docker push 10.100.57.178:5000/jfinalauthdemo:v4.0</span><br></pre></td></tr></table></figure><h4 id="把host主机中的文件和容器相互拷贝"><a href="#把host主机中的文件和容器相互拷贝" class="headerlink" title="把host主机中的文件和容器相互拷贝"></a>把host主机中的文件和容器相互拷贝</h4><p>docker cp 容器名：要拷贝的文件在容器里面的路径       要拷贝到宿主机的相应路径<br>docker cp 宿主机的相应路径  容器名：要拷贝的文件在容器里面的路径  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker cp d0224f53abaf:/usr/local/tomcat/conf/server.xml /root/  </span><br><span class="line">docker cp /root/server.xml d0224f53abaf:/usr/local/tomcat/conf/  </span><br><span class="line"># 查看容器日志</span><br><span class="line">kubectl logs -f jfinaldemo-666b497ccf-98j5j -n=default</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
            <tag> k8s </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用moviepy提取视频中的音频</title>
      <link href="/posts/2022/05/2ad0cdc4.html"/>
      <url>/posts/2022/05/2ad0cdc4.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MoviePy是一个用于视频编辑的Python模块，它可被用于一些基本操作（如剪切、拼接、插入标题）、视频合成（即非线性编辑）、视频处理和创建高级特效。它可对大多数常见视频格式进行读写，包括GIF。</p><h2 id="安装moviepy"><a href="#安装moviepy" class="headerlink" title="安装moviepy"></a>安装moviepy</h2><blockquote><p>环境要求:Python2.7以上及Python3</p></blockquote><p>安装其实比较简单了，执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install moviepy</span><br></pre></td></tr></table></figure><span id="more"></span> <blockquote><p>MoviePy依赖 Numpy 、 imageio 、 Decorator 和 tqdm ，他们将在安装MoviePy的同时自动安装。运行平台为Windows/Mac/Linux，并使用Python2.7以上的版本和Python3。</p></blockquote><blockquote><p>MoviePy依赖FFMPEG软件对视频进行读写，可以自行安装。在你第一次使用MoviePy的时候，FFMPEG将会自动由ImageIO下载和安装（不过需要花一些时间）。如果你想使用FFMPEG的特定版本，你可以设置FFMPEG_BINARY环境变量。  </p></blockquote><h2 id="提取音频"><a href="#提取音频" class="headerlink" title="提取音频"></a>提取音频</h2><p>三行代码搞定</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1、使用moviepy模块 提取视频中的音频文件</span><br><span class="line">from moviepy.editor import AudioFileClip</span><br><span class="line"></span><br><span class="line">my_audio_clip = AudioFileClip(&quot;test.mp4&quot;)</span><br><span class="line"></span><br><span class="line">#  提取视频中的音频文件  m4v,mp3等音频格式也是支持的</span><br><span class="line">my_audio_clip.write_audiofile(&quot;test.mp3&quot;)</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>后续将提供从文件夹下的所有视频中批量提取音频的相关代码。</p>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频剪辑 </tag>
            
            <tag> 音频提取 </tag>
            
            <tag> Moviepy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7 k8s 1.23.3 安装部署</title>
      <link href="/posts/2022/05/eec2f1a3.html"/>
      <url>/posts/2022/05/eec2f1a3.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>系统环境: CentOS Linux release 7.8.2003 (Core)</p></li><li><p>硬件要求: Cpu调整为2 core  内存调整为 2000M   ( 必须 )</p></li><li><p>网络环境:   </p></li></ul><p>IP 根据当前环境自行调整:  </p><table><thead><tr><th>主机名</th><th>IP</th></tr></thead><tbody><tr><td>k8s-master</td><td>192.168.1.104</td></tr><tr><td>k8s-node1</td><td>192.168.1.105</td></tr><tr><td>k8s-node2</td><td>192.168.1.106</td></tr></tbody></table><span id="more"></span> <h3 id="可能多次使用的命令"><a href="#可能多次使用的命令" class="headerlink" title="可能多次使用的命令:"></a>可能多次使用的命令:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 重置配置: </span><br><span class="line">kubeadm reset</span><br><span class="line"></span><br><span class="line"># 查看日志: </span><br><span class="line">journalctl -f -u kubelet</span><br><span class="line"></span><br><span class="line"># 查看接点加入方式: </span><br><span class="line">kubeadm token create --print-join-command </span><br><span class="line"></span><br><span class="line"># 删除方式, 此处添加参数 `--grace-period=0 --force` 用于强制从node删除对应的 container , (未知原因有时container不会删除)</span><br><span class="line">kubectl delete -f deployment.yaml --grace-period=0 --force</span><br><span class="line"></span><br><span class="line"># </span><br><span class="line">systemctl restart kubelet</span><br><span class="line">systemctl status kubelet</span><br><span class="line"></span><br><span class="line"># ingress 查看</span><br><span class="line">kubectl apply -f ingress.yaml</span><br><span class="line">kubectl get ing </span><br><span class="line">kubectl get ingress</span><br><span class="line"># https://github.com/kubernetes/ingress-nginx</span><br><span class="line"># https://kubernetes.io/docs/concepts/services-networking/ingress/</span><br><span class="line"></span><br><span class="line"># ingress-nginx 部署使用及原理简介</span><br><span class="line">参考: https://blog.51cto.com/u_14034751/2647904</span><br><span class="line"># 新版本配置: https://www.cnblogs.com/Netsharp/p/15501138.html</span><br><span class="line"># https://blog.csdn.net/qq_39218530/article/details/115372879</span><br><span class="line"></span><br><span class="line">iptables -nL    #查看iptables策略</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line"></span><br><span class="line"># 如果出现 cnixxx 相关的错误, 可能是因为调整了cidr的值导致的, 可用以下命令进行清理</span><br><span class="line">ip link set cni0 down</span><br><span class="line">brctl delbr cni0</span><br><span class="line">systemctl restart kubelet</span><br><span class="line"></span><br><span class="line">命令方式：nmcli</span><br><span class="line">nmtui要求安装了NetworkManager-tui包</span><br><span class="line">nmcli要求安装了NetworkManager包</span><br><span class="line">注：nmtui与nmcli均是通过NetworkManager实现对网络进行配置</span><br><span class="line">设置k8s环境准备条件</span><br></pre></td></tr></table></figure><p>分别设置主机名:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置 k8s-master 主机名 </span><br><span class="line">hostnamectl set-hostname k8s-master</span><br><span class="line">echo &#x27;192.168.1.104 k8s-master&#x27; &gt;&gt; /etc/hosts</span><br><span class="line">echo &#x27;192.168.1.105 k8s-node1&#x27; &gt;&gt; /etc/hosts</span><br><span class="line">echo &#x27;192.168.1.106 k8s-node2&#x27; &gt;&gt; /etc/hosts</span><br><span class="line"></span><br><span class="line"># 设置 k8s-node1 主机名 </span><br><span class="line">hostnamectl set-hostname k8s-node1</span><br><span class="line">echo &#x27;192.168.1.105 k8s-node1&#x27; &gt;&gt; /etc/hosts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 设置 k8s-node2 主机名 </span><br><span class="line">hostnamectl set-hostname k8s-node2</span><br><span class="line">echo &#x27;192.168.1.106 k8s-node2&#x27; &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure><h3 id="基础环境配置-k8s-master"><a href="#基础环境配置-k8s-master" class="headerlink" title="基础环境配置:  k8s-master"></a>基础环境配置:  k8s-master</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 关闭selinux</span><br><span class="line"># 临时禁用selinux</span><br><span class="line">setenforce 0</span><br><span class="line"></span><br><span class="line"># 禁用交换分区</span><br><span class="line">swapoff -a</span><br><span class="line"># 永久禁用，打开/etc/fstab注释掉swap那一行。</span><br><span class="line">sed -i &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"></span><br><span class="line"># 删除之前的cni 网络信息 </span><br><span class="line">ip link set cni0 down</span><br><span class="line">brctl delbr cni0</span><br><span class="line"></span><br><span class="line"># 安装依赖</span><br><span class="line">yum install -y epel-release conntrack ipvsadm ipset jq sysstat curl iptables libseccomp</span><br><span class="line"></span><br><span class="line"># 关闭防火墙</span><br><span class="line">systemctl disable firewalld &amp;&amp; systemctl stop firewalld</span><br><span class="line"></span><br><span class="line"># 设置iptables</span><br><span class="line">iptables -F &amp;&amp; iptables -X &amp;&amp; iptables -F -t nat &amp;&amp; iptables -X -t nat &amp;&amp; iptables -P FORWARD ACCEPT</span><br><span class="line"></span><br><span class="line"># 禁用 SELinux</span><br><span class="line"># 永久关闭 修改/etc/sysconfig/selinux文件设置</span><br><span class="line">sed -i &#x27;s/SELINUX=permissive/SELINUX=disabled/&#x27; /etc/sysconfig/selinux</span><br><span class="line">sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/config</span><br><span class="line"></span><br><span class="line"># 加载内核模块</span><br><span class="line">cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;EOF</span><br><span class="line">#!/bin/bash</span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- nf_conntrack_ipv4</span><br><span class="line">modprobe -- br_netfilter</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># 修改访问权限</span><br><span class="line">chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules</span><br><span class="line"></span><br><span class="line"># 配置内核参数，将桥接的IPv4流量传递到iptables的链</span><br><span class="line">cat &lt;&lt; EOF | tee /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-iptables=1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables=1</span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line">net.ipv4.tcp_tw_recycle=0</span><br><span class="line">vm.swappiness=0</span><br><span class="line">vm.overcommit_memory=1</span><br><span class="line">vm.panic_on_oom=0</span><br><span class="line">fs.inotify.max_user_watches=89100</span><br><span class="line">fs.file-max=52706963</span><br><span class="line">fs.nr_open=52706963</span><br><span class="line">net.ipv6.conf.all.disable_ipv6=1</span><br><span class="line">net.netfilter.nf_conntrack_max=2310720</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sysctl -p /etc/sysctl.d/k8s.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># docker 安装: </span><br><span class="line"># 安装docker所需的工具</span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line"># 配置阿里云的docker源</span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 安装 docker-ce docker-ce-cli</span><br><span class="line">yum makecache fast</span><br><span class="line">yum install -y docker-ce docker-ce-cli</span><br><span class="line"></span><br><span class="line"># 安装完成后配置启动时的命令，否则 docker 会将 iptables FORWARD chain 的默认策略设置为DROP</span><br><span class="line">sed -i &quot;13i ExecStartPost=/usr/sbin/iptables -P FORWARD ACCEPT&quot; /usr/lib/systemd/system/docker.service</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Kubernetes 默认设置cgroup驱动位为 &quot;systemd&quot; ，而 Docker 服务的cgroup驱动默认为 &quot;cgroupfs&quot;, </span><br><span class="line"># 建议将其修改为 “systemd&quot;, 与 Kubernetes 保持一致 ##</span><br><span class="line">tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://bnc2bedr.mirror.aliyuncs.com&quot;],</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;max-size&quot;: &quot;100m&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;storage-driver&quot;: &quot;overlay2&quot;,</span><br><span class="line">  &quot;storage-opts&quot;: [</span><br><span class="line">    &quot;overlay2.override_kernel_check=true&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 重启Docker 服务</span><br><span class="line">systemctl enable docker &amp;&amp; systemctl start docker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 添加阿里云的K8S源:  k8s-master   k8s-node1    k8s-node2  </span><br><span class="line">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt;- EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 安装kubeadm  kubectl  kubelet</span><br><span class="line">yum install -y kubectl kubeadm kubelet</span><br><span class="line"></span><br><span class="line"># 启动kubelet服务</span><br><span class="line">yum install -y kubectl-1.23.3 kubeadm-1.23.3 kubelet-1.23.3</span><br><span class="line"></span><br><span class="line"># 查看已经安装的版本</span><br><span class="line">kubelet --version</span><br></pre></td></tr></table></figure><h3 id="node-安装-k8s-node1-k8s-node2"><a href="#node-安装-k8s-node1-k8s-node2" class="headerlink" title="node 安装:  k8s-node1    k8s-node2"></a>node 安装:  k8s-node1    k8s-node2</h3><p>基础环境配置:   k8s-node</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 关闭selinux</span><br><span class="line"># 临时禁用selinux</span><br><span class="line">setenforce 0</span><br><span class="line"></span><br><span class="line"># 禁用交换分区</span><br><span class="line">swapoff -a</span><br><span class="line"># 永久禁用，打开/etc/fstab注释掉swap那一行。</span><br><span class="line">sed -i &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"></span><br><span class="line"># 安装依赖</span><br><span class="line">yum install -y epel-release conntrack ipvsadm ipset jq sysstat curl iptables libseccomp</span><br><span class="line"></span><br><span class="line"># 关闭防火墙</span><br><span class="line">systemctl disable firewalld &amp;&amp; systemctl stop firewalld</span><br><span class="line"></span><br><span class="line"># 设置iptables</span><br><span class="line">iptables -F &amp;&amp; iptables -X &amp;&amp; iptables -F -t nat &amp;&amp; iptables -X -t nat &amp;&amp; iptables -P FORWARD ACCEPT</span><br><span class="line"></span><br><span class="line"># 禁用 SELinux</span><br><span class="line"># 永久关闭 修改/etc/sysconfig/selinux文件设置</span><br><span class="line">sed -i &#x27;s/SELINUX=permissive/SELINUX=disabled/&#x27; /etc/sysconfig/selinux</span><br><span class="line">sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/config</span><br><span class="line"></span><br><span class="line"># 加载内核模块</span><br><span class="line">cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;EOF</span><br><span class="line">#!/bin/bash</span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- nf_conntrack_ipv4</span><br><span class="line">modprobe -- br_netfilter</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># 修改访问权限</span><br><span class="line">chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules</span><br><span class="line"></span><br><span class="line"># 配置内核参数，将桥接的IPv4流量传递到iptables的链</span><br><span class="line">cat &lt;&lt; EOF | tee /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-iptables=1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables=1</span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line">net.ipv4.tcp_tw_recycle=0</span><br><span class="line">vm.swappiness=0</span><br><span class="line">vm.overcommit_memory=1</span><br><span class="line">vm.panic_on_oom=0</span><br><span class="line">fs.inotify.max_user_watches=89100</span><br><span class="line">fs.file-max=52706963</span><br><span class="line">fs.nr_open=52706963</span><br><span class="line">net.ipv6.conf.all.disable_ipv6=1</span><br><span class="line">net.netfilter.nf_conntrack_max=2310720</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sysctl -p /etc/sysctl.d/k8s.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># docker 安装: </span><br><span class="line"># 安装docker所需的工具</span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line"># 配置阿里云的docker源</span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 安装 docker-ce docker-ce-cli</span><br><span class="line">yum makecache fast</span><br><span class="line">yum install -y docker-ce docker-ce-cli</span><br><span class="line"></span><br><span class="line"># 安装完成后配置启动时的命令，否则 docker 会将 iptables FORWARD chain 的默认策略设置为DROP</span><br><span class="line">sed -i &quot;13i ExecStartPost=/usr/sbin/iptables -P FORWARD ACCEPT&quot; /usr/lib/systemd/system/docker.service</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Kubernetes 默认设置cgroup驱动位为 &quot;systemd&quot; ，而 Docker 服务的cgroup驱动默认为 &quot;cgroupfs&quot;, </span><br><span class="line"># 建议将其修改为 “systemd&quot;, 与 Kubernetes 保持一致 ##</span><br><span class="line">tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://bnc2bedr.mirror.aliyuncs.com&quot;],</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;max-size&quot;: &quot;100m&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;storage-driver&quot;: &quot;overlay2&quot;,</span><br><span class="line">  &quot;storage-opts&quot;: [</span><br><span class="line">    &quot;overlay2.override_kernel_check=true&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 重启Docker 服务</span><br><span class="line">systemctl enable docker &amp;&amp; systemctl start docker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 添加阿里云的K8S源:  k8s-master   k8s-node1    k8s-node2  </span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 安装kubeadm  kubelet</span><br><span class="line">yum install -y kubeadm kubelet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo &#x27;KUBELET_EXTRA_ARGS=&quot;--runtime-cgroups=/systemd/system.slice --kubelet-cgroups=/systemd/system.slice&quot;&#x27; &gt; /etc/sysconfig/kubelet</span><br><span class="line"></span><br><span class="line"># 启动kubelet服务</span><br><span class="line">systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br><span class="line"></span><br><span class="line"># 查看已经安装的版本</span><br><span class="line">kubelet --version</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果需要指定版本: </span><br><span class="line"></span><br><span class="line">## 安装指定版本</span><br><span class="line">yum install -y kubelet-1.18.0 kubeadm-1.18.0 kubectl-1.18.0 --disableexcludes=kubernetes</span><br></pre></td></tr></table></figure><h3 id="集群初始化"><a href="#集群初始化" class="headerlink" title="集群初始化"></a>集群初始化</h3><p>初始化 k8s-master 环境 或 kubeadm reset 后都要按以下步骤执行, IP地址需根据实际情况调整</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 因为需要下载 images 需要一些时间, 这里会等待一会儿, IP 按当前网络环境自行修改: </span><br><span class="line"># 说明: https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/</span><br><span class="line">kubeadm init \</span><br><span class="line">--kubernetes-version=1.23.3 \</span><br><span class="line">--apiserver-advertise-address=192.168.1.104 \</span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">--service-cidr=10.1.0.0/16 \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16</span><br><span class="line">1643798856184780.png</span><br></pre></td></tr></table></figure><p>命令说明：</p><p><strong>–pod-network-cidr</strong>: 定义pod网段为：10.244.0.0/16</p><p><strong>–apiserver-advertise-address</strong>：master主机内网IP地址</p><p><strong>–image-repository</strong>：指定阿里云镜像仓库地址。由于kubeadm 默认从官网<a href="http://k8s.grc.io下载所需镜像,国内无法访问,因此需要通过–image-repository指定阿里云镜像仓库地址./">http://k8s.grc.io下载所需镜像，国内无法访问，因此需要通过–image-repository指定阿里云镜像仓库地址。</a></p><p>集群初始化会出现如下结果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br></pre></td></tr></table></figure><p>上面安装完后，会提示你输入如下命令，复制粘贴过来，执行即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 上面安装完成后，k8s会提示你输入如下命令，执行</span><br><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>如果是root用户请执行: 最好加入到 .zshrc  .bashrc, 此处有疑问…. TODO: </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export KUBECONFIG=/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure><p>node机上执行:  此时执行会报错并且执行不成功, 请稍等执行好flannel 再到node机上执行: 如忘记: 可使用命令 kubeadm token create –print-join-command 查看:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubeadm join 192.168.1.104:6443 --token rzruo2.3qa09lso9c51iinx \</span><br><span class="line">--discovery-token-ca-cert-hash sha256:52ed235db605f9db5b78b042a09a628446e6f248bc434f5c9dfc0a6a0ea5f900</span><br></pre></td></tr></table></figure><p>配置: kube-flannel.yml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改/etc/hosts ,目的是解决无法下载 kube-flannel.yml 情况</span><br><span class="line">echo &#x27;199.232.96.133 raw.githubusercontent.com&#x27; &gt;&gt; /etc/hosts</span><br><span class="line">curl -k -O https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line">kubectl apply -f kube-flannel.yml</span><br></pre></td></tr></table></figure><p>重要: ok, 此时去node机上执行 kubeadm join 即可, 这时在node执行 join 时会自动生 /run/flannel/subnet.env 文件, 而不会再报找不到文件的错误!</p><p>OK  部署完毕!</p><p>后续需要进行 ingress 和 dashboard 的安装  </p><ul><li>安装dashboard</li></ul><p><a href="https://github.com/kubernetes/dashboard/">https://github.com/kubernetes/dashboard/</a></p><p>设置Kubernetes的Master节点参与应用调度（默认安装Master节点不运行应用）。有两种方法：</p><p>长期改变节点的属性，允许Master运行应用，执行：</p><p>kubectl taint nodes –all node-role.kubernetes.io/master-<br>临时允许Master节点执行应用，在应用的yaml文件中添加：</p><pre><code>  tolerations:  - key: node-role.kubernetes.io/master        effect: NoSchedule</code></pre><h3 id="报错信息及解决方法记录"><a href="#报错信息及解决方法记录" class="headerlink" title="报错信息及解决方法记录"></a>报错信息及解决方法记录</h3><p>报错: 要求还挺高的:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[init] Using Kubernetes version: v1.23.3</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">        [WARNING Swap]: swap is enabled; production deployments should disable swap unless testing the NodeSwap feature gate of the kubelet</span><br><span class="line">error execution phase preflight: [preflight] Some fatal errors occurred:</span><br><span class="line">        [ERROR NumCPU]: the number of available CPUs 1 is less than the required 2</span><br><span class="line">        [ERROR Mem]: the system RAM (972 MB) is less than the minimum 1700 MB</span><br><span class="line">        [ERROR DirAvailable--var-lib-etcd]: /var/lib/etcd is not empty</span><br><span class="line">[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`</span><br><span class="line">To see the stack trace of this error execute with --v=5 or higher</span><br></pre></td></tr></table></figure><p>解决方法:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -rf /var/lib/etcd</span><br><span class="line"></span><br><span class="line">cpu调整为2 core</span><br><span class="line"></span><br><span class="line">RAM 调整为 2000M</span><br><span class="line"></span><br><span class="line">禁用swap</span><br></pre></td></tr></table></figure><p>报错:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kubelet-check] The HTTP call equal to &#x27;curl -sSL http://localhost:10248/healthz&#x27; failed with error: Get &quot;http://localhost:10248/healthz&quot;: dial tcp [::1]:10248: connect: connection refused.</span><br><span class="line">[kubelet-check] It seems like the kubelet isn&#x27;t running or healthy.</span><br><span class="line">[kubelet-check] The HTTP call equal to &#x27;curl -sSL http://localhost:10248/healthz&#x27; failed with error: Get &quot;http://localhost:10248/healthz&quot;: dial tcp [::1]:10248: connect: connection refused.</span><br><span class="line">[kubelet-check] It seems like the kubelet isn&#x27;t running or healthy.</span><br><span class="line">[kubelet-check] The HTTP call equal to &#x27;curl -sSL http://localhost:10248/healthz&#x27; failed with error: Get &quot;http://localhost:10248/healthz&quot;: dial tcp [::1]:10248: connect: connection refused.</span><br><span class="line">[kubelet-check] It seems like the kubelet isn&#x27;t running or healthy.</span><br><span class="line">[kubelet-check] The HTTP call equal to &#x27;curl -sSL http://localhost:10248/healthz&#x27; failed with error: Get &quot;http://localhost:10248/healthz&quot;: dial tcp [::1]:10248: connect: connection refused.</span><br><span class="line">[kubelet-check] It seems like the kubelet isn&#x27;t running or healthy.</span><br><span class="line">[kubelet-check] The HTTP call equal to &#x27;curl -sSL http://localhost:10248/healthz&#x27; failed with error: Get &quot;http://localhost:10248/healthz&quot;: dial tcp [::1]:10248: connect: connection refused.</span><br></pre></td></tr></table></figure><p>解决方法:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">   &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="line">   &quot;registry-mirrors&quot;:[&quot;https://bnc2bedr.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>init 成功:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, if you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 192.168.1.104:6443 --token y5xxms.514jm8ttg99byfqw \</span><br><span class="line">--discovery-token-ca-cert-hash sha256:346e61f73686bb756ade89ad02401fab4d66bf12fa1c5be92b2f5ae128aea082</span><br></pre></td></tr></table></figure><p>错误信息:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get pod -o wide</span><br><span class="line">Unable to connect to the server: x509: certificate signed by unknown authority </span><br><span class="line">(possibly because of &quot;crypto/rsa: verification error&quot; while trying to verify candidate authority </span><br><span class="line">certificate &quot;kubernetes&quot;)</span><br></pre></td></tr></table></figure><p>解决方法:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/hosts</span><br><span class="line"></span><br><span class="line">199.232.96.133 raw.githubusercontent.com</span><br><span class="line"></span><br><span class="line">curl -k -O https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line"></span><br><span class="line">kubectl apply -f kube-flannel.yml</span><br></pre></td></tr></table></figure><p>错误:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r=&quot;failed to get cgroup stats for \&quot;/system.slice/docker.service\&quot;: failed to get container info for \&quot;/system.slice/docker.service\&quot;: unknown container \&quot;/system.slice/docker.service\&quot;&quot; containerName=&quot;/system.slice/docker.service&quot;</span><br><span class="line">Feb 01 18:51:41 k8s-master kubelet[967]: E0201 18:51:41.971405     967 summary_sys_containers.go:48] &quot;Failed to get system container stats&quot; err=&quot;failed to get cgroup stats for \&quot;/system.slice/docker.service\&quot;: failed to get container info for \&quot;/system.slice/docker.service\&quot;: unknown container \&quot;/system.slice/docker.service\&quot;&quot; containerName=&quot;/system.slice/docker.service&quot;</span><br><span class="line">Feb 01 18:51:51 k8s-master kubelet[967]: E0201 18:51:51.983359     967 summary_sys_containers.go:48] &quot;Failed to get system container stats&quot; err=&quot;failed to get cgroup stats for \&quot;/system.slice/docker.service\&quot;: failed to get container info for \&quot;/system.slice/docker.service\&quot;: unknown container \&quot;/system.slice/docker.service\&quot;&quot; containerName=&quot;/system.slice/docker.service&quot;</span><br><span class="line">Feb 01 18:52:01 k8s-master kubelet[967]: E0201 18:52:01.993080     967 summary_sys_containers.go:48] &quot;Failed to get system container stats&quot; err=&quot;failed to get cgroup stats for \&quot;/system.slice/docker.service\&quot;: failed to get container info for \&quot;/system.slice/docker.service\&quot;: unknown container \&quot;/system.slice/docker.service\&quot;&quot; containerName=&quot;/system.slice/docker.service&quot;</span><br></pre></td></tr></table></figure><p>解决方法:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export KUBECONFIG=/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure><p>按照以下方法修改后报错消失</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># vim /etc/sysconfig/kubelet</span><br><span class="line"></span><br><span class="line">KUBELET_EXTRA_ARGS=&quot;--runtime-cgroups=/systemd/system.slice --kubelet-cgroups=/systemd/system.slice&quot;</span><br></pre></td></tr></table></figure><p>重新加载配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure><p>错误:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubeadm join 192.168.1.104:6443 --token a6o03y.wvcmk7o1d2c12w3c --discovery-token-ca-cert-hash sha256:bab7991421fd20f55bf1142dcb8a68887a2572deeb5a09e94d11c9935044a0ee</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">[WARNING Hostname]: hostname &quot;k8s-node2&quot; could not be reached</span><br><span class="line">[WARNING Hostname]: hostname &quot;k8s-node2&quot;: lookup k8s-node2 on 10.64.0.100:53: no such host</span><br><span class="line">[preflight] Reading configuration from the cluster...</span><br></pre></td></tr></table></figure><p>解决方法:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#配置/etc/hosts</span><br><span class="line"></span><br><span class="line">echo &#x27;192.168.1.106 k8s-node2&#x27; &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure><p>master 上的错误:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Feb 01 21:37:16 k8s-node1 kubelet[24981]: E0201 21:37:16.200352   24981 cni.go:362] &quot;Error adding pod to network&quot; err=&quot;failed to delegate add: failed to set bridge addr: \&quot;cni0\&quot; already has an IP address different from 10.244.1.1/24&quot; pod=&quot;default/nginx-deployment-b5776f7cd-snsq5&quot; podSandboxID=&#123;Type:docker ID:bbb4c549c5c801d03458965a892d22871c5f87aa4ce94842b9c6d169ac51816b&#125; podNetnsPath=&quot;/proc/43241/ns/net&quot; networkType=&quot;flannel&quot; networkName=&quot;cbr0&quot;</span><br><span class="line">Feb 01 21:37:16 k8s-node1 kubelet[24981]: E0201 21:37:16.333645   24981 remote_runtime.go:209] &quot;RunPodSandbox from runtime service failed&quot; err=&quot;rpc error: code = Unknown desc = failed to set up sandbox container \&quot;bbb4c549c5c801d03458965a892d22871c5f87aa4ce94842b9c6d169ac51816b\&quot; network for pod \&quot;nginx-deployment-b5776f7cd-snsq5\&quot;: networkPlugin cni failed to set up pod \&quot;nginx-deployment-b5776f7cd-snsq5_default\&quot; network: failed to delegate add: failed to set bridge addr: \&quot;cni0\&quot; already has an IP address different from 10.244.1.1/24&quot;</span><br></pre></td></tr></table></figure><p>解决方法1:</p><p>发现是 cni0 网桥配置了一个不同网段的 IP 地址导致，删除该网桥（网络插件会自动重新创建）即可修复</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br><span class="line"></span><br><span class="line">ip link set cni0 down</span><br><span class="line">brctl delbr cni0</span><br><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure><p>从集群中删除该 Node。使用公有云时，kube-controller-manager 会在 VM 删除后自动删除对应的 Node。而在物理机部署的集群中，需要管理员手动删除 Node（如 kubectl delete node <node-name>。</node-name></p><p>Node 恢复正常。Kubelet 会重新跟 kube-apiserver 通信确认这些 Pod 的期待状态，进而再决定删除或者继续运行这些 Pod。</p><p>用户强制删除。用户可以执行 kubectl delete pods <pod> –grace-period=0 –force 强制删除 Pod。除非明确知道 Pod 的确处于停止状态（比如 Node 所在 VM 或物理机已经关机），否则不建议使用该方法。特别是 StatefulSet 管理的 Pod，强制删除容易导致脑裂或者数据丢失等问题。</pod></p><h2 id="其他问题请查看日志命令"><a href="#其他问题请查看日志命令" class="headerlink" title="其他问题请查看日志命令"></a>其他问题请查看日志命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">journalctl -xefu kubelet</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> 容器技术 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署Kuboard时metrics-server报错HTTP probe failed with statuscode: 500</title>
      <link href="/posts/2022/05/8635d5dd.html"/>
      <url>/posts/2022/05/8635d5dd.html</url>
      
        <content type="html"><![CDATA[<p>部署k8s v1.23完成后，安装Kuboard V2:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://kuboard.cn/install-script/kuboard.yaml</span><br><span class="line">kubectl apply -f https://addons.kuboard.cn/metrics-server/0.3.7/metrics-server.yaml</span><br></pre></td></tr></table></figure><p>安装完成后，进入Kuboard控制台界面，会发现Kuboard不能显示节点计算资源利用率情况，页面上提示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请 检查metrics-server 是否启动正常</span><br><span class="line"></span><br><span class="line">请 检查Apiservice 状态是否正常</span><br></pre></td></tr></table></figure><span id="more"></span> <img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-39.png" alt><p>执行 kubectl top nodes 指令失败，提示如下信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl top nodes</span><br><span class="line">Error from server (ServiceUnavailable): the server is currently unable to handle the request (get nodes.metrics.k8s.io)</span><br></pre></td></tr></table></figure><p>点击上图中的“请 检查metrics-server 是否启动正常”，会看到是哪个 metrics-server 节点出错，继续点击该节点会看到详细报错信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Readiness probe failed: HTTP probe failed with statuscode: 500</span><br></pre></td></tr></table></figure><p>拿到节点id，执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看pod的详情</span><br><span class="line">kubectl describe -n kube-system po/metrics-server-6d544fd645-8flkv</span><br><span class="line"></span><br><span class="line">#没有什么有效信息，继续查看容器日志</span><br><span class="line"></span><br><span class="line">#输出pod中一个容器的日志</span><br><span class="line">kubectl logs -f metrics-server-6d544fd645-6778k -n=kube-system</span><br></pre></td></tr></table></figure><p>具体报错日志：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl logs -f metrics-server-6d544fd645-6778k -n=kube-system</span><br><span class="line"></span><br><span class="line">E0518 07:12:42.090952       1 server.go:132] unable to fully scrape metrics: [unable to fully scrape metrics from node XXX-02: unable to fetch metrics from node XXX-02: Get &quot;https://IP-02:10250/stats/summary?only_cpu_and_memory=true&quot;: x509: cannot validate certificate for IP-02 because it doesn&#x27;t contain any IP SANs, unable to fully scrape metrics from node XXX-01: unable to fetch metrics from node XXX-01: Get &quot;https://IP01:10250/stats/summary?only_cpu_and_memory=true&quot;: x509: cannot validate certificate for IP01 because it doesn&#x27;t contain any IP SANs, unable to fully scrape metrics from node XXX-master: unable to fetch metrics from node XXX-master: Get &quot;https://IP-MASTER:10250/stats/summary?only_cpu_and_memory=true&quot;: x509: cannot validate certificate for IP-MASTER because it doesn&#x27;t contain any IP SANs]</span><br><span class="line">I0518 07:12:42.091126       1 requestheader_controller.go:169] Starting RequestHeaderAuthRequestController</span><br><span class="line">I0518 07:12:42.091139       1 shared_informer.go:240] Waiting for caches to sync for RequestHeaderAuthRequestController</span><br><span class="line">I0518 07:12:42.091167       1 configmap_cafile_content.go:202] Starting client-ca::kube-system::extension-apiserver-authentication::requestheader-client-ca-file</span><br><span class="line">I0518 07:12:42.091204       1 shared_informer.go:240] Waiting for caches to sync for client-ca::kube-system::extension-apiserver-authentication::requestheader-client-ca-file</span><br><span class="line">I0518 07:12:42.091174       1 configmap_cafile_content.go:202] Starting client-ca::kube-system::extension-apiserver-authentication::client-ca-file</span><br><span class="line">I0518 07:12:42.091246       1 shared_informer.go:240] Waiting for caches to sync for client-ca::kube-system::extension-apiserver-authentication::client-ca-file</span><br><span class="line">I0518 07:12:42.091521       1 dynamic_serving_content.go:130] Starting serving-cert::/tmp/apiserver.crt::/tmp/apiserver.key</span><br><span class="line">I0518 07:12:42.091885       1 secure_serving.go:197] Serving securely on [::]:4443</span><br></pre></td></tr></table></figure><p>这个错误就是说“探测失败，因为它无法收集任何指标 。无法验证 IP-02 的证书，因为它不包含任何 IP SAN”。</p><p>怎么解决呢，其实办法很简单。</p><p>传递 ‘–kubelet-insecure-tls’ 以禁用证书验证即可（不建议在生产中）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl edit deployment.apps/metrics-server -n kube-system</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行上述命令后，将 –kubelet-insecure-tls 添加到“spec.template.spec.containers.args”（YAML Path）下的列表即可。</p><p>然后再回到Kuboard控制台界面，一切都正常了。</p>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> Kuboard </tag>
            
            <tag> metrics-server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>msg=”getting status of runtime: rpc error: code = Unimplemented desc = unknown service runtime.v1alpha2.RuntimeService”问题解决</title>
      <link href="/posts/2022/05/8ce9d753.html"/>
      <url>/posts/2022/05/8ce9d753.html</url>
      
        <content type="html"><![CDATA[<p>搭建k8s集群（v1.24.0版本）过程中碰到如下报错：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">    [WARNING FileExisting-ethtool]: ethtool not found in system path</span><br><span class="line">    [WARNING FileExisting-socat]: socat not found in system path</span><br><span class="line">error execution phase preflight: [preflight] Some fatal errors occurred:</span><br><span class="line">    [ERROR CRI]: container runtime is not running: output: time=&quot;2022-05-23T15:43:15+08:00&quot; level=fatal msg=&quot;getting status of runtime: rpc error: code = Unimplemented desc = unknown service runtime.v1alpha2.RuntimeService&quot;</span><br><span class="line">, error: exit status 1</span><br><span class="line">[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`</span><br><span class="line">To see the stack trace of this error execute with --v=5 or higher</span><br></pre></td></tr></table></figure><p>解决办法很简单：</p><span id="more"></span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm /etc/containerd/config.toml</span><br><span class="line">systemctl restart containerd</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> containerd </tag>
            
            <tag> 容器技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s v1.24.0搭建高可用(k8s)Kubernetes集群教程</title>
      <link href="/posts/2022/05/741c30b.html"/>
      <url>/posts/2022/05/741c30b.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h5 id="Kubernetes-1-24新特性"><a href="#Kubernetes-1-24新特性" class="headerlink" title="Kubernetes 1.24新特性"></a>Kubernetes 1.24新特性</h5><ul><li>从kubelet中移除dockershim<br>自1.20版本被弃用之后，dockershim组件终于在1.24的kubelet中被删除。从1.24开始，大家需要使用其他受到支持的运行时选项（例如containerd或CRI-O）；如果您选择Docker Engine作为运行时，则需要使用cri-dockerd。</li></ul><p>对于kubelet和containerd重要提示<br>在升级至1.24之前，请确认containerd版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#以下容器运行时已经或即将全面兼容Kubernetes 1.24：</span><br><span class="line">containerd v1.6.4及更高，v1.5.11及更高</span><br><span class="line">CRI-O 1.24及更高</span><br></pre></td></tr></table></figure><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">若CNI插件尚未升级且/或CNI配置文件中未声明CNI配置版本时，则containerd v1.6.0-v1.6.3版本将导致Pod CNI网络setup及tear down发生问题。containerd团队报告称，这些问题已经在containerd v1.6.4中得到解决。</span><br><span class="line">在containerd v1.6.0-v1.6.3时，如果你未升级CNI插件且/或声明CNI配置版本，则可能遇到CNI版本不兼容或无法为沙箱删除网络等错误。</span><br></pre></td></tr></table></figure><h2 id="Kubernetes-1-24新特性-1"><a href="#Kubernetes-1-24新特性-1" class="headerlink" title="Kubernetes 1.24新特性"></a>Kubernetes 1.24新特性</h2><ul><li><p>各beta API默认关闭<br>在默认情况下，新的各beta API不会在集群内得到启用。但全部原有beta API及其新版本将在1.24中继续默认启用</p></li><li><p>OpenAPI v3<br>Kubernetes 1.24开始为API的OpenAPI v3发布格式提供beta支持。</p></li><li><p>存储容量与存储卷扩展双双迎来通用版本<br>存储容量跟踪通过CSIStorageCapacity对象公开当前可用的存储容量，并对使用后续绑定的CSI存储卷的pod进行调度增强。<br>存储卷扩展则新增对现有持久卷的重新调整功能。</p></li><li><p>NonPreemptingPriority迎来稳定版<br>此功能为PriorityClasses添加了新的选项，可开启或关闭Pod抢占机制</p></li><li><p>存储插件迁移<br>目前Kubernetes开发团队正在迁移树内存储插件，希望在实现CSI插件的同时、保持原有API的正常起效。Azure Disk与OpenStack Cinder等插件已经完成了迁移。</p></li><li><p>gRPC探针升级至beta版<br>在1.24版本中，gRPC探针功能已经进入beta阶段且默认启用。现在，大家可以在Kubernetes中为自己的gRPC应用程序原生配置启动、活动与就绪探测，而且无需公开HTTP商战或者使用额外的可执行文件。</p></li><li><p>Kubelet证书提供程序升级至beta版<br>最初在Kubernetes 1.20版本中以alpha版亮相的kubelet镜像证书提供程序现已升级至beta版。现在，kubelet将使用exec插件动态检索容器镜像注册表的凭证，而不再将凭证存储在节点文件系统之上。</p></li><li><p>避免为服务分配IP时发生冲突<br>Kubernetes 1.24引入了一项新的选择性功能，允许用户为服务的静态IP分配地址保留一个软范围。通过手动启用此项功能，集群将从您指定的服务IP池中自动获取地址，从而降低冲突风险。  </p></li></ul><p>也就是说，服务的ClusterIP能够以下列方式分配：<br><strong>动态分配</strong>，即集群将在配置的服务IP范围内自动选择一个空闲IP。<br><strong>静态分配</strong>，意味着用户需要在已配置的服务IP范围内指定一个IP。  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">服务ClusterIP是唯一的；因此若尝试使用已被分配的ClusterIP进行服务创建，则会返回错误结果。</span><br></pre></td></tr></table></figure><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>我本地有kubernetes 1.18环境，接下来对环境进行初始化</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#目前kubernetes版本</span><br><span class="line">[root@k8s-01 ~]# kubectl  get node</span><br><span class="line">NAME     STATUS   ROLES    AGE    VERSION</span><br><span class="line">k8s-01   Ready    master   243d   v1.18.3</span><br><span class="line">k8s-02   Ready    master   243d   v1.18.3</span><br><span class="line">k8s-03   Ready    master   243d   v1.18.3</span><br><span class="line">k8s-04   Ready    &lt;none&gt;   243d   v1.18.3</span><br><span class="line">k8s-05   Ready    &lt;none&gt;   243d   v1.18.3</span><br></pre></td></tr></table></figure><p>卸载集群命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#建议所有服务器都执行</span><br><span class="line">#!/bin/bash</span><br><span class="line">kubeadm reset -f</span><br><span class="line">modprobe -r ipip</span><br><span class="line">lsmod</span><br><span class="line">rm -rf ~/.kube/</span><br><span class="line">rm -rf /etc/kubernetes/</span><br><span class="line">rm -rf /etc/systemd/system/kubelet.service.d</span><br><span class="line">rm -rf /etc/systemd/system/kubelet.service</span><br><span class="line">rm -rf /usr/bin/kube*</span><br><span class="line">rm -rf /etc/cni</span><br><span class="line">rm -rf /opt/cni</span><br><span class="line">rm -rf /var/lib/etcd</span><br><span class="line">rm -rf /var/etcd</span><br><span class="line">yum -y remove kubeadm* kubectl* kubelet* docker*</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h2 id="基础环境配置"><a href="#基础环境配置" class="headerlink" title="基础环境配置"></a>基础环境配置</h2><table><thead><tr><th>IP地址</th><th>主机名</th><th>服务</th><th>配置</th></tr></thead><tbody><tr><td>192.168.31.10</td><td>k8s-01</td><td>k8s-master、containerd、keepalived、nginx</td><td>2c8g</td></tr><tr><td>192.168.31.11</td><td>k8s-02</td><td>k8s-master、containerd、keepalived、nginx</td><td>2c8g</td></tr><tr><td>192.168.31.12</td><td>k8s-03</td><td>k8s-master、containerd、keepalived、nginx</td><td>2c8g</td></tr><tr><td>192.168.31.13</td><td>k8s-04</td><td>k8s-node、containerd</td><td>1c4g</td></tr><tr><td>192.168.31.14</td><td>k8s-05</td><td>k8s-node、containerd</td><td>1c4g</td></tr><tr><td>VIP: 192.168.31.111 域名:apiserver.frps.cn</td><td></td><td></td><td></td></tr></tbody></table><p>apiserver.frps.cn:6443 为VIP</p><ul><li>kube-apiserver 三台节点</li><li>kube-schedulet 三台节点</li><li>kube-controller-manager 三台节点</li><li>ETCD 三台节点</li></ul><h5 id="服务版本"><a href="#服务版本" class="headerlink" title="服务版本"></a>服务版本</h5><table><thead><tr><th>服务名称</th><th>版本号</th></tr></thead><tbody><tr><td>内核</td><td>5.14.3-1.el7.elrepo.x86_64</td></tr><tr><td>containerd</td><td>v1.6.4</td></tr><tr><td>ctr</td><td>v1.6.4</td></tr><tr><td>k8s</td><td>1.24</td></tr></tbody></table><h5 id="初始化环境"><a href="#初始化环境" class="headerlink" title="初始化环境"></a>初始化环境</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始化环境需要全部节点都执行</span><br></pre></td></tr></table></figure><p>批量修改主机名，以及免密</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname k8s01  #所有机器按照要求修改</span><br><span class="line">bash        #刷新主机名</span><br><span class="line">#配置host</span><br><span class="line">cat &gt;&gt; /etc/hosts &lt;&lt;EOF</span><br><span class="line">192.168.31.10  k8s-01</span><br><span class="line">192.168.31.11  k8s-02</span><br><span class="line">192.168.31.12  k8s-03</span><br><span class="line">192.168.31.13  k8s-04</span><br><span class="line">192.168.31.14  k8s-05</span><br><span class="line">EOF</span><br><span class="line">#设置k8s-01为分发机 (只需要在k8s-01服务器操作即可)</span><br><span class="line">wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">yum install -y expect</span><br><span class="line">#分发公钥</span><br><span class="line">ssh-keygen -t rsa -P &quot;&quot; -f /root/.ssh/id_rsa</span><br><span class="line">for i in k8s-01 k8s-02 k8s-03 k8s-04 k8s-05;do</span><br><span class="line">expect -c &quot;</span><br><span class="line">spawn ssh-copy-id -i /root/.ssh/id_rsa.pub root@$i</span><br><span class="line">        expect &#123;</span><br><span class="line">                &quot;*yes/no*&quot; &#123;send &quot;yesr&quot;; exp_continue&#125;</span><br><span class="line">                &quot;*password*&quot; &#123;send &quot;123456r&quot;; exp_continue&#125;</span><br><span class="line">                &quot;*Password*&quot; &#123;send &quot;123456r&quot;;&#125;</span><br><span class="line">        &#125; &quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><blockquote><p>我这里密码为123456，请根据需求自行更改  </p></blockquote><p>所有节点关闭Selinux、iptables、swap分区</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line">iptables -F &amp;&amp; iptables -X &amp;&amp; iptables -F -t nat &amp;&amp; iptables -X -t nat</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line">swapoff -a</span><br><span class="line">sed -i &#x27;/ swap / s/^(.*)$/#1/g&#x27; /etc/fstab</span><br><span class="line">setenforce 0</span><br><span class="line">sed -i &#x27;s/^SELINUX=.*/SELINUX=disabled/&#x27; /etc/selinux/config</span><br></pre></td></tr></table></figure><p>所有节点配置yum源</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><p>新安装的服务器可以安装下面的软件包，可以解决99%的依赖问题</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install gcc gcc-c++ make autoconf libtool-ltdl-devel gd-devel freetype-devel libxml2-devel libjpeg-devel libpng-devel openssh-clients openssl-devel curl-devel bison patch libmcrypt-devel libmhash-devel ncurses-devel binutils compat-libstdc++-33 elfutils-libelf elfutils-libelf-devel glibc glibc-common glibc-devel libgcj libtiff pam-devel libicu libicu-devel gettext-devel libaio-devel libaio libgcc libstdc++ libstdc++-devel unixODBC unixODBC-devel numactl-devel glibc-headers sudo bzip2 mlocate flex lrzsz sysstat lsof setuptool system-config-network-tui system-config-firewall-tui ntsysv ntp pv lz4 dos2unix unix2dos rsync dstat iotop innotop mytop telnet iftop expect cmake nc gnuplot screen xorg-x11-utils xorg-x11-xinit rdate bc expat-devel compat-expat1 tcpdump sysstat man nmap curl lrzsz elinks finger bind-utils traceroute mtr ntpdate zip unzip vim wget net-tools</span><br></pre></td></tr></table></figure><p>由于开启内核 ipv4 转发需要加载 br_netfilter 模块，所以加载下该模块：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modprobe br_netfilter</span><br><span class="line">modprobe ip_conntrack</span><br><span class="line">#每台节点</span><br></pre></td></tr></table></figure><p>将上面的命令设置成开机启动，因为重启后模块失效，下面是开机自动加载模块的方式。首先新建 /etc/rc.sysinit 文件，内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &gt;&gt;/etc/rc.sysinit&lt;&lt;EOF</span><br><span class="line">#!/bin/bash</span><br><span class="line">for file in /etc/sysconfig/modules/*.modules ; do</span><br><span class="line">[ -x $file ] &amp;&amp; $file</span><br><span class="line">done</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>然后在/etc/sysconfig/modules/目录下新建如下文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;modprobe br_netfilter&quot; &gt;/etc/sysconfig/modules/br_netfilter.modules</span><br><span class="line">echo &quot;modprobe ip_conntrack&quot; &gt;/etc/sysconfig/modules/ip_conntrack.modules</span><br></pre></td></tr></table></figure><p>增加权限</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 755 /etc/sysconfig/modules/br_netfilter.modules</span><br><span class="line">chmod 755 /etc/sysconfig/modules/ip_conntrack.modules</span><br></pre></td></tr></table></figure><p>然后重启后，模块就可以自动加载了</p><p>优化内核参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &gt; kubernetes.conf &lt;&lt;EOF</span><br><span class="line">net.bridge.bridge-nf-call-iptables=1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables=1</span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line">vm.swappiness=0 # 禁止使用 swap 空间，只有当系统 OOM 时才允许使用它</span><br><span class="line">vm.overcommit_memory=1 # 不检查物理内存是否够用</span><br><span class="line">vm.panic_on_oom=0 # 开启 OOM</span><br><span class="line">fs.inotify.max_user_instances=8192</span><br><span class="line">fs.inotify.max_user_watches=1048576</span><br><span class="line">fs.file-max=52706963</span><br><span class="line">fs.nr_open=52706963</span><br><span class="line">net.ipv6.conf.all.disable_ipv6=1</span><br><span class="line">net.netfilter.nf_conntrack_max=2310720</span><br><span class="line">EOF</span><br><span class="line">cp kubernetes.conf  /etc/sysctl.d/kubernetes.conf</span><br><span class="line">sysctl -p /etc/sysctl.d/kubernetes.conf</span><br><span class="line">#分发到所有节点</span><br><span class="line">for i in k8s-02 k8s-03 k8s-04 k8s-05</span><br><span class="line">do</span><br><span class="line">    scp kubernetes.conf root@$i:/etc/sysctl.d/</span><br><span class="line">    ssh root@$i sysctl -p /etc/sysctl.d/kubernetes.conf</span><br><span class="line">    ssh root@$i echo &#x27;1&#x27; &gt;&gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line">done</span><br><span class="line">#for后面节点根据需求修改</span><br></pre></td></tr></table></figure><blockquote><p>bridge-nf 使得netfilter可以对Linux网桥上的 IPv4/ARP/IPv6 包过滤。比如，设置net.bridge.bridge-nf-call-iptables＝1后，二层的网桥在转发包时也会被 iptables的 FORWARD 规则所过滤。常用的选项包括：</p></blockquote><blockquote><blockquote><p>net.bridge.bridge-nf-call-arptables：是否在 arptables 的 FORWARD 中过滤网桥的 ARP 包<br>net.bridge.bridge-nf-call-ip6tables：是否在 ip6tables 链中过滤 IPv6 包<br>net.bridge.bridge-nf-call-iptables：是否在 iptables 链中过滤 IPv4 包<br>net.bridge.bridge-nf-filter-vlan-tagged：是否在 iptables/arptables 中过滤打了 vlan 标签的包。  </p></blockquote></blockquote><p>所有节点安装ipvs</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#为什么要使用IPVS,从k8s的1.8版本开始，kube-proxy引入了IPVS模式，IPVS模式与iptables同样基于Netfilter，但是采用的hash表，因此当service数量达到一定规模时，hash查表的速度优势就会显现出来，从而提高service的服务性能。</span><br><span class="line">ipvs依赖于nf_conntrack_ipv4内核模块,4.19包括之后内核里改名为nf_conntrack,1.13.1之前的kube-proxy的代码里没有加判断一直用的nf_conntrack_ipv4,好像是1.13.1后的kube-proxy代码里增加了判断,我测试了是会去load nf_conntrack使用ipvs正常</span><br><span class="line"></span><br><span class="line">cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;EOF</span><br><span class="line">#!/bin/bash</span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- nf_conntrack</span><br><span class="line">EOF</span><br><span class="line">chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack</span><br><span class="line">#查看是否已经正确加载所需的内核模块</span><br></pre></td></tr></table></figure><p>所有节点安装ipset</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install ipset -y</span><br></pre></td></tr></table></figure><p>ipset介绍</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables是Linux服务器上进行网络隔离的核心技术，内核在处理网络请求时会对iptables中的策略进行逐条解析，因此当策略较多时效率较低；而是用IPSet技术可以将策略中的五元组(协议，源地址，源端口,目的地址，目的端口)合并到有限的集合中，可以大大减少iptables策略条目从而提高效率。测试结果显示IPSet方式效率将比iptables提高100倍</span><br></pre></td></tr></table></figure><p>为了方面ipvs管理，这里安装一下ipvsadm。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install ipvsadm -y</span><br></pre></td></tr></table></figure><p>所有节点设置系统时区</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">timedatectl set-timezone Asia/Shanghai</span><br><span class="line"> #将当前的 UTC 时间写入硬件时钟</span><br><span class="line">timedatectl set-local-rtc 0</span><br><span class="line"> #重启依赖于系统时间的服务</span><br><span class="line">systemctl restart rsyslog </span><br><span class="line">systemctl restart crond</span><br></pre></td></tr></table></figure><p>升级内核 (可选方案)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class="line">rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm</span><br><span class="line">#默认安装为最新内核</span><br><span class="line">yum --enablerepo=elrepo-kernel install kernel-ml</span><br><span class="line">#修改内核顺序</span><br><span class="line">grub2-set-default  0 &amp;&amp; grub2-mkconfig -o /etc/grub2.cfg</span><br><span class="line">#使用下面命令看看确认下是否启动默认内核指向上面安装的内核</span><br><span class="line">grubby --default-kernel</span><br><span class="line">#这里的输出结果应该为我们升级后的内核信息</span><br><span class="line">reboot</span><br><span class="line">#可以等所有初始化步骤结束进行reboot操作</span><br></pre></td></tr></table></figure><p>接下来更新一下软件包版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum update -y</span><br></pre></td></tr></table></figure><h2 id="Containerd-安装"><a href="#Containerd-安装" class="headerlink" title="Containerd 安装"></a>Containerd 安装</h2><p>在安装containerd前，我们需要优先升级libseccomp<br>在centos7中yum下载libseccomp的版本是2.3的，版本不满足我们最新containerd的需求，需要下载2.4以上的</p><blockquote><p><strong>Containerd需要在所有节点升级安装</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#卸载原来的</span><br><span class="line">[i4t@web01 ~]# rpm -qa | grep libseccomp</span><br><span class="line">libseccomp-devel-2.3.1-4.el7.x86_64</span><br><span class="line">libseccomp-2.3.1-4.el7.x86_64</span><br><span class="line">[i4t@web01 ~]# rpm -e libseccomp-devel-2.3.1-4.el7.x86_64 --nodeps</span><br><span class="line">[i4t@web01 ~]# rpm -e libseccomp-2.3.1-4.el7.x86_64 --nodeps</span><br><span class="line">#下载高于2.4以上的包</span><br><span class="line">[i4t@web01 ~]# wget http://rpmfind.net/linux/centos/8-stream/BaseOS/x86_64/os/Packages/libseccomp-2.5.1-1.el8.x86_64.rpm</span><br><span class="line">#安装</span><br><span class="line">[i4t@web01 ~]# rpm -ivh libseccomp-2.5.1-1.el8.x86_64.rpm </span><br><span class="line">warning: libseccomp-2.5.1-1.el8.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID 8483c65d: NOKEY</span><br><span class="line">Preparing...                          ################################# [100%]</span><br><span class="line">Updating / installing...</span><br><span class="line">   1:libseccomp-2.5.1-1.el8           ################################# [100%]</span><br><span class="line">#查看当前版本</span><br><span class="line">[root@web01 ~]# rpm -qa | grep libseccomp</span><br><span class="line">libseccomp-2.5.1-1.el8.x86_64</span><br></pre></td></tr></table></figure><h5 id="下载安装containerd"><a href="#下载安装containerd" class="headerlink" title="下载安装containerd"></a>下载安装containerd</h5><p>github地址:<a href="https://containerd.io/downloads/">https://containerd.io/downloads/</a></p><p>Containerd安装我们使用<strong>1.6.1</strong>版本号</p><blockquote><p>containerd-1.6.1-linux-amd64.tar.gz 只包含containerd<br>cri-containerd-cni-1.6.4-linux-amd64.tar.gz 包含containerd以及cri runc等相关工具包，建议下载本包</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#下载tar.gz包</span><br><span class="line">#containerd工具包，包含cri runc等</span><br><span class="line">wget https://github.com/containerd/containerd/releases/download/v1.6.4/cri-containerd-cni-1.6.4-linux-amd64.tar.gz</span><br><span class="line">#备用下载地址</span><br><span class="line">wget https://d.frps.cn/file/kubernetes/containerd/cri-containerd-cni-1.6.4-linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p>工具包文件如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#cri-containerd-cni会将我们整个containerd相关的依赖都进行下载下来</span><br><span class="line">[root@k8s-01 containerd]# tar zxvf cri-containerd-cni-1.6.4-linux-amd64.tar.gz -C /   #我们直接让它给我们对应的目录给替换掉</span><br><span class="line">etc/</span><br><span class="line">etc/systemd/</span><br><span class="line">etc/systemd/system/</span><br><span class="line">etc/systemd/system/containerd.service</span><br><span class="line">etc/crictl.yaml</span><br><span class="line">etc/cni/</span><br><span class="line">etc/cni/net.d/</span><br><span class="line">etc/cni/net.d/10-containerd-net.conflist</span><br><span class="line">usr/</span><br><span class="line">usr/local/</span><br><span class="line">usr/local/sbin/</span><br><span class="line">usr/local/sbin/runc</span><br><span class="line">usr/local/bin/</span><br><span class="line">usr/local/bin/crictl</span><br><span class="line">usr/local/bin/ctd-decoder</span><br><span class="line">usr/local/bin/ctr</span><br><span class="line">usr/local/bin/containerd-shim</span><br><span class="line">usr/local/bin/containerd</span><br><span class="line">usr/local/bin/containerd-shim-runc-v1</span><br><span class="line">usr/local/bin/critest</span><br><span class="line">usr/local/bin/containerd-shim-runc-v2</span><br><span class="line">usr/local/bin/containerd-stress</span><br><span class="line">opt/</span><br><span class="line">opt/containerd/</span><br><span class="line">opt/containerd/cluster/</span><br><span class="line">opt/containerd/cluster/version</span><br><span class="line">opt/containerd/cluster/gce/</span><br><span class="line">opt/containerd/cluster/gce/cni.template</span><br><span class="line">opt/containerd/cluster/gce/env</span><br><span class="line">opt/containerd/cluster/gce/configure.sh</span><br><span class="line">opt/containerd/cluster/gce/cloud-init/</span><br><span class="line">opt/containerd/cluster/gce/cloud-init/node.yaml</span><br><span class="line">opt/containerd/cluster/gce/cloud-init/master.yaml</span><br><span class="line">opt/cni/</span><br><span class="line">opt/cni/bin/</span><br><span class="line">opt/cni/bin/firewall</span><br><span class="line">opt/cni/bin/portmap</span><br><span class="line">opt/cni/bin/host-local</span><br><span class="line">opt/cni/bin/ipvlan</span><br><span class="line">opt/cni/bin/host-device</span><br><span class="line">opt/cni/bin/sbr</span><br><span class="line">opt/cni/bin/vrf</span><br><span class="line">opt/cni/bin/static</span><br><span class="line">opt/cni/bin/tuning</span><br><span class="line">opt/cni/bin/bridge</span><br><span class="line">opt/cni/bin/macvlan</span><br><span class="line">opt/cni/bin/bandwidth</span><br><span class="line">opt/cni/bin/vlan</span><br><span class="line">opt/cni/bin/dhcp</span><br><span class="line">opt/cni/bin/loopback</span><br><span class="line">opt/cni/bin/ptp</span><br></pre></td></tr></table></figure><p>上面的文件都是二进制文件，直接移动到对应的目录并配置好环境变量就可以进行使用了。</p><p>如果我们机器上通过yum安装docker了，可以用下面的命令进行卸载</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker </span><br><span class="line">                  docker-client </span><br><span class="line">                  docker-client-latest </span><br><span class="line">                  docker-common </span><br><span class="line">                  docker-latest </span><br><span class="line">                  docker-latest-logrotate </span><br><span class="line">                  docker-logrotate </span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><p>接下来我们为每台服务器配置Containerd</p><p>#创建配置文件目录<br>[root@k8s-01 ~]# mkdir /etc/containerd -p<br>#生成默认配置文件<br>[root@k8s-01 ~]# containerd config default &gt; /etc/containerd/config.toml<br>#–config,-c可以在启动守护程序时更改此路径<br>#配置文件的默认路径位于/etc/containerd/config.toml<br>替换默认pause镜像地址</p><p>默认情况下k8s.gcr.io无法访问，所以使用我提供的阿里云镜像仓库地址即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/k8s.gcr.io/registry.cn-beijing.aliyuncs.com/abcdocker/&#x27; /etc/containerd/config.toml</span><br><span class="line"></span><br><span class="line">#所有节点更换默认镜像地址</span><br><span class="line">#我这里使用阿里云地址</span><br></pre></td></tr></table></figure><p>配置systemd作为容器的cgroup driver</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/SystemdCgroup = false/SystemdCgroup = true/&#x27; /etc/containerd/config.toml</span><br></pre></td></tr></table></figure><p>Containerd官方操作手册</p><p>默认cri-containerd-cni包中会有containerd启动脚本，我们已经解压到对应的目录，可以直接调用启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-01 ~]# systemctl enable containerd --now   </span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/containerd.service to /etc/systemd/system/containerd.service.</span><br><span class="line">[root@k8s-01 ~]# systemctl status containerd   #查看containerd启动状态</span><br><span class="line">● containerd.service - containerd container runtime</span><br><span class="line">   Loaded: loaded (/etc/systemd/system/containerd.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Thu 2022-05-12 22:59:19 EDT; 3s ago</span><br><span class="line">     Docs: https://containerd.io</span><br><span class="line">  Process: 30048 ExecStartPre=/sbin/modprobe overlay (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 30050 (containerd)</span><br><span class="line">   Memory: 24.5M</span><br><span class="line">   CGroup: /system.slice/containerd.service</span><br><span class="line">           └─30050 /usr/local/bin/containerd</span><br><span class="line">May 12 22:59:19 web01 containerd[30050]: time=&quot;2022-05-12T22:59:19.153514446-04:00&quot; level=info msg=&quot;Get image filesystem path &quot;/var/lib/containerd/io.containerd.snapshotter.v1.overlayfs&quot;&quot;</span><br><span class="line">May 12 22:59:19 web01 containerd[30050]: time=&quot;2022-05-12T22:59:19.154085898-04:00&quot; level=info msg=&quot;Start subscribing containerd event&quot;</span><br><span class="line">May 12 22:59:19 web01 containerd[30050]: time=&quot;2022-05-12T22:59:19.154137039-04:00&quot; level=info msg=&quot;Start recovering state&quot;</span><br><span class="line">May 12 22:59:19 web01 containerd[30050]: time=&quot;2022-05-12T22:59:19.154230615-04:00&quot; level=info msg=&quot;Start event monitor&quot;</span><br><span class="line">May 12 22:59:19 web01 containerd[30050]: time=&quot;2022-05-12T22:59:19.154276701-04:00&quot; level=info msg=&quot;Start snapshots syncer&quot;</span><br><span class="line">May 12 22:59:19 web01 containerd[30050]: time=&quot;2022-05-12T22:59:19.154299287-04:00&quot; level=info msg=&quot;Start cni network conf syncer for default&quot;</span><br><span class="line">May 12 22:59:19 web01 containerd[30050]: time=&quot;2022-05-12T22:59:19.154316094-04:00&quot; level=info msg=&quot;Start streaming server&quot;</span><br><span class="line">May 12 22:59:19 web01 containerd[30050]: time=&quot;2022-05-12T22:59:19.154675632-04:00&quot; level=info msg=serving... address=/run/containerd/containerd.sock.ttrpc</span><br><span class="line">May 12 22:59:19 web01 containerd[30050]: time=&quot;2022-05-12T22:59:19.154755704-04:00&quot; level=info msg=serving... address=/run/containerd/containerd.sock</span><br><span class="line">May 12 22:59:19 web01 containerd[30050]: time=&quot;2022-05-12T22:59:19.155220379-04:00&quot; level=info msg=&quot;containerd successfully booted in 0.027654s&quot;</span><br></pre></td></tr></table></figure><p>ctr在我们解压包中已经附带了，直接可以使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-01 ~]# ctr version</span><br><span class="line">Client:     #ctr版本号</span><br><span class="line">  Version:  v1.6.4</span><br><span class="line">  Revision: 212e8b6fa2f44b9c21b2798135fc6fb7c53efc16</span><br><span class="line">  Go version: go1.17.9</span><br><span class="line">Server:</span><br><span class="line">  Version:  v1.6.4     #containerd版本号</span><br><span class="line">  Revision: 212e8b6fa2f44b9c21b2798135fc6fb7c53efc16</span><br><span class="line">  UUID: b376d7b6-c97e-4b39-8144-9624ade3ba84</span><br><span class="line">#可以使用下面命令查看containerd版本号</span><br><span class="line">[root@k8s-01 ~]# containerd --version</span><br><span class="line">containerd github.com/containerd/containerd v1.6.4 212e8b6fa2f44b9c21b2798135fc6fb7c53efc16</span><br></pre></td></tr></table></figure><h2 id="Kubeadm-安装配置"><a href="#Kubeadm-安装配置" class="headerlink" title="Kubeadm 安装配置"></a>Kubeadm 安装配置</h2><p>首先我们需要在k8s-01配置kubeadm源</p><blockquote><p>下面kubeadm操作只需要在k8s-01上即可</p></blockquote><p>国内源</p><p>packages.cloud.google.com这里懂的都懂，下面改成阿里云源</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">        http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>官方文档推荐源</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-$basearch</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span><br><span class="line">exclude=kubelet kubeadm kubectl</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>k8s-01节点安装kubeadm和master相关依赖组建</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y kubelet-1.24.0 kubeadm-1.24.0 kubectl-1.24.0 --disableexcludes=kubernetes</span><br></pre></td></tr></table></figure><p>将k8s-01节点的kubelet设置成开机启动：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable --now kubelet</span><br></pre></td></tr></table></figure><p>配置kubeadm文件</p><p>这里我们在k8s-01上配置打印init默认配置信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubeadm config print init-defaults &gt;kubeadm-init.yaml</span><br></pre></td></tr></table></figure><p>虽然kubeadm作为etcd节点的管理工具，但请注意kubeadm不打算支持此类节点的证书轮换或升级。长期计划是使用etcdadm来工具来进行管理。</p><p>因为我这里要做集群，请根据我这里的配置按需修改</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-01 ~]# cat kubeadm-init.yaml </span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta3</span><br><span class="line">bootstrapTokens:</span><br><span class="line">- groups:</span><br><span class="line">  - system:bootstrappers:kubeadm:default-node-token</span><br><span class="line">  token: abcdef.0123456789abcdef</span><br><span class="line">  ttl: 24h0m0s</span><br><span class="line">  usages:</span><br><span class="line">  - signing</span><br><span class="line">  - authentication</span><br><span class="line">kind: InitConfiguration</span><br><span class="line">localAPIEndpoint:</span><br><span class="line">  advertiseAddress: 192.168.31.10               #k8s-01 ip地址</span><br><span class="line">  bindPort: 6443</span><br><span class="line">nodeRegistration:</span><br><span class="line">  criSocket: unix:///var/run/containerd/containerd.sock</span><br><span class="line">  imagePullPolicy: IfNotPresent</span><br><span class="line">  name: k8s-01</span><br><span class="line">  taints: null</span><br><span class="line">---</span><br><span class="line">apiServer:</span><br><span class="line">  timeoutForControlPlane: 4m0s</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta3</span><br><span class="line">certificatesDir: /etc/kubernetes/pki</span><br><span class="line">clusterName: kubernetes</span><br><span class="line">controllerManager: &#123;&#125;</span><br><span class="line">dns: &#123;&#125;</span><br><span class="line">etcd:</span><br><span class="line">    local:</span><br><span class="line">      dataDir: /var/lib/etcd</span><br><span class="line">imageRepository: k8s.gcr.io</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: 1.24.0</span><br><span class="line">networking:</span><br><span class="line">  dnsDomain: cluster.local</span><br><span class="line">  serviceSubnet: 10.96.0.0/12</span><br><span class="line">  podSubnet: 10.244.0.0/16</span><br><span class="line">scheduler: &#123;&#125;</span><br><span class="line">---</span><br><span class="line">apiVersion: kubeproxy.config.k8s.io/v1alpha1</span><br><span class="line">kind: KubeProxyConfiguration</span><br><span class="line">mode: ipvs                                            # kube-proxy 模式</span><br><span class="line">---</span><br><span class="line">apiVersion: kubelet.config.k8s.io/v1beta1</span><br><span class="line">authentication:</span><br><span class="line">  anonymous:</span><br><span class="line">    enabled: false</span><br><span class="line">  webhook:</span><br><span class="line">    cacheTTL: 0s</span><br><span class="line">    enabled: true</span><br><span class="line">  x509:</span><br><span class="line">    clientCAFile: /etc/kubernetes/pki/ca.crt</span><br><span class="line">authorization:</span><br><span class="line">  mode: Webhook</span><br><span class="line">  webhook:</span><br><span class="line">    cacheAuthorizedTTL: 0s</span><br><span class="line">    cacheUnauthorizedTTL: 0s</span><br><span class="line">clusterDNS:</span><br><span class="line">- 10.96.0.10</span><br><span class="line">clusterDomain: cluster.local</span><br><span class="line">cpuManagerReconcilePeriod: 0s</span><br><span class="line">evictionPressureTransitionPeriod: 0s</span><br><span class="line">fileCheckFrequency: 0s</span><br><span class="line">healthzBindAddress: 127.0.0.1</span><br><span class="line">healthzPort: 10248</span><br><span class="line">httpCheckFrequency: 0s</span><br><span class="line">imageMinimumGCAge: 0s</span><br><span class="line">kind: KubeletConfiguration</span><br><span class="line">cgroupDriver: systemd                   # 配置 cgroup driver</span><br><span class="line">logging: &#123;&#125;</span><br><span class="line">memorySwap: &#123;&#125;</span><br><span class="line">nodeStatusReportFrequency: 0s</span><br><span class="line">nodeStatusUpdateFrequency: 0s</span><br><span class="line">rotateCertificates: true</span><br><span class="line">runtimeRequestTimeout: 0s</span><br><span class="line">shutdownGracePeriod: 0s</span><br><span class="line">shutdownGracePeriodCriticalPods: 0s</span><br><span class="line">staticPodPath: /etc/kubernetes/manifests</span><br><span class="line">streamingConnectionIdleTimeout: 0s</span><br><span class="line">syncFrequency: 0s</span><br><span class="line">volumeStatsAggPeriod: 0s</span><br></pre></td></tr></table></figure><p>检查配置文件是否有错误</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-01 ~]# kubeadm init --config kubeadm-init.yaml --dry-run</span><br></pre></td></tr></table></figure><p>正确如下</p><p>1652881108147.png</p><p>预先拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-01 ~]# kubeadm config images list --config kubeadm-init.yaml </span><br><span class="line">k8s.gcr.io/kube-apiserver:v1.24.0</span><br><span class="line">k8s.gcr.io/kube-controller-manager:v1.24.0</span><br><span class="line">k8s.gcr.io/kube-scheduler:v1.24.0</span><br><span class="line">k8s.gcr.io/kube-proxy:v1.24.0</span><br><span class="line">k8s.gcr.io/pause:3.7</span><br><span class="line">k8s.gcr.io/etcd:3.5.3-0</span><br><span class="line">k8s.gcr.io/coredns/coredns:v1.8.6</span><br></pre></td></tr></table></figure><p>提前下载镜像导入，默认情况使用的是k8s.gcr.io，这个镜像地址我们无法pull，所以使用导入的方式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://d.frps.cn/file/kubernetes/image/k8s_all_1.24.tar</span><br><span class="line">#拷贝到其它节点</span><br><span class="line">for i in k8s-02 k8s-03 k8s-04 k8s-05;do</span><br><span class="line">    scp k8s_all_1.24.tar root@$i:/root/</span><br><span class="line">    ssh root@$i ctr -n k8s.io i import k8s_all_1.24.tar</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>检查</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-01 ~]# ctr -n k8s.io i ls -q</span><br><span class="line">k8s.gcr.io/coredns/coredns:v1.8.6</span><br><span class="line">k8s.gcr.io/etcd:3.5.3-0</span><br><span class="line">k8s.gcr.io/kube-apiserver:v1.24.0</span><br><span class="line">k8s.gcr.io/kube-controller-manager:v1.24.0</span><br><span class="line">k8s.gcr.io/kube-proxy:v1.24.0</span><br><span class="line">k8s.gcr.io/kube-scheduler:v1.24.0</span><br><span class="line">k8s.gcr.io/pause:3.7</span><br></pre></td></tr></table></figure><h2 id="Kubectl-安装"><a href="#Kubectl-安装" class="headerlink" title="Kubectl 安装"></a>Kubectl 安装</h2><p>这一步可以省略，可以通过后续yum安装，这一步可以忽略</p><blockquote><p>kubeadm不会安装或管理kubelet，kubectl因此需要确保它们kubeadm和Kubernetes版本相匹配。如果不这样，则存在版本偏差的风险。但是，支持kubelet和k8s之间的一个小版本偏差，但kubelet版本可能永远不会超过API Server版本</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#下载1.24.0 kubectl工具</span><br><span class="line">[root@k8s-01 ~]# curl -LO https://dl.k8s.io/release/v1.24.0/bin/linux/amd64/kubectl</span><br><span class="line">[root@k8s-01 ~]# chmod +x kubectl &amp;&amp; mv kubectl /usr/local/bin/</span><br><span class="line">#检查kubectl工具版本号</span><br><span class="line">[root@k8s-01 ~]# kubectl version --client --output=yaml</span><br><span class="line">clientVersion:</span><br><span class="line">  buildDate: &quot;2022-05-03T13:46:05Z&quot;</span><br><span class="line">  compiler: gc</span><br><span class="line">  gitCommit: 4ce5a8954017644c5420bae81d72b09b735c21f0</span><br><span class="line">  gitTreeState: clean</span><br><span class="line">  gitVersion: v1.24.0</span><br><span class="line">  goVersion: go1.18.1</span><br><span class="line">  major: &quot;1&quot;</span><br><span class="line">  minor: &quot;24&quot;</span><br><span class="line">  platform: linux/amd64</span><br><span class="line">kustomizeVersion: v4.5.4</span><br><span class="line">#拷贝kubectl到其它master节点</span><br><span class="line">for i in k8s-02 k8s-03;do</span><br><span class="line">    scp /usr/local/bin/kubectl root@$i:/usr/local/bin/kubectl</span><br><span class="line">    ssh root@$i chmod +x /usr/local/bin/kubectl</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>接下来开始初始化</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-01 ~]#  kubeadm init --config kubeadm-init.yaml  --upload-certs</span><br></pre></td></tr></table></figure><p>初始化过程</p><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-34.png" alt><p>初始化完成</p><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-35.png" alt><p>记住init后打印的token，复制kubectl的kubeconfig，kubectl的kubeconfig路径默认是~/.kube/config</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>初始化的配置文件为保存在configmap里面</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl -n kube-system get cm kubeadm-config -o yaml</span><br></pre></td></tr></table></figure><p>接下来执行kubectl就可以看到node了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-01 ~]# kubectl get node</span><br><span class="line">NAME     STATUS   ROLES           AGE     VERSION</span><br><span class="line">k8s-01   Ready    control-plane   4m18s   v1.24.0</span><br></pre></td></tr></table></figure><h2 id="Master节点配置"><a href="#Master节点配置" class="headerlink" title="Master节点配置"></a>Master节点配置</h2><p>前面我们已经为所有master节点配置了一下服务</p><ul><li>nginx</li><li>keeplived</li><li>containerd </li></ul><p>接下来只需要给其它master节点安装k8s组件  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">        http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>安装相关组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y kubelet-1.24.0 kubeadm-1.24.0 kubectl-1.24.0 --disableexcludes=kubernetes</span><br></pre></td></tr></table></figure><p>启动kubelet</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable --now kubelet</span><br></pre></td></tr></table></figure><p>master执行添加节点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubeadm join apiserver.frps.cn:8443 --token abcdef.0123456789abcdef </span><br><span class="line">        --discovery-token-ca-cert-hash sha256:a54c17e514edba57226f969268227b749d8bfb8802ae99112e08cbcabcd22ae0 </span><br><span class="line">        --control-plane --certificate-key f7b0eb9c7e0aac2c95eef083c591950109434250a6df9cc0dc1ec9fb04461250</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设置kubectl config文件</span><br></pre></td></tr></table></figure><p>mkdir -p $HOME/.kube<br>sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config<br>sudo chown $(id -u):$(id -g) $HOME/.kube/config</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目前我们3台master节点已经添加完毕</span><br></pre></td></tr></table></figure><p>[root@k8s-02 ~]# kubectl get node<br>NAME     STATUS   ROLES           AGE     VERSION<br>k8s-01   Ready    control-plane   15m     v1.24.0<br>k8s-02   Ready    control-plane   6m25s   v1.24.0<br>k8s-03   Ready    control-plane   14m     v1.24.0</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## Node节点配置</span><br><span class="line">##### node节点安装kubeadm</span><br></pre></td></tr></table></figure><p>cat &lt;<EOF> /etc/yum.repos.d/kubernetes.repo<br>[kubernetes]<br>name=Kubernetes<br>baseurl=<a href="http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64">http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</a><br>enabled=1<br>gpgcheck=0<br>repo_gpgcheck=0<br>gpgkey=<a href="http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg">http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</a><br>        <a href="http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg">http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</a><br>EOF</EOF></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##### 安装相关组件</span><br></pre></td></tr></table></figure><p>yum install -y kubeadm-1.24.0 –disableexcludes=kubernetes</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">添加join命令</span><br></pre></td></tr></table></figure><p>kubeadm join apiserver.frps.cn:8443 –token abcdef.0123456789abcdef<br>        –discovery-token-ca-cert-hash sha256:a54c17e514edba57226f969268227b749d8bfb8802ae99112e08cbcabcd22ae0 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果我们后续需要添加node节点时，可以到k8s-01节点执行下面的命令获取token相关信息</span><br></pre></td></tr></table></figure><p>[root@k8s-01 ~]# kubeadm token create –print-join-command<br>kubeadm join apiserver.frps.cn:8443 –token sgvcen.qf87ykht9gopqe0d –discovery-token-ca-cert-hash sha256:f535fdf0af19022a30760fd5069c648019a3f4b4828bfb2eb566224d76d21647 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果我们添加某台节点异常了，修改后可以执行下面的命令，然后在重新join加入集群</span><br></pre></td></tr></table></figure><p>kubeadm reset</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">验证所有服务器是否添加到集群中</span><br></pre></td></tr></table></figure><p>[root@k8s-01 ~]# kubectl get node -o wide<br>NAME     STATUS   ROLES           AGE    VERSION   INTERNAL-IP     EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION                CONTAINER-RUNTIME<br>k8s-01   Ready    control-plane   22m    v1.24.0   192.168.31.10   <none>        CentOS Linux 7 (Core)   5.17.8-1.el7.elrepo.x86_64    containerd://1.6.4<br>k8s-02   Ready    control-plane   13m    v1.24.0   192.168.31.11   <none>        CentOS Linux 7 (Core)   5.17.8-1.el7.elrepo.x86_64    containerd://1.6.4<br>k8s-03   Ready    control-plane   21m    v1.24.0   192.168.31.12   <none>        CentOS Linux 7 (Core)   5.17.8-1.el7.elrepo.x86_64    containerd://1.6.4<br>k8s-04   Ready    <none>          107s   v1.24.0   192.168.31.13   <none>        CentOS Linux 7 (Core)   5.17.8-1.el7.elrepo.x86_64    containerd://1.6.4<br>k8s-05   Ready    <none>          6m6s   v1.24.0   192.168.31.14   <none>        CentOS Linux 7 (Core)   3.10.0-1160.62.1.el7.x86_64   containerd://1.6.4</none></none></none></none></none></none></none></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 网络配置</span><br><span class="line">这个时候其实集群还不能正常使用，因为还没有安装网络插件，接下来安装网络插件，可以在文档 https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/ 中选择我们自己的网络插件，这里我们安装 flannel</span><br></pre></td></tr></table></figure><p>wget <a href="http://down.i4t.com/k8s1.24/kube-flannel.yml">http://down.i4t.com/k8s1.24/kube-flannel.yml</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据需求修改网卡配置，我这里以ens160为主</span><br></pre></td></tr></table></figure><pre><code>  containers:  - name: kube-flannel    image: quay.io/coreos/flannel:v0.12.0-amd64    command:    - /opt/bin/flanneld    args:    - --ip-masq    - --kube-subnet-mgr    - --iface=ens160  # 如果是多网卡的话，指定内网网卡的名称</code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">温馨提示: 在kubeadm.yaml文件中设置了podSubnet网段，同时在flannel中网段也要设置相同的。 （我这里默认就是相同的配置）</span><br><span class="line"></span><br><span class="line">执行</span><br></pre></td></tr></table></figure><p>[root@k8s-01 ~]# kubectl apply -f kube-flannel.yml </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## CNI插件问题</span><br><span class="line">默认情况下containerd也会有一个cni插件，但是我们已经安装Flannel了，我们需要使用Flannel的cni插件，需要将containerd里面的cni配置文件进行注释，否则2个配置会产生冲突</span><br><span class="line"></span><br><span class="line">因为如果这个目录中有多个 cni 配置文件，kubelet 将会使用按文件名的字典顺序排列的第一个作为配置文件，所以前面默认选择使用的是 containerd-net 这个插件。</span><br></pre></td></tr></table></figure><p>mv /etc/cni/net.d/10-containerd-net.conflist /etc/cni/net.d/10-containerd-net.conflist.bak<br>ifconfig cni0 down &amp;&amp; ip link delete cni0<br>systemctl daemon-reload<br>systemctl restart containerd kubelet</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">接下来我们所有的pod都可以正常运行了</span><br><span class="line"></span><br><span class="line">&#123;% asset_img pasted-36.png  %&#125;</span><br><span class="line"></span><br><span class="line">##### 验证集群</span><br><span class="line">等kube-system命名空间下的Pod都为Running，这里先测试一下dns是否正常</span><br></pre></td></tr></table></figure><p>cat&lt;&lt;EOF | kubectl apply -f -<br>apiVersion: apps/v1<br>kind: Deployment<br>metadata:<br>  name: nginx<br>spec:<br>  selector:<br>    matchLabels:<br>      app: nginx<br>  template:<br>    metadata:<br>      labels:<br>        app: nginx<br>    spec:<br>      containers:<br>      - image: nginx:alpine<br>        name: nginx<br>        ports:<br>        - containerPort: 80</p><hr><p>apiVersion: v1<br>kind: Service<br>metadata:<br>  name: nginx<br>spec:<br>  selector:<br>    app: nginx<br>  type: NodePort<br>  ports:<br>    - protocol: TCP<br>      port: 80<br>      targetPort: 80<br>      nodePort: 30001</p><hr><p>apiVersion: v1<br>kind: Pod<br>metadata:<br>  name: busybox<br>  namespace: default<br>spec:<br>  containers:</p><ul><li>name: busybox<br>image: abcdocker9/centos:v1<br>command:<ul><li>sleep</li><li>“3600”<br>imagePullPolicy: IfNotPresent<br>restartPolicy: Always<br>EOF<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建后Pod我们进行检查</span><br></pre></td></tr></table></figure></li></ul></li></ul><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-37.png" alt><p>使用nslookup查看是否能返回地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-01 ~]# kubectl exec -ti busybox -- nslookup kubernetes</span><br><span class="line">Server:         10.96.0.10</span><br><span class="line">Address:        10.96.0.10#53</span><br><span class="line">Name:   kubernetes.default.svc.cluster.local</span><br><span class="line">Address: 10.96.0.1</span><br></pre></td></tr></table></figure><p>测试nginx svc以及Pod内部网络通信是否正常</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in k8s-01 k8s-02 k8s-03 k8s-04 k8s-05</span><br><span class="line">do</span><br><span class="line">   ssh root@$i curl -s 10.99.209.220   #nginx svc ip</span><br><span class="line">   ssh root@$i curl -s 10.244.3.4   #pod ip</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>访问宿主机nodePort端口</p><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-38.png" alt><blockquote><p>转载自 <a href="https://i4t.com/5451.html">https://i4t.com/5451.html</a> ，进行了一些勘误。如侵权，请联系删除。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过Autosub为音频视频自动生成字幕文件</title>
      <link href="/posts/2022/05/e0ba2ad4.html"/>
      <url>/posts/2022/05/e0ba2ad4.html</url>
      
        <content type="html"><![CDATA[<p>Autosub是一个字幕自动生成工具。它能使用Auditok来自动检测语音区域，通过ffmpeg根据语音区域来切割音频，通过多个API将语音转为文字，以及通过py-googletrans将字幕文本翻译。</p><h3 id="autosub"><a href="#autosub" class="headerlink" title="autosub"></a>autosub</h3><p>autosub 原本使用 python 2.X 开发，仅支持 linux 和 macos 系统，现已停止维护</p><p>其原理是对音视频文件进行语音活动检测以查找说话的区域，然后并行调用 Google Web Speech API 进行转录，（可选）翻译成目标语言，并将结果存储下来。</p><h3 id="autosub3"><a href="#autosub3" class="headerlink" title="autosub3"></a>autosub3</h3><p>基于 autosub，升级到 python 3.X 版本，并添加了对 windows 系统的支持。</p><p>源码库：<a href="https://github.com/BingLingGroup/autosub">Github</a></p><span id="more"></span> <h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>依赖 ffmpeg 进行音频提取，需要自己手动安装，并添加到系统环境变量中。</p><p>autosub3 的安装非常简单，执行以下命令即可：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install autosub3</span><br></pre></td></tr></table></figure><p>注意<br>由于要调用 google speech 的 API，请自行翻墙。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">autosub abc.mp4</span><br></pre></td></tr></table></figure><p>即可在 abc.mp4 同目录下生成 abc.srt 的字幕文件。  </p><p>指定语言为中文：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">autosub -S zh-CN -D zh-CN videoplayback.mp4 </span><br></pre></td></tr></table></figure><p>查看参数说明:  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">autosub --help</span><br></pre></td></tr></table></figure><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p>请参见Github autosub库的<br><a href="https://github.com/BingLingGroup/autosub/blob/dev/docs/README.zh-Hans.md">使用说明</a></p>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频剪辑 </tag>
            
            <tag> 字幕 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用脚本快速安装docker和k8s</title>
      <link href="/posts/2022/05/4feefd57.html"/>
      <url>/posts/2022/05/4feefd57.html</url>
      
        <content type="html"><![CDATA[<h2 id="使用脚本快速安装docker"><a href="#使用脚本快速安装docker" class="headerlink" title="使用脚本快速安装docker"></a>使用脚本快速安装docker</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">环境要求：</span><br><span class="line"></span><br><span class="line">Docker 需要安装在 64 位的 x86 平台或 ARM 平台上（如树莓派） ，并且要求内核 版本不低于 3.10。  </span><br><span class="line">但实际上内核越新越好，过低的内核版本可能会出现部分功能无 法使用，或者不稳定。</span><br></pre></td></tr></table></figure><p>执行如下命令即可：</p><span id="more"></span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/docker | sh</span><br></pre></td></tr></table></figure><h2 id="使用脚本快速安装k8s"><a href="#使用脚本快速安装k8s" class="headerlink" title="使用脚本快速安装k8s**"></a>使用脚本快速安装k8s**</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">环境要求：</span><br><span class="line">一台或多台机器，操作系统CentOS7.x-86_x64</span><br><span class="line">硬件配置：内存2GB或2G+，CPU 2核或CPU 2核+</span><br><span class="line">集群内各个机器之间能相互通信</span><br><span class="line">集群内各个机器可以访问外网，需要拉取镜像</span><br><span class="line">禁止swap分区</span><br></pre></td></tr></table></figure><p>下载安装脚本 <a href="https://link.juejin.cn/?target=https://www.aliyundrive.com/s/3yzGyfRjhLu">install_k8s.sh</a><br>上传到待安装机器，并分配执行权限chmod +x install_k8s.sh<br>执行脚本sh install_k8s.sh </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x ./install_k8s.sh  </span><br><span class="line">./install_k8s.sh </span><br></pre></td></tr></table></figure><p>安装步骤就是这么简单，so easy ^_^  </p><p>注：如果指定k8s版本号，可直接修改脚本。</p>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
          <category> 容器技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> K8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员下一个项目的灵感来源</title>
      <link href="/posts/2022/05/3427750e.html"/>
      <url>/posts/2022/05/3427750e.html</url>
      
        <content type="html"><![CDATA[<p>这个网站收集很多从不同应用商店收集到的那些人们愿意付费，但是评分很低的软件 / 插件 / 扩展。你可以在这里找到下一个项目的灵感。</p><p>这些 APP 都是经过市场检验的有真正用户需求，人们有付费意愿的，只是现在的 APP 做的不够好，你可以从中选取你感兴趣的，做一个复刻和升级。</p><span id="more"></span> <p><a href="https://ideasfilter.com/">https://ideasfilter.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何升级nodejs版本</title>
      <link href="/posts/2022/05/4feb9d30.html"/>
      <url>/posts/2022/05/4feb9d30.html</url>
      
        <content type="html"><![CDATA[<p>方法一： 用n升级nodejs</p><span id="more"></span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看当前node版本</span><br><span class="line">$ node -v</span><br><span class="line"></span><br><span class="line"># 清除npm缓存</span><br><span class="line">$ npm cache clean -f</span><br><span class="line"></span><br><span class="line"># 全局安装n</span><br><span class="line">$ npm install -g n</span><br><span class="line"></span><br><span class="line"># 升级到最新稳定版</span><br><span class="line">$ n stable</span><br><span class="line"></span><br><span class="line"># 升级到最新版</span><br><span class="line">$ n latest</span><br><span class="line"></span><br><span class="line"># 升级到定制版</span><br><span class="line">$ n v14.6.0</span><br><span class="line"></span><br><span class="line"># 切换使用版本</span><br><span class="line">$ n 13.10.0 (ENTER)</span><br><span class="line"></span><br><span class="line"># 删除制定版本</span><br><span class="line">$ n rm 13.10.0</span><br><span class="line"></span><br><span class="line"># 用制定的版本执行脚本</span><br><span class="line">$ n use 13.10.0 some.js</span><br><span class="line"></span><br><span class="line"># 升级完成查看 node版本</span><br><span class="line">$ node -v</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法二：官网下载<br>去官网 <a href="http://nodejs.cn/">http://nodejs.cn/</a> 下载指定版本安装即可。</p>]]></content>
      
      
      <categories>
          
          <category> Web技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序周日历滑动组件</title>
      <link href="/posts/2022/03/b3b460b2.html"/>
      <url>/posts/2022/03/b3b460b2.html</url>
      
        <content type="html"><![CDATA[<p>最近在做一个小程序的过程中，需要使用到日历的周滑动切换组件，经过查询，找到以下组件满足需求，留着备用。</p><p>实现的功能：  </p><ul><li>可滑动切换上一周和下一周；</li><li>点击年月可跳转到指定日期；</li><li>修复了iOS手机年和日出现NaN的问题。<span id="more"></span> 效果图：</li></ul><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-31.png" alt><p>在components组件文件夹下新建calendarWeek文件夹，创建calendarWeek组件。  </p><p>在需要使用的页面导入使用。</p><p>小程序代码片段，可在微信开发者工具导入使用：<a href="https://developers.weixin.qq.com/s/a4y1NCmP7Anv">https://developers.weixin.qq.com/s/a4y1NCmP7Anv</a></p><p>GitHub源码地址：<a href="https://github.com/Lemon-Yan/calendarWeek">小程序周日历滑动组件</a></p>]]></content>
      
      
      <categories>
          
          <category> Web技术 </category>
          
          <category> 小程序开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux内存占用问题调查——为什么cached占用如此多的内存</title>
      <link href="/posts/2022/03/86365bd7.html"/>
      <url>/posts/2022/03/86365bd7.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、问题描述："><a href="#一、问题描述：" class="headerlink" title="一、问题描述："></a>一、问题描述：</h3><p>线上centos服务器查看内容使用情况：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[root@t-tomcat-online105-jylt ~]# free -g</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:            31         28          2          0          0         27</span><br><span class="line">-/+ buffers/cache:          1         30</span><br><span class="line">Swap:            3          0          3</span><br></pre></td></tr></table></figure><p>系统总内存32g，看Mem下的free大小为2。系统上没有跑任务服务，用ps大概统计下所有程序占用的总内存：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ps aux | awk &#x27;&#123;mem += $6&#125; END &#123;print mem/1024/1024&#125;&#x27;</span><br><span class="line">0.127075</span><br></pre></td></tr></table></figure><p>发现占用内存也非常少。那么，内存到底被哪些隐藏的设置占用着？</p><span id="more"></span> <h3 id="二、问题分析："><a href="#二、问题分析：" class="headerlink" title="二、问题分析："></a>二、问题分析：</h3><p>根据free -g 命令可以看出来，Mem/cached占用了27g，而Mem/used中包含了系统使用的+buffer+cache+slab。所以，到这里就明朗化了，被占用的内存都被cached占有了。</p><p>1）可以这么理解：在linux的内存分配机制中，优先使用物理内存，当物理内存还有空闲时（还够用），不会释放其占用内存，就算占用内存的程序已经被关闭了，该程序所占用的内存用来做缓存使用，对于开启过的程序、或是读取刚存取过得数据会比较快。</p><p>2）因此查看目前进程正在实际被使用的内存，是used-(buffers+cache)，也可以认为如果swap没有大量使用，mem还是够用的，只有mem被当前进程实际占用完（没有了buffers和cache），才会使用到swap的。或者可以通过free命令的第二行来看剩余内存大小，第二行的free列表示系统未使用的内存+buffer+cached。</p><h3 id="三、Linux内存中的Cache真的能被回收么？"><a href="#三、Linux内存中的Cache真的能被回收么？" class="headerlink" title="三、Linux内存中的Cache真的能被回收么？"></a>三、Linux内存中的Cache真的能被回收么？</h3><h4 id="1、什么是buffer-cache？"><a href="#1、什么是buffer-cache？" class="headerlink" title="1、什么是buffer/cache？"></a>1、什么是buffer/cache？</h4><pre><code>   buffer和cache是两个在计算机技术中被用滥的名词，放在不通语境下会有不同的意义。在Linux的内存管理中，这里的buffer指Linux内存的：Buffer cache。这里的cache指Linux内存中的：Page cache。翻译成中文可以叫做缓冲区缓存和页面缓存。在历史上，它们一个（buffer）被用来当成对io设备写的缓存，而另一个（cache）被用来当作对io设备的读缓存，这里的io设备，主要指的是块设备文件和文件系统上的普通文件。但是现在，它们的意义已经不一样了。在当前的内核中，page cache顾名思义就是针对内存页的缓存，说白了就是，如果有内存是以page进行分配管理的，都可以使用page cache作为其缓存来管理使用。当然，不是所有的内存都是以页（page）进行管理的，也有很多是针对块（block）进行管理的，这部分内存使用如果要用到cache功能，则都集中到buffer cache中来使用。（从这个角度出发，是不是buffer cache改名叫做block cache更好？）然而，也不是所有块（block）都有固定长度，系统上块的长度主要是根据所使用的块设备决定的，而页长度在X86上无论是32位还是64位都是4k。</code></pre><p>明白了这两套缓存系统的区别，就可以理解它们究竟都可以用来做什么了。</p><p>1）什么是page cache<br>Page cache主要用来作为文件系统上的文件数据的缓存来用，尤其是针对当进程对文件有read／write操作的时候。如果你仔细想想的话，作为可以映射文件到内存的系统调用：mmap是不是很自然的也应该用到page cache？在当前的系统实现里，page cache也被作为其它文件类型的缓存设备来用，所以事实上page cache也负责了大部分的块设备文件的缓存工作。</p><p>2）什么是buffer cache<br>Buffer cache则主要是设计用来在系统对块设备进行读写的时候，对块进行数据缓存的系统来使用。这意味着某些对块的操作会使用buffer cache进行缓存，比如我们在格式化文件系统的时候。一般情况下两个缓存系统是一起配合使用的，比如当我们对一个文件进行写操作的时候，page cache的内容会被改变，而buffer cache则可以用来将page标记为不同的缓冲区，并记录是哪一个缓冲区被修改了。这样，内核在后续执行脏数据的回写（writeback）时，就不用将整个page写回，而只需要写回修改的部分即可。</p><h4 id="2、如何回收cache？"><a href="#2、如何回收cache？" class="headerlink" title="2、如何回收cache？"></a>2、如何回收cache？</h4><p>Linux内核会在内存将要耗尽的时候，触发内存回收的工作，以便释放出内存给急需内存的进程使用。一般情况下，这个操作中主要的内存释放都来自于对buffer／cache的释放。尤其是被使用更多的cache空间。既然它主要用来做缓存，只是在内存够用的时候加快进程对文件的读写速度，那么在内存压力较大的情况下，当然有必要清空释放cache，作为free空间分给相关进程使用。所以一般情况下，我们认为buffer/cache空间可以被释放，这个理解是正确的。</p><p>但是这种清缓存的工作也并不是没有成本。理解cache是干什么的就可以明白清缓存必须保证cache中的数据跟对应文件中的数据一致，才能对cache进行释放。所以伴随着cache清除的行为的，一般都是系统IO飙高。因为内核要对比cache中的数据和对应硬盘文件上的数据是否一致，如果不一致需要写回，之后才能回收。</p><p>在系统中除了内存将被耗尽的时候可以清缓存以外，我们还可以使用下面这个文件来人工触发缓存清除的操作，方法是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure><p>当然，这个文件可以设置的值分别为1、2、3。它们所表示的含义为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/vm/drop_caches:表示清除pagecache。</span><br><span class="line"></span><br><span class="line">echo 2 &gt; /proc/sys/vm/drop_caches:表示清除回收slab分配器中的对象（包括目录项缓存和inode缓存）。slab分配器是内核中管理内存的一种机制，其中很多缓存数据实现都是用的pagecache。</span><br><span class="line"></span><br><span class="line">echo 3 &gt; /proc/sys/vm/drop_caches:表示清除pagecache和slab分配器中的缓存对象。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> IT技术 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat报错:java.lang.IllegalArgumentException: Invalid character found in the request target解决</title>
      <link href="/posts/2022/03/e9c03763.html"/>
      <url>/posts/2022/03/e9c03763.html</url>
      
        <content type="html"><![CDATA[<p>在web应用的漏洞测试中，在url参数中添加各种非法字符时，会报如下异常：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: Invalid character found in the request target. The valid characters are defined in RFC 7230 and RFC 3986</span><br><span class="line">    at org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:476) ~[tomcat-embed-core-8.5.28.jar:8.5.28]</span><br><span class="line">    at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:687) ~[tomcat-embed-core-8.5.28.jar:8.5.28]</span><br><span class="line">    at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-8.5.28.jar:8.5.28]</span><br><span class="line">    at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:790) [tomcat-embed-core-8.5.28.jar:8.5.28]</span><br><span class="line">    at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1459) [tomcat-embed-core-8.5.28.jar:8.5.28]</span><br><span class="line">    at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-8.5.28.jar:8.5.28]</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_161]</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_161]</span><br><span class="line">    at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-8.5.28.jar:8.5.28]</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748) [na:1.8.0_161]</span><br></pre></td></tr></table></figure><p>这是因为Tomcat严格按照 RFC 3986规范进行访问解析，而 RFC 3986规范定义了Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及所有保留字符(RFC3986中指定了以下字符为保留字符：! * ’ ( ) ; : @ &amp; = + $ , / ? # [ ])。传入的参数中有”{“不在RFC3986中的保留字段中，所以会报这个错。</p><span id="more"></span> <p>解决办法：</p><p>修改Tomcat/conf/server.xml文件，Connector属性修改为如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; relaxedQueryChars=&quot;[]|&#123;&#125;^&amp;#x5c;&amp;#x60;&amp;quot;&amp;lt;&amp;gt;&quot; relaxedPathChars=&quot;[]|&#123;&#125;^&amp;#x5c;&amp;#x60;&amp;quot;&amp;lt;&amp;gt;&quot; redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure><p>如果存在18443的端口，把relaxedPathChars和relaxedQueryChars两个属性值一并加上即可。</p>]]></content>
      
      
      <categories>
          
          <category> Web技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac osx 自带拼音输入法卡顿问题解决</title>
      <link href="/posts/2022/02/e36dea63.html"/>
      <url>/posts/2022/02/e36dea63.html</url>
      
        <content type="html"><![CDATA[<p>为什么 mac osx 自带拼音输入法，总是出现卡顿现象？</p><p>这个问题，知乎上回答最多，好像也无法彻底解决。</p><p>如果你用百度，更是无法解决的。</p><p>问题在于什么呢？</p><p>很多，很多，但核心问题，就是 苹果自带的拼音输入法想要处理的问题太多了。</p><span id="more"></span> <p>我们来看看默认的苹果电脑输入法要解决多少问题!<br>1、首先切换到 拼音输入法 然后右键点击 右上角的 拼 字图标</p><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-28.png" alt> <p>2、点击 打开简体拼音偏好设置，然后切换到 文本，可以看到几乎所有的都勾选了</p><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-29.png" alt>这些功能我们都需要吗？<p>其实不是的，除了第一个 自动纠正拼写 外，其它都是垃圾功能。 都全部取消勾选。</p><p>如果你日常不输入英文等，其实连 自动纠正拼写 都不需要。<br>3、全部取消勾选后的效果图如下</p><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-30.png" alt><p>然后，世界瞬间清净了…</p>]]></content>
      
      
      <categories>
          
          <category> IT技术 </category>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>No goals have been specified for this build，maven报错解决</title>
      <link href="/posts/2022/02/87ad95bb.html"/>
      <url>/posts/2022/02/87ad95bb.html</url>
      
        <content type="html"><![CDATA[<p>在对Maven项目进行Build的时候，可能会出现下图这种情况：<br><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-27.png" alt><br>出现这种情况的原因是，缺少了一个指定的goal，需要在项目的pom.xml文件中添加一项goal数据。添加的位置在<build>标签当中，添加如下配置：</build></p><span id="more"></span>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;defaultGoal&gt;compile&lt;/defaultGoal&gt;</span><br></pre></td></tr></table></figure><p>添加后如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">&lt;defaultGoal&gt;compile&lt;/defaultGoal&gt;</span><br><span class="line">&lt;!-- 打包目录 --&gt;</span><br><span class="line">&lt;directory&gt;target&lt;/directory&gt;</span><br><span class="line">&lt;!-- 打包名称 --&gt;</span><br><span class="line">&lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt;</span><br><span class="line">   ...</span><br><span class="line">&lt;/build&gt;   </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序 TabBar怎么设置默认选中</title>
      <link href="/posts/2022/02/3b9d274e.html"/>
      <url>/posts/2022/02/3b9d274e.html</url>
      
        <content type="html"><![CDATA[<p>微信小程序 TabBar怎么设置默认选中？app.json中，tabbar按照如下写法，进入界面默认选择第一个tab(代码中为“首页”)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;tabBar&quot;: &#123;</span><br><span class="line">    &quot;list&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;pagePath&quot;: &quot;pages/index/index&quot;,</span><br><span class="line">        &quot;text&quot;: &quot;首页&quot;,</span><br><span class="line">        &quot;iconPath&quot;: &quot;/images/icon/home.png&quot;,</span><br><span class="line">        &quot;selectedIconPath&quot;: &quot;/images/icon/home.png&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">          &quot;pagePath&quot;: &quot;pages/message/message&quot;,</span><br><span class="line">          &quot;text&quot;: &quot;消息&quot;,</span><br><span class="line">          &quot;iconPath&quot;: &quot;images/icon/message.png&quot;,</span><br><span class="line">          &quot;selectedIconPath&quot;: &quot;images/icon/message.png&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">      &quot;pagePath&quot;: &quot;pages/my/my&quot;,</span><br><span class="line">      &quot;text&quot;: &quot;我&quot;,</span><br><span class="line">      &quot;iconPath&quot;: &quot;/images/icon/my.png&quot;,</span><br><span class="line">      &quot;selectedIconPath&quot;: &quot;/images/icon/my.png&quot;</span><br><span class="line">      &#125;</span><br><span class="line">  ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><span id="more"></span> <p>假如我想把“消息”栏放在第一个，且默认选中，该怎么做？我自然而然的修改了”tabBar”里的顺序，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;tabBar&quot;: &#123;</span><br><span class="line">    &quot;list&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">          &quot;pagePath&quot;: &quot;pages/message/message&quot;,</span><br><span class="line">          &quot;text&quot;: &quot;消息&quot;,</span><br><span class="line">          &quot;iconPath&quot;: &quot;images/icon/message.png&quot;,</span><br><span class="line">          &quot;selectedIconPath&quot;: &quot;images/icon/message.png&quot;</span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        &quot;pagePath&quot;: &quot;pages/index/index&quot;,</span><br><span class="line">        &quot;text&quot;: &quot;首页&quot;,</span><br><span class="line">        &quot;iconPath&quot;: &quot;/images/icon/home.png&quot;,</span><br><span class="line">        &quot;selectedIconPath&quot;: &quot;/images/icon/home.png&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">      &quot;pagePath&quot;: &quot;pages/my/my&quot;,</span><br><span class="line">      &quot;text&quot;: &quot;我&quot;,</span><br><span class="line">      &quot;iconPath&quot;: &quot;/images/icon/my.png&quot;,</span><br><span class="line">      &quot;selectedIconPath&quot;: &quot;/images/icon/my.png&quot;</span><br><span class="line">      &#125;</span><br><span class="line">  ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>改完一运行，发现“消息”栏虽然显示在第一个了，但是默认选中的还是“首页”…</p><p>研究了一下，发现如果想修改默认选中的tab，只需要修改”pages”数组里的顺序即可，放在前面的会优先选中。<br>所以，此处应该这么改：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;pages&quot;: [</span><br><span class="line">    &quot;pages/message/message&quot;,</span><br><span class="line">    &quot;pages/index/index&quot;,</span><br><span class="line">    &quot;pages/my/my&quot;</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure><p>OK，就这样搞定了！</p>]]></content>
      
      
      <categories>
          
          <category> Web技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序出错 TypeError: _typeof3 is not a function</title>
      <link href="/posts/2022/02/c3bd5b44.html"/>
      <url>/posts/2022/02/c3bd5b44.html</url>
      
        <content type="html"><![CDATA[<p>升级微信开发者工具后，小程序启动报如下错误：<br>TypeError: _typeof3 is not a function at _typeof (typeof.js? [sm]:2)</p><p>@babel\runtime\helpers文件夹下面的typeof.js报错，因为本地装过这个包npm install –save @babel/runtime，直接进去拷一份typeof.js覆盖就好了，新typeof.js如下：</p><span id="more"></span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _typeof(obj) &#123;</span><br><span class="line">  &quot;@babel/helpers - typeof&quot;;</span><br><span class="line"></span><br><span class="line">  if (typeof Symbol === &quot;function&quot; &amp;&amp; typeof Symbol.iterator === &quot;symbol&quot;) &#123;</span><br><span class="line">    module.exports = _typeof = function _typeof(obj) &#123;</span><br><span class="line">      return typeof obj;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    module.exports[&quot;default&quot;] = module.exports, module.exports.__esModule = true;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    module.exports = _typeof = function _typeof(obj) &#123;</span><br><span class="line">      return obj &amp;&amp; typeof Symbol === &quot;function&quot; &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? &quot;symbol&quot; : typeof obj;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    module.exports[&quot;default&quot;] = module.exports, module.exports.__esModule = true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return _typeof(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = _typeof;</span><br><span class="line">module.exports[&quot;default&quot;] = module.exports, module.exports.__esModule = true;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web技术 </category>
          
          <category> 小程序开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS使用yum安装ffmpeg</title>
      <link href="/posts/2022/01/3f63c42c.html"/>
      <url>/posts/2022/01/3f63c42c.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>摘要<br>本文主要解决如下问题：<br>（1）CentOS 7 怎么使用yum安装ffmpeg；<br>（2）CentOS 6 怎么使用yum安装ffmpeg。  </p></blockquote><p>1.安装epel并update yum</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install epel-release -y</span><br><span class="line">sudo yum update -y</span><br></pre></td></tr></table></figure><p>2.安装Nux Dextop Yum 源</p><p>由于CentOS没有官方FFmpeg rpm软件包。但是，我们可以使用第三方YUM源（Nux Dextop）完成此工作。</p><span id="more"></span> <ol><li>CentOS 7<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo rpm --import http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro</span><br><span class="line">sudo rpm -Uvh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-5.el7.nux.noarch.rpm</span><br></pre></td></tr></table></figure></li><li>CentOS 6<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo rpm --import http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro</span><br><span class="line">sudo rpm -Uvh http://li.nux.ro/download/nux/dextop/el6/x86_64/nux-dextop-release-0-2.el6.nux.noarch.rpm</span><br></pre></td></tr></table></figure></li></ol><p>3.安装FFmpeg 和 FFmpeg开发包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install ffmpeg ffmpeg-devel -y</span><br></pre></td></tr></table></figure><p>4.测试是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg</span><br></pre></td></tr></table></figure><p>5.如果你想了解更多关于FFmpeg使用方面的资料，可以输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -h</span><br></pre></td></tr></table></figure><p>例子：<br>使用FFmpeg将mp3转为ogg</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i MLKDream_64kb.mp3 -c:a libvorbis -q:a 4 MLKDream_64kb.ogg</span><br></pre></td></tr></table></figure><p>使用FFmpeg将flv转为mp4</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i beeen.flv -y -vcodec copy -acodec copy beeen.mp4</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> IT技术 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Selenium获取元素的HTML和子元素的方法</title>
      <link href="/posts/2022/01/20e46e56.html"/>
      <url>/posts/2022/01/20e46e56.html</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">本文主要解决如下3个问题：</span><br><span class="line">1、Selenium怎么获取一个元素的HTML源代码</span><br><span class="line">2、Selenium怎么获取元素下的子元素</span><br><span class="line">3、Selenium怎么判断元素是否存在</span><br></pre></td></tr></table></figure><h3 id="Selenium怎么获取一个元素的HTML源代码"><a href="#Selenium怎么获取一个元素的HTML源代码" class="headerlink" title="Selenium怎么获取一个元素的HTML源代码"></a>Selenium怎么获取一个元素的HTML源代码</h3><p>假设需要获取id为articleList的元素的HTML源代码,有两种方法：</p><span id="more"></span> <h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WebElement subTag=driver.findElement(By.id(&quot;articleList&quot;));</span><br><span class="line">String contents = liTag.getAttribute(&quot;outerHTML&quot;);</span><br></pre></td></tr></table></figure><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WebElement element = driver.findElement(By.id(&quot;articleList&quot;));</span><br><span class="line">String contents = (String)((JavascriptExecutor)driver).executeScript(&quot;return      arguments[0].innerHTML;&quot;, element); </span><br></pre></td></tr></table></figure><p>相比较而言，方法一更为简洁。</p><h3 id="Selenium怎么获取元素下的子元素"><a href="#Selenium怎么获取元素下的子元素" class="headerlink" title="Selenium怎么获取元素下的子元素"></a>Selenium怎么获取元素下的子元素</h3><p>Selenium提供了以下8个方法来查找页面中的1个元素：  </p><table><thead><tr><th>Selenium方法</th><th>Java方法</th></tr></thead><tbody><tr><td>find_element_by_id</td><td>driver.findElement(By.id())</td></tr><tr><td>find_element_by_name</td><td>driver.findElement(By.name())</td></tr><tr><td>find_element_by_xpath</td><td>driver.findElement(By.xpath()</td></tr><tr><td>find_element_by_link_text</td><td>driver.findElement(By.linkText()</td></tr><tr><td>find_element_by_partial_link_text</td><td>driver.findElement(By.partialLinkText()</td></tr><tr><td>find_element_by_tag_name</td><td>driver.findElement(By.tagName()</td></tr><tr><td>find_element_by_class_name</td><td>driver.findElement(By.className()</td></tr><tr><td>find_element_by_css_selector</td><td>driver.findElement(By.cssSelector()</td></tr></tbody></table><p>以下7个方法来查找页面中的多个元素（这些方法将返回一个列表）：</p><table><thead><tr><th>Selenium方法</th><th>Java方法</th></tr></thead><tbody><tr><td>find_elements_by_name</td><td>driver.findElements(By.name())</td></tr><tr><td>find_elements_by_xpath</td><td>driver.findElements(By.xpath()</td></tr><tr><td>find_elements_by_link_text</td><td>driver.findElements(By.linkText()</td></tr><tr><td>find_elements_by_partial_link_text</td><td>driver.findElements(By.partialLinkText()</td></tr><tr><td>find_elements_by_tag_name</td><td>driver.findElements(By.tagName()</td></tr><tr><td>find_elements_by_class_name</td><td>driver.findElements(By.className()</td></tr><tr><td>find_elements_by_css_selector</td><td>driver.findElements(By.cssSelector()</td></tr></tbody></table><p>上述方法都是查找页面中的元素的，那么怎么获取一个元素下的子元素呢？其实和获取页面元素类似，以获取parentElement元素下的所有a标签为例:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;WebElement&gt; aTags = parentElement.findElements(By.tagName(&quot;a&quot;));</span><br></pre></td></tr></table></figure><p>总结：获取页面元素的15个方法都可以用来获取元素下的子元素。</p><h3 id="Selenium怎么获取判断元素是否存在"><a href="#Selenium怎么获取判断元素是否存在" class="headerlink" title="Selenium怎么获取判断元素是否存在"></a>Selenium怎么获取判断元素是否存在</h3><p>Selenium 中并没有直接判断元素是否存在的方法，只能通过变通的方式判断。</p><h4 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h4><p>调用findElement方法获取元素，如果抛出异常，就可以判断为元素不存在。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">          webDriver.findElement(by);</span><br><span class="line">          return true;</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">          System.out.println(&quot;不存在此元素&quot;);</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h4><p>WebDriver的findElements()返回一个List<WebElement>元素集合，通过找到元素的size()判断，如果&lt;=0则元素不存在，否则元素存在。另外，findElements方法找不到元素时会返回一个空List，所以不需要进行null判断。</WebElement></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 判断某个元素是否存在</span><br><span class="line">   */</span><br><span class="line">  public boolean isElementExists(WebDriver webDriver, By by) &#123;</span><br><span class="line">      if(webDriver.findElements(by).size()&gt;0)&#123;</span><br><span class="line">      return true;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">      return false;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>显然，相比抛异常进行判断，方法二更为合适，可以直接写进工具类里方便调用。</p>]]></content>
      
      
      <categories>
          
          <category> Web技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Selenium </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Hexo教程-从零开始搭建个人博客】5、Hexo博客部署到GitHub Pages</title>
      <link href="/posts/2022/01/face4142.html"/>
      <url>/posts/2022/01/face4142.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>完成<a href="https://www.yeluohuakai.com/posts/2022/01/71127ac7.html">Hexo博客搭建指南</a>前面几个章节的流程后，本地的Butterfly主题的Hexo博客已经能运行起来了，下面的工作就是要把博客发布到GitHub Pages。</p><p>本文主要解决如下4个问题：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、怎么创建GitHub Pages仓库</span><br><span class="line">2、怎么把本地的Hexo博客部署到GitHub Pages</span><br><span class="line">3、解决使用git时报错：fatal: unable to access &#x27;https://***.github.io/&#x27;: Received HTTP code 400 from proxy after CONNECT</span><br><span class="line">4、解决使用git时报错：remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.</span><br></pre></td></tr></table></figure><span id="more"></span> <h2 id="为什么使用GitHub-Pages"><a href="#为什么使用GitHub-Pages" class="headerlink" title="为什么使用GitHub Pages"></a>为什么使用GitHub Pages</h2><p> GitHub有一个非常有用的功能，称为GitHub Pages，它允许您在Web上实时发布网站代码。</p><p> GitHub Pages的优势：</p><ol><li>搭建简单而且<strong>免费</strong>；  </li><li>支持静态脚本；  </li><li>可以绑定你的域名；  </li><li>理想的写博环境，随意DIY，git+github+markdown+其他；</li><li>充分的自由度，毕竟部署在github上…</li></ol><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>点击你的GitHub主页的”New”，准备创建一个新的仓库；</p><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-16.png" alt></li><li><p>创建仓库有两点要注意：<br><code>仓库类型一定是**public**</code><br><code>仓库名一定是 **你的用户名.github.io**</code><br>以我的测试github账户的用户名yeluohua为例,  仓库名就是 <code>yeluohua.github.io</code>，如图所示:  </p><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-17.png" alt></li><li><p>仓库创建完成之后，进入仓库主页。</p></li></ol><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-18.png" alt><p>点击<code>Settings</code>–&gt;<code>Pages</code>，可以看到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Your site is published at https://yeluohua.github.io/</span><br></pre></td></tr></table></figure><p>这就意味着可以用这个链接访问你的网站了。<br><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-21.png" alt><br>4. 在浏览器中访问 <a href="https://yeluohua.github.io/">https://yeluohua.github.io/</a><br><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-20.png" alt></p><ol start="5"><li>至此，个人GitHub Pages个人仓库已经创建完毕，可以开始部署Hexo博客到仓库了。</li></ol><h2 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h2><ol><li><p>安装模块</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><!--more--> </li><li><p>配置<br>blog/_config.yml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  - type: git</span><br><span class="line">    repo:</span><br><span class="line">      github:</span><br><span class="line">        url: https://github.com:name/name.git # GitHub Pages的https链接</span><br><span class="line">        branch: master # GitHub Pages的分支</span><br><span class="line">        token: GitHub Token</span><br><span class="line">    name: name # GitHub用户名</span><br><span class="line">    email: email@qq.com # GitHub登陆邮箱</span><br></pre></td></tr></table></figure></li><li><p>推送到 GitHub 远程仓库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>如果推送成功的话，会看到如下提示信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Counting objects: 244, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (157/157), done.</span><br><span class="line">Writing objects: 100% (244/244), 47.80 KiB | 627.00 KiB/s, done.</span><br><span class="line">Total 244 (delta 128), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (128/128), completed with 84 local objects.</span><br><span class="line">To https://github.com/***.github.io</span><br><span class="line">   36b5718..8a35a87  HEAD -&gt; master</span><br><span class="line">Branch &#x27;master&#x27; set up to track remote branch &#x27;master&#x27; from &#x27;https://github.com/***.github.io&#x27;.</span><br><span class="line">[32mINFO [39m Deploy done: [35mgit[39m</span><br></pre></td></tr></table></figure></li><li><p>然后在<a href="https://github.com/%E4%BD%A0%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D.github.io%E8%BF%99%E4%B8%AA%E4%BB%93%E5%BA%93%E7%9A%84master%E5%88%86%E6%94%AF%E4%B8%8B%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E5%B7%B2%E4%B8%8A%E4%BC%A0%E7%9A%84%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E3%80%82">https://github.com/你的用户名.github.io这个仓库的master分支下可以看到已上传的静态文件。</a></p></li><li><p>在浏览器中输入<code>https://你的用户名.github.io</code>就能打开你的博客了。</p></li></ol><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="错误一"><a href="#错误一" class="headerlink" title="错误一"></a>错误一</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fatal: unable to access &#x27;https://***.github.io/&#x27;: Received HTTP code 400 from proxy after CONNECT</span><br><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; (d:\Code\hexo\node_modules\hexo-util\lib\spawn.js:51:21)</span><br><span class="line">      at ChildProcess.emit (events.js:315:20)</span><br><span class="line">      at ChildProcess.cp.emit (d:\Code\hexo\node_modules\cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">      at Process.ChildProcess._handle.onexit (internal/child_process.js:277:12) &#123;</span><br><span class="line">    code: 128</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html</span><br></pre></td></tr></table></figure><p>这个错误一般是本地设置了代理导致，尝试使用如下命令解决：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br><span class="line">git config --global --unset core.gitproxy</span><br></pre></td></tr></table></figure><p>使用<code>git config -l --show-origin|grep -i proxy</code>检查设置是否有遗漏。<br>（注：windows下检查命令为<code>git config -l --show-origin|findstr proxy</code>）</p><h3 id="错误二"><a href="#错误二" class="headerlink" title="错误二"></a>错误二</h3><p>推送代码时，弹出一个GitHub的登陆框，输入用户名密码后，控制台会提示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.</span><br></pre></td></tr></table></figure><p>这个很简单，2021年8月13日起GitHub不再支持密码身份验证的解决方案，需要通过github personal access token来进行git操作，按如下步骤生成access token:</p><ol><li>进入 <a href="https://github.com/settings/apps">https://github.com/settings/apps</a></li><li> 点击“Personal access tokens”</li></ol><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-22.png" alt> 3. 点击右上角的“generate new token”,    - 填入Note（access token的标识，随意填）    - 选择access token期限（最好不选永久），    - 权限只需要选择`repo`即可<img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-23.png" alt> 4. 点击“Generate token”生成access token,记录生成的access token<img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-24.png" alt> 5. 删除之前的git用户密码缓存。这一步很关键，一定要删除之前的缓存，不然还是提示上述错误。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 运行一下命令缓存</span><br><span class="line">git config --global credential.helper wincred</span><br><span class="line"># 清除掉缓存在git中的用户名和密码</span><br><span class="line">git credential-manager uninstall</span><br></pre></td></tr></table></figure>6. 重新执行推送到 GitHub 远程仓库，在弹出的GitHub登陆框的密码区域填入刚才生成的access token即可。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web技术 </category>
          
          <category> Hexo搭建博客教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-abbrlink生成的文章链接undefind.html问题解决</title>
      <link href="/posts/2022/01/c7ae70bf.html"/>
      <url>/posts/2022/01/c7ae70bf.html</url>
      
        <content type="html"><![CDATA[<p>使用Hexo博客的过程中，为了生成简洁且唯一链接不变的URL链接，我使用了hexo-abbrlink插件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>然后再Hexo根目录下_config.yml里增加如下配置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改原链接格式：permalink: :year/:month/:day/:title/</span><br><span class="line">permalink: posts/:year/:month/:abbrlink.html</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  # 算法：crc16(default) and crc32</span><br><span class="line">  rep: hex    # 进制：dec(default) and hex</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br></pre></td></tr></table></figure><span id="more"></span> <p>然后执行<code>hexo clean &amp; hexo g &amp; hexo s</code>,打开博客就会看到博客文章的html名称都变成了一串随机数。再去打开文章的md文件，文件头都增加了一行类似<code>abbrlink: e89dcf68</code>，这个abbrlink的值就是hexo-abbrlink插件给文章生成的唯一ID了。这个字段确保了在我们修改了Front-matter 内的博客标题title或创建日期date字段之后而不会改变链接地址，相当于每篇文章有了专属链接了，这样找搜索引擎收录也简单多了。</p><hr><p>给文章生成永久链接原本是比较顺利的，但是几天之后新生成的文章链接居然变成了undefind.html，md文件里也没生成abbrlink，执行<code>hexo clean &amp; hexo g</code>也没啥用。 </p><p>去Google了一番这个问题，总结以下产生该问题的原因：  </p><p>1.文章的链接变成了undefined.html,新的文章没问题，老的文章就不行了。首先要执行hexo clean 清楚掉以前生成的文章缓存，然后hexo g重新生成静态文件就ok了。  </p><p>ps：<code>hexo clean &amp; hexo g</code>多次还是无效，我这是老文章没问题，新文章不行。</p><p>2.如果全部文章的链接都有问题或者没有任何规律，总有一部分文章链接是undefined。建议检查一下文章开头的Front-matter，文章的Front-matter中不能设置layout，将layout属性删掉后就可以正常使用了。 </p><p>ps：检查了md文件中并没有layout，再次无效。</p><p>3.与hexo-auto-category插件冲突。这2款插件都是读写 Front-matter 的数据。如果同时启用这2个插件，会导致hexo-abbrlink这个插件无法向 md 文件里写入 abbrlink 属性。</p><p>据hexo-abbrlink插件作者的说法，此问题无法修复，两个插件只能选其一。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abbrlink:</span><br><span class="line">  auto_category: </span><br><span class="line">    enable: false</span><br><span class="line">  alg: crc32  # 算法：crc16(default) and crc32</span><br><span class="line">  rep: hex    # 进制：dec(default) and hex</span><br></pre></td></tr></table></figure><p>ps：我这里并没有使用hexo-auto-category插件，依旧无效。</p><p>试遍了诸般办法，没能解决问题，心血来潮去看了眼Hexo的扩展包文件package.json……纳尼?居然没有hexo-abbrlink……好吧，我这才想起来，昨天把Hexo给换了个目录，装了一大堆插件，hexo-abbrlink忘记装了。</p><p>所以，第4点原因：  </p><p>4.检查package.json，查看有没有安装hexo-abbrlink插件（比如我这样更换Hexo文件夹的情况）。  </p><hr><p>安装和使用Hexo，请参考<a href="/posts/2022/01/71127ac7.html">Hexo博客搭建指南</a>。  </p>]]></content>
      
      
      <categories>
          
          <category> Web技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决electron打包时下载nsis等依赖慢的问题</title>
      <link href="/posts/2022/01/753a936a.html"/>
      <url>/posts/2022/01/753a936a.html</url>
      
        <content type="html"><![CDATA[<p>初次学习使用Electron，在打包第一个入门应用时就出现了老大难的问题，<code>npm run package</code>命令在运行时会去下载github的资源（如nsis、winCodeSign等），但是这个速度可就太感人。慢就不说了，最后还赤果果的用一大串红字告诉我打包失败。<br>报错信息如下：</p><span id="more"></span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0] npm run build:main exited with code 0</span><br><span class="line">[1] npm run build:renderer exited with code 0</span><br><span class="line">  • electron-builder  version=22.13.1 os=10.0.19043</span><br><span class="line">  • loaded configuration  file=package.json (&quot;build&quot; field)</span><br><span class="line">  • writing effective config  file=release\build\builder-effective-config.yaml</span><br><span class="line">  • installing production dependencies  platform=win32 arch=x64 appDir=D:\Code\Electron\test\release\app</span><br><span class="line">  • packaging       platform=win32 arch=x64 electron=16.0.5 appOutDir=release\build\win-unpacked</span><br><span class="line">  • building        target=nsis file=release\build\ElectronReact Setup 4.5.0.exe archs=x64 oneClick=true perMachine=false</span><br><span class="line">  • downloading     url=https://github.com/electron-userland/electron-builder-binaries/releases/download/nsis-3.0.4.2/nsis-3.0.4.2.7z size=1.4 MB parts=1</span><br><span class="line">  • retrying        attempt=1</span><br><span class="line">  • retrying        attempt=2</span><br><span class="line">  • retrying        attempt=3</span><br><span class="line">  ⨯ part download request failed with status code 401</span><br><span class="line">github.com/develar/app-builder/pkg/download.(*Part).doRequest</span><br><span class="line">        /Volumes/data/Documents/app-builder/pkg/download/Part.go:126</span><br><span class="line">github.com/develar/app-builder/pkg/download.(*Part).download</span><br><span class="line">        /Volumes/data/Documents/app-builder/pkg/download/Part.go:67</span><br><span class="line">github.com/develar/app-builder/pkg/download.(*Downloader).DownloadResolved.func1.1</span><br><span class="line">        /Volumes/data/Documents/app-builder/pkg/download/downloader.go:155</span><br><span class="line">github.com/develar/app-builder/pkg/util.MapAsyncConcurrency.func2</span><br><span class="line">        /Volumes/data/Documents/app-builder/pkg/util/async.go:68</span><br><span class="line">runtime.goexit</span><br><span class="line">        /usr/local/Cellar/go/1.16.5/libexec/src/runtime/asm_amd64.s:1371</span><br><span class="line">  ⨯ D:\Code\Electron\test\node_modules\app-builder-bin\win\x64\app-builder.exe exited with code ERR_ELECTRON_BUILDER_CANNOT_EXECUTE  failedTask=build stackTrace=Error: D:\Code\Electron\test\node_modules\app-builder-bin\win\x64\app-builder.exe exited with code ERR_ELECTRON_BUILDER_CANNOT_EXECUTE</span><br></pre></td></tr></table></figure><p>问题就出在下载github资源太慢了，而cnpm是提供了对应的镜像源的，所以解决办法也挺简单，设置ELECTRON_BUILDER_BINARIES_MIRROR镜像源地址就行了，即修改 <code>C:\Users\你的用户名\.npmrc</code> 文件（如果没有该文件就直接创建）,加入如下代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">registry=https://registry.npm.taobao.org/</span><br><span class="line">electron_mirror=https://npm.taobao.org/mirrors/electron/</span><br><span class="line">isturl=https://npm.taobao.org/mirrors/node</span><br><span class="line">ELECTRON_BUILDER_BINARIES_MIRROR=http://npm.taobao.org/mirrors/electron-builder-binaries/</span><br><span class="line">ELECTRON_MIRROR=https://npm.taobao.org/mirrors/electron/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注:<code>ELECTRON_BUILDER_BINARIES_MIRROR</code>的地址可以改成https的试试。</p><p>然后再去运行<code>npm run package</code>，发现download部分很快就过去了，程序包也打好了，喜极而泣。</p>]]></content>
      
      
      <categories>
          
          <category> Web技术 </category>
          
          <category> Electron </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Electron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装electron失败：npm ERR electron@16.0.5 postinstall: node install.js</title>
      <link href="/posts/2022/01/npmerrelectron.html"/>
      <url>/posts/2022/01/npmerrelectron.html</url>
      
        <content type="html"><![CDATA[<p>安装Electron时报如下错误：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm ERR! code ELIFECYCLE</span><br><span class="line">npm ERR! errno 1</span><br><span class="line">npm ERR! electron@16.0.5 postinstall: `node install.js`</span><br><span class="line">npm ERR! Exit status 1</span><br><span class="line">npm ERR!</span><br><span class="line">npm ERR! Failed at the electron@16.0.5 postinstall script.</span><br><span class="line">npm ERR! This is probably not a problem with npm. There is likely additional logging output above.</span><br></pre></td></tr></table></figure><p>如图所示：</p><span id="more"></span> <img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-15.png" alt="alt:npm ERR! electron@16.0.5 postinstall: node install.js "><p>解决方法：将electron下载地址指向taobao镜像即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set electron_mirror &quot;https://npm.taobao.org/mirrors/electron/&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web技术 </category>
          
          <category> Electron </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Electron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Hexo教程-从零开始搭建个人博客】4、Hexo安装主题</title>
      <link href="/posts/2022/01/e89dcf68.html"/>
      <url>/posts/2022/01/e89dcf68.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>初步使用了Hexo后，你是否对Hexo的默认主题不满意呢？本篇文章将教你如何安装及美化hexo主题。<br>如果你还没安装和使用Hexo，请参考<a href="https://www.yeluohuakai.com/posts/2022/01/71127ac7.html">Hexo博客搭建指南</a>。</p><p>通过查看Hexo安装目录的_config.yml配置文件，我们可以了解到Hexo的默认主题是landscape。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: landscape</span><br></pre></td></tr></table></figure><p>更多的主题可以去 <a href="https://hexo.io/themes/">https://hexo.io/themes/</a>了解，诸位可以根据自己的喜好选择合适的主题，这里我推荐几个。</p><span id="more"></span> <h3 id="Hexo主题推荐"><a href="#Hexo主题推荐" class="headerlink" title="Hexo主题推荐"></a>Hexo主题推荐</h3><h4 id="Hexo-NexT"><a href="#Hexo-NexT" class="headerlink" title="Hexo NexT"></a>Hexo NexT</h4><p><a href="https://github.com/next-theme/hexo-theme-next">hexo-theme-next</a>是目前最广泛使用的Hexo主题了，优点是简洁，定制度高，因为代码是开源的，所以有很多开发者维护。由于前任管理员不提供权限，故开发了一个新的分支，详情。最新版本为8.0也是我在使用的版本，8.0及前版本请使用github搜索功能。</p><h4 id="Hexo-Butterfly"><a href="#Hexo-Butterfly" class="headerlink" title="Hexo Butterfly"></a>Hexo Butterfly</h4><p><a href="https://github.com/jerryc127/hexo-theme-butterfly">hexo-theme-butterfly</a> 动态效果比较丰富，用了很多圆角元素。原生支持的插件很多，比如说绝大部分评论系统、给搜索引擎提交网站和站点地图、页面动效、页内搜索等。</p><p>我个人用的是 <code>Butterfly</code> ，支持功能够多，能节省很多自定义配置，我个人比较喜欢。</p><h3 id="安装Butterfly主题插件"><a href="#安装Butterfly主题插件" class="headerlink" title="安装Butterfly主题插件"></a>安装Butterfly主题插件</h3><ul><li><p>安装Butterfly之前记得先安装pug和stylus依赖：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus</span><br></pre></td></tr></table></figure></li><li><p>在Hexo博客根目录通过git指令下载Butterfly最新的主题文件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone --depth 1 https://github.com/jerryc127/hexo-theme-butterfly themes/butterfly</span><br></pre></td></tr></table></figure></li></ul><p>或者，直接从<a href="https://github.com/jerryc127/hexo-theme-butterfly">hexo-theme-butterfly</a>页面下载<a href="https://github.com/jerryc127/hexo-theme-butterfly/archive/refs/heads/dev.zip">源代码</a> ，解压到博客目录/themes目录下。<br>最终目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├─_config.yml</span><br><span class="line">├─public</span><br><span class="line">├─scaffolds</span><br><span class="line">├─source</span><br><span class="line">└─themes</span><br><span class="line">    ├─butterfly</span><br><span class="line">       ├─lanuage</span><br><span class="line">         ├─source</span><br><span class="line">         ├─layout</span><br><span class="line">         ├─_config.yml</span><br></pre></td></tr></table></figure><ul><li>修改Hexo安装目录的_config.yml配置文件，将主题修改为butterfly:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure></li><li>最后，执行<code>hexo g &amp; hexo s</code>看看Butterfly主题风格的博客吧。</li></ul><h3 id="尝试其他主题"><a href="#尝试其他主题" class="headerlink" title="尝试其他主题"></a>尝试其他主题</h3><p>安装NexT主题：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone --depth 1 https://github.com/next-theme/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>安装Light主题：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone --depth 1 https://github.com/hexojs/hexo-theme-light themes/light</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web技术 </category>
          
          <category> Hexo搭建博客教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Hexo教程-从零开始搭建个人博客】3、Hexo安装和使用</title>
      <link href="/posts/2022/01/ac4a4b5a.html"/>
      <url>/posts/2022/01/ac4a4b5a.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、安装Hexo"><a href="#1、安装Hexo" class="headerlink" title="1、安装Hexo"></a>1、安装Hexo</h3><p>Hexo就是我们的个人博客网站的框架， 这里需要自己在电脑常里创建一个文件夹，可以命名为MyBlog，Hexo框架与以后你自己发布的网页都在这个文件夹中。</p><p>这里以在D:/Code/MyBlog目录下安装Hexo为例,首先在命令行中进入目录：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d: &amp; cd D:/Code/MyBlog</span><br></pre></td></tr></table></figure><p>使用npm命令安装Hexo，输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli </span><br></pre></td></tr></table></figure><span id="more"></span> <p>安装完成后，初始化我们的博客，输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init </span><br></pre></td></tr></table></figure><p>初始化完成后，目录结构如下：<br><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-10.png" alt>  </p><p>_config.yml<br>用来配置博客相关的参数，初始化时自动创建。具体参数设置，可参照 <a href="https://hexo.io/zh-cn/docs/configuration">Hexo配置</a> 文档。</p><h3 id="2、启动Hexo"><a href="#2、启动Hexo" class="headerlink" title="2、启动Hexo"></a>2、启动Hexo</h3><p>输入<code>hexo s</code>启动Hexo服务：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-11.png" alt><p>根据启动提示，在浏览器中输入 <a href="http://localhost:4000/">http://localhost:4000</a> 即可访问博客。</p><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-12.png" alt><p>hexo命令详解：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建一篇文章</span><br><span class="line">hexo g == hexo generate #生成html</span><br><span class="line">hexo s == hexo server #启动服务预览</span><br><span class="line">hexo d == hexo deploy #部署</span><br><span class="line"></span><br><span class="line">hexo server -s #静态模式</span><br><span class="line">hexo server -p 5000 #更改端口</span><br><span class="line">hexo server -i 192.168.1.1 #自定义 IP,一般用不到</span><br><span class="line">hexo clean #清除缓存，若是网页正常情况下可以忽略这条命令</span><br></pre></td></tr></table></figure><h3 id="3、编辑并发布第一篇文章"><a href="#3、编辑并发布第一篇文章" class="headerlink" title="3、编辑并发布第一篇文章"></a>3、编辑并发布第一篇文章</h3><p>根据上文，新建博客命令为 <code>hexo n</code>, 新建一篇名为 HelloWorld！的博客：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n &quot;HelloWorld!&quot;</span><br></pre></td></tr></table></figure><p>命令行中会提示:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\Code\MyBlog&gt;hexo n &quot;HelloWorld!&quot;</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Created: D:\Code\MyBlog\source\_posts\HelloWorld.md</span><br></pre></td></tr></table></figure><p>我们会看到Hexo会在 \source_posts\ 目录下新建一个HelloWorld.md 文件，md文件也就是 Markdown 文件,它会被编译成 html 文件，放到 public 文件夹下。</p><p>md同样也支持中文命名，文件名也就是博客的标题，如下：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\Code\MyBlog&gt;hexo n &quot;第一篇博客&quot;</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Created: D:\Code\MyBlog\source\_posts\第一篇博客.md</span><br></pre></td></tr></table></figure><p>编辑完博客后，即可执行<code>hexo g</code>命令生成html文件</p><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-13.png" alt>然后再启动Hexo服务即可。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>再次在浏览器中访问博客页面，新建的博客已经出现在首页博客列表中。  <img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-14.png" alt><p>至此，Hexo的安装和初步使用已完成。</p>]]></content>
      
      
      <categories>
          
          <category> Web技术 </category>
          
          <category> Hexo搭建博客教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Hexo教程-从零开始搭建个人博客】2、Hexo配置基础环境</title>
      <link href="/posts/2022/01/10e17c07.html"/>
      <url>/posts/2022/01/10e17c07.html</url>
      
        <content type="html"><![CDATA[<p>Hexo配置基础环境包括：GitHub Pages、Git、Node。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>1、注册GitHub账号</p><p>2、安装Node</p><p>3、安装Git</p><h3 id="注册GitHub账号和新建仓库"><a href="#注册GitHub账号和新建仓库" class="headerlink" title="注册GitHub账号和新建仓库"></a>注册GitHub账号和新建仓库</h3><ul><li>登录到<a href="https://github.com/">GitHub</a>,如果没有GitHub帐号，使用你的邮箱注册GitHub帐号<span id="more"></span> </li><li>点击GitHub中的New repository创建新仓库，仓库名应该为：你的用户名.github.io 这个用户名使用你的GitHub帐号名称代替，这是固定写法。将来你的网站访问地址就是 你的用户名.github.io，弊端就是，我们只能创建一个这样的仓库。</li><li>如果需要搭建多个博客，就需要注册多个GitHub账号。</li></ul><h3 id="安装Node"><a href="#安装Node" class="headerlink" title="安装Node"></a>安装Node</h3><p>Hexo基于Node.js，Node.js下载地址：<a href="https://nodejs.org/zh-cn/download/">Download | Node.js</a> 下载安装包，注意安装Node.js会包含环境变量及npm的安装，安装后，</p><p>检测Node.js是否安装成功，在命令行中输入 node -v 。<br>检测npm是否安装成功，在命令行中输入npm -v 。</p><p>补充：国内环境下把包的远程服务器设置为淘宝镜像，以加快下载速度。</p><p>使用命令行运行:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set registry=https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure><p>执行完毕后通过<code>npm config get registry</code>命令查看npm源:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\Code\MyBlog&gt;npm config get registry</span><br><span class="line">https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>什么是Git ?简单来说Git是开源的分布式版本控制系统，用于敏捷高效地处理项目。我们网站在本地搭建好了，需要使用Git同步到GitHub上。<br>从Git官网下载：<a href="https://git-scm.com/download/win">Git - Downloading</a>， 现在的电脑基本都是64位的，选择64位的安装包即可。下载后安装，在命令行里输入git测试是否安装成功，若安装失败，参看其他详细的Git安装教程。  </p><p>安装成功后，将你的Git与GitHub帐号绑定  。<br>打开命令行，设置user.name和user.email配置信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;你的GitHub用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的GitHub注册邮箱&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生成ssh密钥文件：<br>命令行任意位置键入如下命令  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱地址&quot;</span><br></pre></td></tr></table></figure><p>然后直接三个回车即可，默认不需要设置密码。<br>然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，用编辑器打开将内容全部复制。</p><p>注意：windows环境下id_rsa.pub是在<code>cd C:\Users\你的用户名\.ssh</code>目录下。</p><p>打开<a href="https://github.com/settings/keys">GitHub Settings keys</a> 页面，点击“new SSH Key”来新建新的SSH Key：</p><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-9.png" alt><p>Title为标题任意填即可，将刚刚复制的id_rsa.pub内容粘贴到Key中，最后点击“Add SSH key”完成添加。  </p><p>检测GitHub公钥设置是否成功，在命令行中输入 <code>ssh git@github.com </code>，出现<code>You&#39;ve successfully authenticated</code>等字样即代表公钥设置成功。</p><p>至此，安装Hexo的基础环境已经全部搭建完成。  </p><h3 id="完整Hexo博客搭建流程请参考：Hexo博客搭建指南"><a href="#完整Hexo博客搭建流程请参考：Hexo博客搭建指南" class="headerlink" title="完整Hexo博客搭建流程请参考：Hexo博客搭建指南"></a>完整Hexo博客搭建流程请参考：<a href="/posts/2022/01/71127ac7.html">Hexo博客搭建指南</a></h3>]]></content>
      
      
      <categories>
          
          <category> Web技术 </category>
          
          <category> Hexo搭建博客教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Node </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Hexo教程-从零开始搭建个人博客】1、Hexo博客搭建指南</title>
      <link href="/posts/2022/01/71127ac7.html"/>
      <url>/posts/2022/01/71127ac7.html</url>
      
        <content type="html"><![CDATA[<p>怎么搭建一个免费的个人博客，个人采用了Hexo博客框架，下面是我搭建Hexo个人博客的经验总结。 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">至于为什么选择Hexo，因为Hexo主题多，漂亮主题更是不少，Huge在这点上差太多了。</span><br><span class="line"></span><br><span class="line">而使用Wordpress搞个人博客，就必须要有虚拟主机或者云服务器才可以。国内的虚拟主机或云服务器，新用户活动价便宜，但是续费的话会非常贵。而利用GitHub pages服务搭建Hexo博客是免费的。</span><br><span class="line"></span><br><span class="line">所以虽然Hexo生成html的速度慢了点，但是依然是我认为的最佳选择。</span><br></pre></td></tr></table></figure><h3 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。Hexo拥有丰富的插件系统，常与GitHub等代码托管平台一起构建个人博客网站。</p><p>Hexo可以让你快速拥有自己的博客网站，写文章记录生活，享受这种从0到1的过程。</p><p>下面正式从零开始搭建年轻人的第一个免费个人博客。</p><h3 id="Hexo博客搭建指南"><a href="#Hexo博客搭建指南" class="headerlink" title="Hexo博客搭建指南"></a>Hexo博客搭建指南</h3><ul><li><a href="/posts/2022/01/10e17c07.html">Hexo配置基础环境(GitHub Pages、Git、Node)</a></li><li><a href="/posts/2022/01/ac4a4b5a.html">Hexo安装和使用</a></li><li><a href="/posts/2022/01/e89dcf68.html">Hexo使用主题</a></li><li><a href="/posts/2022/01/face4142.html">Hexo部署到GitHub</a></li><li>Hexo绑定个人域名<span id="more"></span> </li><li>Hexo怎么写文章(hexo-amdin插件)</li><li>Hexo设置首页文章只显示部分摘要</li><li>Hexo生成永久文章链接</li><li>Hexo设置文章分享</li><li>Hexo设置分页</li><li>Hexo给文章添加版权声明</li><li>Hexo初级SEO优化（增加description和keywords）</li><li>Hexo增加分类页和标签云</li><li>Hexo增加百度统计和Google统计</li><li>Hexo搜索引擎收录（百度、Google、头条、Bing等）</li><li>Hexo图片上传到图床（七牛云）</li><li>Hexo增加评论模块（remark42）</li><li>Hexo页面美化</li><li>Hexo增加站内静态搜索</li><li>Hexo增加RSS订阅</li><li>Hexo加入Google广告联盟</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web技术 </category>
          
          <category> Hexo搭建博客教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>https网站如何访问http资源？</title>
      <link href="/posts/2022/01/b60222b0.html"/>
      <url>/posts/2022/01/b60222b0.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在Chrome中，如果网站开启了https，http资源是无法加载了。</p><p>如，我的博客是hexo+githubpages，开启了https，我的七牛云图床的图片资源是http的，这样我的网站就无法加载七牛云的资源了。  </p><p><em>ps:七牛云的资源开启https访问是收费的，无法享受每个月10G的免费空间，所以此处不考虑https直接访问七牛云。也不考虑拥有云主机的情况下使用nginx进行反向代理。</em></p><h3 id="解决办法-使用cloudflare"><a href="#解决办法-使用cloudflare" class="headerlink" title="解决办法 - 使用cloudflare"></a>解决办法 - 使用cloudflare</h3><span id="more"></span><p>如图所示：</p><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/hexo5.png" alt="title:hexo5 alt:hexo5  ">  <p>cloudflare注册和添加域名的过程此处不详述，直接参考：<br><a href="https://www.cnblogs.com/bonelee/p/8670660.html">使用cloudflare加速你的网站隐藏你的网站IP</a></p><p>在添加域名、修改域名服务器完成后，点击你的域名，点击 <strong>SSL/TLS</strong>–<strong>概述</strong> 菜单，<br>修改SSL/TLS 加密模式为 <strong>灵活</strong> 。<br>稍等几分钟后，你的https网站就能访问http的资源了（在你的网站里http资源的地址都是https开头的）。</p><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/hexo6.png" alt="title:hexo6 alt:hexo6  ">]]></content>
      
      
      <categories>
          
          <category> Web技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 七牛云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo设置同步图片到七牛云碰到怪异问题</title>
      <link href="/posts/2022/01/19da73ba.html"/>
      <url>/posts/2022/01/19da73ba.html</url>
      
        <content type="html"><![CDATA[<p>Hexo设置同步图片到七牛云碰到的一个问题，如下： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error:ENOENT: no such file or directory, mkdir &#x27;static\images&#x27;</span><br></pre></td></tr></table></figure><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/hexo3.png" alt="title:hexo3 alt:hexo3  ">  <span id="more"></span>百度bingGoogle搜索无果...... <p>检查cmd.js的代码<br><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/hexo4.png" alt="title:hexo4 alt:hexo4  ">  </p><p>发现问题可能是fs.mkdirSync只能一层层创建目录，于是手动创建了static目录，这个问题居然就好了。 </p><p>感到很无语，特意记录一下。</p>]]></content>
      
      
      <categories>
          
          <category> Web技术 </category>
          
          <category> Hexo搭建博客教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 七牛云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo中文网页名转换为固定字符串</title>
      <link href="/posts/2022/01/e334963d.html"/>
      <url>/posts/2022/01/e334963d.html</url>
      
        <content type="html"><![CDATA[<p>hexo默认生成的页面链接是文章的标题，如果标题是中文那么网站访问的路径也是中文，这样是不利于搜索引擎的收录，可以使用插件来解决这个问题。</p><p><em><strong>方法一</strong></em></p><p>安装缩短链接插件<br><code>npm install hexo-abbrlink --save</code></p><p>hexo的_config.yml 添加如下配置：</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">permalink: posts/:abbrlink.html</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  # 算法：crc16(default) and crc32</span><br><span class="line">  rep: hex    # 进制：dec(default) and hex</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br></pre></td></tr></table></figure><p>安装完毕后此时再clean hexo g 会发现生成的网页名称不再是中文，而是固定的字符串，访问路径也统一变成了posts/xxx.html，这种简单的访问路径比较利于搜索引擎收录。</p><p>注：这个插件生成的链接是一串数字+字母的字符串，如果需要更高大上的英文链接，请参考<em><strong>方法二</strong></em>。</p><p><em><strong>方法二</strong></em>  </p><ol><li>安装</li></ol><p><code>npm install hexo-translate-title --save</code></p><ol start="2"><li>配置<br>修改hexo根项目下的_config.yml，建议用google翻译毕竟贴地气，但实测并不稳定，所以也可以用baidu_no_appid，这样也不需要额外的认证配置。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">translate_title:</span><br><span class="line">  translate_way: google  # google,youdao,baidu_with_appid,baidu_no_appid</span><br><span class="line">  is_need_proxy: false     # true | false</span><br><span class="line">  # proxy_url: http://localhost:50018 # Your proxy_url</span><br><span class="line">  # youdao_api_key: &#x27;&#x27; # Your youdao_api_key</span><br><span class="line">  # youdao_keyfrom: xxxx-blog # Your youdao_keyfrom</span><br><span class="line">  # baidu_appid: &#x27;&#x27; # Your baidu_appid</span><br><span class="line">  # baidu_appkey: &#x27;&#x27; # Your baidu_appkey</span><br><span class="line"># 修改原链接格式：permalink: :year/:month/:day/:title/</span><br><span class="line">permalink: :year:month:day/:translate_title.html</span><br></pre></td></tr></table></figure><ol start="3"><li><p>测试<br>用hexo d重新生成，留意控制台输出以及public目录下是否有生成相应的<hexo-translate-title>.html文件，如果有代表成功了，再用hexo d部署即可。  </hexo-translate-title></p></li><li><p>注意<br>  Google翻译服务的不稳定，按上述流程安装、配置和部署，有可能生成的链接都是undefined.html。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Web技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> seo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos6 可用yum源</title>
      <link href="/posts/2022/01/31475.html"/>
      <url>/posts/2022/01/31475.html</url>
      
        <content type="html"><![CDATA[<p><em><strong>小tips：</strong></em></p><p><em><strong>测试yum源能否使用，就看源的url能否在浏览器中访问。</strong></em></p><p>目前可用的几个yum源：</p><p>清华大学：<a href="https://mirrors4.tuna.tsinghua.edu.cn/centos-vault/">https://mirrors4.tuna.tsinghua.edu.cn/centos-vault/</a><br>（去链接里查找需要的源，清华各个版本的源挺全的）</p><p>搜狐源：<a href="http://mirrors.sohu.com/centos/6.10/os/x86_64/">http://mirrors.sohu.com/centos/6.10/os/x86_64/</a>   (已失效)</p><p><a href="http://file.kangle.odata.cc/repo/Centos-6.repo">http://file.kangle.odata.cc/repo/Centos-6.repo</a></p><p><a href="http://file.kangle.odata.cc/repo/epel-6.repo">http://file.kangle.odata.cc/repo/epel-6.repo</a></p><span id="more"></span><h3 id="方法一：设置yum搜狐源"><a href="#方法一：设置yum搜狐源" class="headerlink" title="方法一：设置yum搜狐源"></a>方法一：设置yum搜狐源</h3><p>1、先备份源文件：</p><p><code>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo-backup</code></p><p>2、编辑文件：vi /etc/yum.repos.d/CentOS-Base.repo</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/yum.repos.d/CentOS-Base.repo`</span><br><span class="line"></span><br><span class="line">`[base]</span><br><span class="line">name=CentOS-6</span><br><span class="line">failovermethod=priority</span><br><span class="line">#搜狐源</span><br><span class="line">baseurl=http://mirrors.sohu.com/centos/6.10/os/x86_64/</span><br><span class="line">gpgcheck=0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>如果baseurl已失效，换成其他可访问的yum源地址即可。</strong></p><p>3、清理软件源</p><p><code>yum clean all</code></p><p>4、建立源数据缓存</p><p><code>yum makecache</code></p><h3 id="方法二：设置其他源"><a href="#方法二：设置其他源" class="headerlink" title="方法二：设置其他源"></a>方法二：设置其他源</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//直接在ssh框中输入</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://file.kangle.odata.cc/repo/Centos-6.repo</span><br><span class="line">wget -O /etc/yum.repos.d/epel.repo http://file.kangle.odata.cc/repo/epel-6.repo</span><br><span class="line">yum makecache</span><br><span class="line">//即可</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> IT技术 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> yum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员的酒后真言</title>
      <link href="/posts/2021/06/cb37c737.html"/>
      <url>/posts/2021/06/cb37c737.html</url>
      
        <content type="html"><![CDATA[<p>美国最大的论坛 Reddit，最近有一个热帖[1]。</p><p>一个程序员说自己喝醉了，软件工程师已经当了10年，心里有好多话想说，“我可能会后悔今天说了这些话。”</p><p>他洋洋洒洒写了一大堆，获得9700多个赞。内容很有意思，值得一读，下面是节选。</p><p>（1）职业发展的最好方法是换公司。</p><p>（2）技术栈不重要。技术领域有大约 10-20 条核心原则，重要的是这些原则，技术栈只是落实它们的方法。你如果不熟悉某个技术栈，不需要过度担心。</p><span id="more"></span> <p>（3）工作和人际关系是两回事。有一些公司，我交到了好朋友，但是工作得并不开心；另一些公司，我没有与任何同事建立友谊，但是工作得很开心。</p><p>（4）我总是对经理实话实说。怕什么？他开除我？我会在两周内找到一份新工作。</p><p>（5）如果一家公司的工程师超过 100 人，它的期权可能在未来十年内变得很有价值。对于工程师人数很少的公司，期权一般都是毫无价值。</p><p>（6）好的代码是初级工程师可以理解的代码。伟大的代码可以被第一年的 CS 专业的新生理解。</p><p>（7）作为一名工程师，最被低估的技能是记录。说真的，如果有人可以教我怎么写文档，我会付钱，也许是 1000 美元。</p><p>（8）网上的口水战，几乎都无关紧要，别去参与。</p><p>（9）如果我发现自己是公司里面最厉害的工程师，那就该离开了。</p><p>（10）我们应该雇佣更多的实习生，他们很棒。那些精力充沛的小家伙用他们的想法乱搞。如果他们公开质疑或批评某事，那就更好了。我喜欢实习生。</p><p>（11）技术栈很重要。如果你使用 Python 或 C++ 语言，就会忍不住想做一些非常不同的事情。因为某些工具确实擅长某些工作。</p><p>（12）如果你不确定自己想做什么东西，请使用 Java。这是一种糟糕的编程语言，但几乎无所不能。</p><p>（13）对于初学者来说，最赚钱的编程语言是 SQL，干翻所有其他语言。你只了解 SQL 而不会做其他事情，照样赚钱。人力资源专家的年薪？也许5万美元。懂 SQL 的人力资源专家？9万美元。</p><p>（14）测试很重要，但 TDD （测试驱动的开发）几乎变成了一个邪教。</p><p>（15） 政府单位很轻松，但并不像人们说的那样好。对于职业生涯早期到中期的工程师，12 万美元的年薪 + 各种福利 + 养老金听起来不错，但是你将被禁锢在深奥的专用工具里面，离开政府单位以后，这些知识就没用了。我非常尊重政府工作人员，但说真的，这些地方的工程师，年龄中位数在 50 岁以上是有原因的。</p><p>（16）再倒一杯酒。</p><p>（17）大多数头衔都无关紧要，随便什么公司都可以有首席工程师。</p><p>（18）手腕和背部的健康问题可不是开玩笑的，好的设备值得花钱。</p><p>（19）当一个软件工程师，最好的事情是什么？你可以结识很多想法相同的人，大家互相交流，不一定有相同的兴趣，但是对方会用跟你相同的方式思考问题，这很酷。</p><p>（20）有些技术太流行，我不得不用它。我心里就会很讨厌这种技术，但会把它推荐给客户，比如我恨 Jenkins，但把它推荐给新客户，我不觉得做错了。</p><p>（21）成为一名优秀的工程师意味着了解最佳实践，成为高级工程师意味着知道何时打破最佳实践。</p><p>（22）发生事故时，如果周围的人试图将责任归咎于外部错误或底层服务中断，那么是时候离开这家公司，继续前进了。</p><p>（23）我遇到的最好的领导，同意我的一部分观点，同时耐心跟我解释，为什么不同意我的另一部分观点。我正在努力成为像他们一样的人。</p><p>（24）算法和数据结构确实重要，但不应该无限夸大，尤其是面试的时候。我没见过药剂师面试时，还要测试有机化学的细节。这个行业的面试过程有时候很糟糕。</p><p>（25）做自己喜欢的事情并不重要，不要让我做讨厌的事情更重要。</p><p>（26）越接近产品，就越接近推动收入增长。无论工作的技术性如何，只要它接近产品，我都感到越有价值。</p><p>（27）即使我平时用 Windows 工作，Linux 也很重要。为什么？因为服务器是 Linux 系统，你最终在 Linux 系统上工作。</p><p>（28）人死了以后，你想让代码成为你的遗产吗？如果是那样，就花很多时间在代码上面吧，因为那是你的遗产。但是，如果你像我一样，更看重与家人、朋友和生活中其他人相处的时光，而不是写的代码，那就别对它太在意。</p><p>（29）我挣的钱还不错，对此心存感激，但还是需要省钱。</p><p>（30）糟糕，我没酒了。</p><p>（完）</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p><code>[1]</code> 热帖: <em><a href="https://old.reddit.com/r/ExperiencedDevs/comments/nmodyl/drunk/_post/_things/_ive/_learned/_as/_a/_sr/_engineer/">https://old.reddit.com/r/ExperiencedDevs/comments/nmodyl/drunk\_post\_things\_ive\_learned\_as\_a\_sr\_engineer/</a></em></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SM2密钥加密数据，对明文数据长度有什么要求？最大可以加密多少字节明文数据？</title>
      <link href="/posts/2021/05/3fd2352e.html"/>
      <url>/posts/2021/05/3fd2352e.html</url>
      
        <content type="html"><![CDATA[<p>sm2的密文是根据一定规则派生，然后与明文异或 。所以对明文长度没有要求，多长都可以，但是尽量别用SM2加解密长数据，SM2 只是用来 签名，验签， 以及对称密钥的协商，要加解密长数据，肯定还是sm4 对称加解密 更合适。</p>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 加解密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux带参数的脚本示例（包含进程状态判断）</title>
      <link href="/posts/2021/05/95b43a10.html"/>
      <url>/posts/2021/05/95b43a10.html</url>
      
        <content type="html"><![CDATA[<p>Linux带参数的脚本示例（包含进程状态判断）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;start&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;start&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;stop&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;stop&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;status&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="keyword">while</span> [ 1 ]</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;`ps -ef | grep ping | grep -v grep`&quot;</span> != <span class="string">&quot;&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;running&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> stop</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">        <span class="built_in">sleep</span> 1s</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;error&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> IT技术 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在Beanshell里使用source命令加载java源文件的报错：Method Invocation this.interpreter.source</title>
      <link href="/posts/2021/04/eab7b127.html"/>
      <url>/posts/2021/04/eab7b127.html</url>
      
        <content type="html"><![CDATA[<p>用Jmeter在Beanshell里使用source命令加载java源文件的报错：Method Invocation this.interpreter.source</p><p>具体报错如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanShellSampler: Exception executing script. org.apache.jorphan.util.JMeterException: Error invoking bsh method: eval    </span><br><span class="line">Sourced file: inline evaluation of: <span class="string">&quot;. . . &#x27;&#x27; : Method Invocation this.interpreter.source</span></span><br></pre></td></tr></table></figure><p><strong>原因大概是引用的java源文件里有interface的定义，去掉interface的定义则不会报这个错。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Jmeter </tag>
            
            <tag> 压力测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jmeter:通过JAVA代码创建仅一次控制器(OnceOnlyController)和预处理器(BeanShellPreProcessor )</title>
      <link href="/posts/2021/04/a4034006.html"/>
      <url>/posts/2021/04/a4034006.html</url>
      
        <content type="html"><![CDATA[<p>Jmeter:通过JAVA代码创建仅一次控制器(OnceOnlyController)</p><p>最近在研究通过JAVA动态创建Jmeter脚本，对于创建OnceOnlyController ，实在没找到相关资料，就自己研究了下，不是很难，代码如下：</p><span id="more"></span> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建OnceOnlyController  仅一次控制器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadGroupHashTree</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> taskId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createOnceOnlyController</span><span class="params">(HashTree threadGroupHashTree ,String taskId)</span> &#123;</span><br><span class="line">    OnceOnlyController onceOnlyController=<span class="keyword">new</span> <span class="title class_">OnceOnlyController</span>();</span><br><span class="line">    onceOnlyController.setProperty(<span class="string">&quot;testname&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    onceOnlyController.setProperty(<span class="string">&quot;enable&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">HashTree</span> <span class="variable">testPlanTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashTree</span>();</span><br><span class="line">    testPlanTree.add(createBeanShellPreProcessor(taskId));</span><br><span class="line">    </span><br><span class="line">    <span class="type">BeanShellSampler</span> <span class="variable">beanShellSampler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanShellSampler</span>();</span><br><span class="line">beanShellSampler.setName(<span class="string">&quot;test&quot;</span> + taskId);</span><br><span class="line">beanShellSampler.setProperty(<span class="string">&quot;BeanShellSampler.query&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">testPlanTree.add(beanShellSampler);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将BeanShellPreProcessor和BeanShellSampler 添加到OnceOnlyController下</span></span><br><span class="line">threadGroupHashTree.add(onceOnlyController,testPlanTree);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建BeanShell 预处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BeanShellPreProcessor <span class="title function_">createBeanShellPreProcessor</span><span class="params">(String taskId)</span> &#123;</span><br><span class="line">    BeanShellPreProcessor preProcessor=<span class="keyword">new</span> <span class="title class_">BeanShellPreProcessor</span>();</span><br><span class="line">    preProcessor.setEnabled(<span class="literal">true</span>);</span><br><span class="line">    preProcessor.setProperty(<span class="string">&quot;resetInterpreter&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    String script=<span class="string">&quot;System.out.println(\&quot;预处理num:\&quot;+ctx.getThreadNum());&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    preProcessor.setProperty(<span class="string">&quot;script&quot;</span>, script);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    preProcessor.setProperty(TestElement.ENABLED, <span class="literal">true</span>);</span><br><span class="line">    preProcessor.setProperty(TestElement.NAME,<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    preProcessor.setProperty(TestElement.TEST_CLASS, preProcessor.getClass().getName());</span><br><span class="line">    preProcessor.setProperty(TestElement.GUI_CLASS, TestBeanGUI.class.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;createBeanShellPreProcessor:&quot;</span>+preProcessor.getPropertyAsString(<span class="string">&quot;script&quot;</span>));</span><br><span class="line"><span class="keyword">return</span> preProcessor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>欢迎留言交流。</p>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Jmeter </tag>
            
            <tag> 压力测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用JNA时碰到的坑：Can&#39;t obtain InputStream for linux-x86-64/libXXX.so</title>
      <link href="/posts/2021/04/3feb991d.html"/>
      <url>/posts/2021/04/3feb991d.html</url>
      
        <content type="html"><![CDATA[<p>比如使用JNA时需要动态加载 libsgd.so，使用Native.load(“sgd”,FmSGDLibrary.class) 时总是会报   Can’t obtain InputStream for linux-x86-64/libsgd.so 的错误，虽然通过设置环境变量可以解决问题  ：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#/tmp/lib/ 是so文件所在路径，自由调整</span><br><span class="line">export LD_LIBRARY_PATH=/tmp/lib/:$LD_LIBRARY_PATH  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是这个方式也太不灵活了，能不能只通过java代码就能动态加载动态链接库呢？</p><p>答案是有的，通过Native.loadlibrary使用绝对路径加载就行了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Native.loadLibrary(<span class="string">&quot;/tmp/lib/libsgd.so&quot;</span>, FmSGDLibrary.class);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JNA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端技能图谱</title>
      <link href="/posts/2021/01/cd84893a.html"/>
      <url>/posts/2021/01/cd84893a.html</url>
      
        <content type="html"><![CDATA[<p>前端技能图谱<br>如图：</p><span id="more"></span> <p><img src="https://oscimg.oschina.net/oscnet/up-fc97cfb9d77627bcea428a6678f42feabe6.png"></p>]]></content>
      
      
      <categories>
          
          <category> Web技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维导图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试技能图谱</title>
      <link href="/posts/2021/01/a87b39e5.html"/>
      <url>/posts/2021/01/a87b39e5.html</url>
      
        <content type="html"><![CDATA[<p>测试技能图谱<br>如图：</p><span id="more"></span> <p><img src="https://oscimg.oschina.net/oscnet/up-0bbddd6c2c418d544c227d4533fcba2a3fb.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 思维导图 </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA技能图谱</title>
      <link href="/posts/2021/01/d11f2b88.html"/>
      <url>/posts/2021/01/d11f2b88.html</url>
      
        <content type="html"><![CDATA[<p>JAVA技能图谱<br>如图：</p><span id="more"></span> <p><img src="https://oscimg.oschina.net/oscnet/up-14ab35097f73549b221301ed9efab49f492.png"></p>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 思维导图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA项目性能分析工具JConsole的使用</title>
      <link href="/posts/2020/11/f64db4d9.html"/>
      <url>/posts/2020/11/f64db4d9.html</url>
      
        <content type="html"><![CDATA[<p>项目启动参数增加以下选项即可：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Djava.rmi.server.hostname=192.168.0.129 (服务所在IP)</span><br><span class="line"></span><br><span class="line">-Dcom.sun.management.jmxremote</span><br><span class="line"></span><br><span class="line">-Dcom.sun.management.jmxremote.port=9192 (JConsole要连接的端口，不能与项目一样)</span><br><span class="line"></span><br><span class="line">-Dcom.sun.management.jmxremote.rmi.port=9193 (rmi方式连接，不能与项目一样)</span><br><span class="line"></span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=false</span><br><span class="line"></span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=false</span><br></pre></td></tr></table></figure><span id="more"></span> <p>以某项目（192.168.0.129,jar文件）为例，启动命令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup java -jar -Djava.rmi.server.hostname=192.168.0.129 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=9192 -Dcom.sun.management.jmxremote.rmi.port=9193 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false test-1.0.0.jar &amp;</span><br></pre></td></tr></table></figure><p>然后启动%JAVA_HOME%/bin/jconsole.exe,输入进程ip和端口，点击连接即可。</p><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-8.png" alt><p>进程实际情况如下,使用情况：</p><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-0.png" alt><p>通过观察发现一次次的堆内存使用量有较大幅度的变化，多次进行GC。</p><p>进一步分析堆内存情况。</p><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-1.png" alt><p>每次经过GC之后老年区一直都在提升，说明对象在进行GC后被移动到老年区了。</p><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-2.png" alt><p>Eden新生区，对象随着时间的变化生成的速度越来越快，GC不断进行回收操作，系统频繁调用GC。</p><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-3.png" alt><p>存活期对象，在不断的进行GC操作之后，将被不断的从eden区copy到survive区，通过经过不多gc回收标记，在14：57时被批量移动到old区，所以空间在不断下降。</p><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-4.png" alt><p>而非堆区数据一致保持较平稳状况，所以内存较为平稳。</p><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-5.png" alt><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-6.png" alt><p> 通过分析发现，堆区对象在不断生成，并且不断增加，即使在进行回收的时候也无法回收掉，可以理解为，此处有与不断产生 斐波那契 序列并存储出现的问题，由于后续的数据非常大，所以非必须应该放弃缓存，或在获得结果后进行转存，如数据库等。</p><p>另外，我们可以查看线程情况，通过下图可以查看main方法中的Thread.sleep();方法话费了2638，可以在程序中去掉。</p><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/pasted-7.png" alt>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 性能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java计算中位数、方差、标准差、众数</title>
      <link href="/posts/2019/09/1d8dae74.html"/>
      <url>/posts/2019/09/1d8dae74.html</url>
      
        <content type="html"><![CDATA[<p>Java计算中位数、方差、标准差、众数</p><p>代码如下：<br> <span id="more"></span></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数学算法（数学算法（方差、标准差、中位数、众数））</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathAlgorithm</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">double</span> <span class="variable">dmax</span> <span class="operator">=</span> <span class="number">999</span>;<span class="comment">// Double.MAX_VALUE;//Double类型的最大值，太大的double值，相乘会达到无穷大</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">double</span> <span class="variable">dmin</span> <span class="operator">=</span> Double.MIN_VALUE;<span class="comment">// Double类型的最小值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">// 假设求取100个doubl数的方差和标准差</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">double</span>[] x = <span class="keyword">new</span> <span class="title class_">double</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">// 随机生成n个double数</span></span><br><span class="line">x[i] = Double.valueOf(Math.floor(random.nextDouble() * (dmax - dmin)));</span><br><span class="line">System.out.println(x[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置doubl字符串输出格式，不以科学计数法输出</span></span><br><span class="line"><span class="type">DecimalFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#,##0.00&quot;</span>);<span class="comment">// 格式化设置</span></span><br><span class="line"><span class="comment">// 计算方差</span></span><br><span class="line"><span class="type">double</span> <span class="variable">dV</span> <span class="operator">=</span> getVariance(x);</span><br><span class="line">System.out.println(<span class="string">&quot;方差=&quot;</span> + df.format(dV));</span><br><span class="line"><span class="comment">// 计算标准差</span></span><br><span class="line"><span class="type">double</span> <span class="variable">dS</span> <span class="operator">=</span> getStandardDiviation(x);</span><br><span class="line">System.out.println(<span class="string">&quot;标准差=&quot;</span> + df.format(dS));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] intArr=&#123;<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">8</span>,<span class="number">6</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(intArr)+<span class="string">&quot; 中位数:&quot;</span>+median(intArr));</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] intArr2=&#123;<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(intArr2)+<span class="string">&quot; 中位数:&quot;</span>+median(intArr2));</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; modalNums = getModalNums(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;众数：&quot;</span>+modalNums);</span><br><span class="line">        </span><br><span class="line">        <span class="type">float</span>[] arr2 = &#123;<span class="number">0.1f</span>, <span class="number">1.1f</span>, <span class="number">2.1f</span>, <span class="number">3.1f</span>, <span class="number">4.1f</span>, <span class="number">5.1f</span>, <span class="number">6.1f</span>, <span class="number">7.1f</span>, <span class="number">8.1f</span>, <span class="number">9.1f</span>, <span class="number">10.1f</span>, <span class="number">1.1f</span>, <span class="number">1.1f</span>, <span class="number">2.1f</span>, <span class="number">2.1f</span>, <span class="number">3.1f</span>, <span class="number">4.1f</span>, <span class="number">5.1f</span>&#125;;</span><br><span class="line"></span><br><span class="line">        List&lt;Float&gt; modalNums2 = getModalNums(arr2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;众数：&quot;</span>+modalNums2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方差s^2=[(x1-x)^2 +...(xn-x)^2]/n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getVariance</span><span class="params">(<span class="type">double</span>[] x)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> x.length;</span><br><span class="line"><span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;<span class="comment">// 求和</span></span><br><span class="line">sum += x[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="variable">dAve</span> <span class="operator">=</span> sum / m;<span class="comment">// 求平均值</span></span><br><span class="line"><span class="type">double</span> <span class="variable">dVar</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;<span class="comment">// 求方差</span></span><br><span class="line">dVar += (x[i] - dAve) * (x[i] - dAve);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dVar / m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标准差σ=sqrt(s^2)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getStandardDiviation</span><span class="params">(<span class="type">double</span>[] x)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> x.length;</span><br><span class="line"><span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;<span class="comment">// 求和</span></span><br><span class="line">sum += x[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="variable">dAve</span> <span class="operator">=</span> sum / m;<span class="comment">// 求平均值</span></span><br><span class="line"><span class="type">double</span> <span class="variable">dVar</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;<span class="comment">// 求方差</span></span><br><span class="line">dVar += (x[i] - dAve) * (x[i] - dAve);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Math.sqrt(dVar / m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中位数(int)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums: A list of integers.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: An integer denotes the middle number of the array.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">median</span><span class="params">(<span class="type">int</span> []nums)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(nums.length==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> end=nums.length-<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> index=partition(nums, start, end);</span><br><span class="line"><span class="keyword">if</span>(nums.length%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(index!=nums.length/<span class="number">2</span>-<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(index&gt;nums.length/<span class="number">2</span>-<span class="number">1</span>)&#123;</span><br><span class="line">index=partition(nums, start, index-<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">index=partition(nums, index+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(index!=nums.length/<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(index&gt;nums.length/<span class="number">2</span>)&#123;</span><br><span class="line">index=partition(nums, start, index-<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">index=partition(nums, index+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[index];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line"><span class="type">int</span> left=start;</span><br><span class="line"><span class="type">int</span> right=end;</span><br><span class="line"><span class="type">int</span> pivot=nums[left];</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]&gt;=pivot)&#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">nums[left]=nums[right];</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]&lt;=pivot)&#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">nums[right]=nums[left];</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">nums[left]=pivot;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中位数(float)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums: A list of integers.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: An integer denotes the middle number of the array.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">median</span><span class="params">(<span class="type">float</span> []nums)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(nums.length==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> end=nums.length-<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> index=partition(nums, start, end);</span><br><span class="line"><span class="keyword">if</span>(nums.length%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(index!=nums.length/<span class="number">2</span>-<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(index&gt;nums.length/<span class="number">2</span>-<span class="number">1</span>)&#123;</span><br><span class="line">index=partition(nums, start, index-<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">index=partition(nums, index+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(index!=nums.length/<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(index&gt;nums.length/<span class="number">2</span>)&#123;</span><br><span class="line">index=partition(nums, start, index-<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">index=partition(nums, index+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[index];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">float</span> nums[], <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line"><span class="type">int</span> left=start;</span><br><span class="line"><span class="type">int</span> right=end;</span><br><span class="line"><span class="type">float</span> pivot=nums[left];</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]&gt;=pivot)&#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">nums[left]=nums[right];</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]&lt;=pivot)&#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">nums[right]=nums[left];</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">nums[left]=pivot;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 众数(int)</span></span><br><span class="line"><span class="comment"> * 众数:在一个数组中出现次数最多的数</span></span><br><span class="line"><span class="comment"> * 如果存在多个众数，则一起返回</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">getModalNums</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.asList(arr[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; freqMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 统计数组中每个数出现的频率</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">v</span> <span class="operator">=</span> freqMap.get(arr[i]);</span><br><span class="line">            <span class="comment">// v == null 说明 freqMap 中还没有这个 arr[i] 这个键</span></span><br><span class="line">            freqMap.put(arr[i], v == <span class="literal">null</span> ? <span class="number">1</span> : v + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 freqMap 中所有的键值对（键为数，值为数出现的频率）放入一个 ArrayList</span></span><br><span class="line">        List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(freqMap.entrySet());</span><br><span class="line">        <span class="comment">// 对 entries 按出现频率从大到小排序</span></span><br><span class="line">        Collections.sort(entries, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; e1, Map.Entry&lt;Integer, Integer&gt; e2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> e2.getValue() - e1.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; modalNums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        modalNums.add(entries.get(<span class="number">0</span>).getKey()); <span class="comment">// 排序后第一个 entry 的键肯定是一个众数</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> entries.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果之后的 entry 与第一个 entry 的 value 相等，那么这个 entry 的键也是众数</span></span><br><span class="line">            <span class="keyword">if</span> (entries.get(i).getValue().equals(entries.get(<span class="number">0</span>).getValue())) &#123;</span><br><span class="line">                modalNums.add(entries.get(i).getKey());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> modalNums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 众数(float)</span></span><br><span class="line"><span class="comment"> * 众数:在一个数组中出现次数最多的数</span></span><br><span class="line"><span class="comment"> * 如果存在多个众数，则一起返回</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Float&gt; <span class="title function_">getModalNums</span><span class="params">(<span class="type">float</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Float&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.asList(arr[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Float, Integer&gt; freqMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 统计数组中每个数出现的频率</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">v</span> <span class="operator">=</span> freqMap.get(arr[i]);</span><br><span class="line">            <span class="comment">// v == null 说明 freqMap 中还没有这个 arr[i] 这个键</span></span><br><span class="line">            freqMap.put(arr[i], v == <span class="literal">null</span> ? <span class="number">1</span> : v + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 freqMap 中所有的键值对（键为数，值为数出现的频率）放入一个 ArrayList</span></span><br><span class="line">        List&lt;Map.Entry&lt;Float, Integer&gt;&gt; entries = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(freqMap.entrySet());</span><br><span class="line">        <span class="comment">// 对 entries 按出现频率从大到小排序</span></span><br><span class="line">        Collections.sort(entries, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;Float, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;Float, Integer&gt; e1, Map.Entry&lt;Float, Integer&gt; e2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> e2.getValue() - e1.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        List&lt;Float&gt; modalNums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        modalNums.add(entries.get(<span class="number">0</span>).getKey()); <span class="comment">// 排序后第一个 entry 的键肯定是一个众数</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> entries.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果之后的 entry 与第一个 entry 的 value 相等，那么这个 entry 的键也是众数</span></span><br><span class="line">            <span class="keyword">if</span> (entries.get(i).getValue().equals(entries.get(<span class="number">0</span>).getValue())) &#123;</span><br><span class="line">                modalNums.add(entries.get(i).getKey());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> modalNums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java生成固定格式word并打印word文档解决方案【windows环境】</title>
      <link href="/posts/2018/05/4ef893aa.html"/>
      <url>/posts/2018/05/4ef893aa.html</url>
      
        <content type="html"><![CDATA[<p>   用户要求用程序生成标准的word文档，要能打印（有多个打印机时可以指定打印机进行打印，支持横向打印），而且不能变形，以前用过很多解决方案，都在客户严格要求下牺牲的无比惨烈。</p><p>   POI读word文档还行，写文档实在不敢恭维，复杂的样式很难控制不提，想象一下一个20多页，嵌套很多表格和图像的word文档靠POI来写代码输出，对程序员来说比去山西挖煤还惨，况且文档格式还经常变化。</p><p>   iText操作Excel还行，对于复杂的大量的word也是噩梦。</p><span id="more"></span> <p>   Word从2003开始支持XML格式，用XML还做就很简单了。 大致的思路是先用office2003或者2007编辑好word的样式，然后另存为xml，将xml翻译为FreeMarker模板，最后用java来解析FreeMarker模板并输出Doc。经测试这样方式生成的word文档完全符合office标准，样式、内容控制非常便利，打印也不会变形，生成的文档和office中编辑文档完全一样。</p><p>   具体代码请参见:<a href="https://www.cnblogs.com/zwqh/p/7182953.html">https://www.cnblogs.com/zwqh/p/7182953.html</a> ，此处不再赘述。</p><p>   另外还有一个比较好的生成各种美观的word的组件，分享一下:<a href="https://github.com/Sayi/poi-tl">https://github.com/Sayi/poi-tl</a> 。</p><p>   <strong>本文的重点是如何使用Java来打印word文档。</strong></p><p><strong>一、背景</strong></p><p>    ·查找了Java打印的相关资料，总结如下：</p><ul><li>  Java自带的PrintJob，提供的打印机制并不完整，只能打印pdf、txt、图片之类，无法打印html、word、excel等复杂文档。</li><li>  使用jacob组件打印word，详见：<a href="https://www.cnblogs.com/Joanna-Yan/p/5346084.html">https://www.cnblogs.com/Joanna-Yan/p/5346084.html</a> ，证实可用。但是不能指定打印机打印和不支持设定横向打印（可能是我没找到具体方法）。</li></ul><p>    由于上述两种方法均无法满足客户需求，我只好亲自上阵，完美实现了客户需求，并在实施过程中运行良好。</p><p><strong>二、我的解决方案</strong></p><p>   使用printword.exe ，下载链接：<a href="https://download.csdn.net/download/dong707/10485755">https://download.csdn.net/download/dong707/10485755</a></p><p>   调用printword.exe 时，有3个参数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-   path：word文档的路径（如果路径中有空格时，整个路径需要用双引号包起来），必填</span><br><span class="line">-   ip：打印机的IP（实际上该参数应为打印机的名字，但是我这边打印机的命名都是用ip来命名的，故用ip），实现指定打印机来打印，必填</span><br><span class="line">-   orientation：0 纵向打印，1 横向打印。可不填，默认纵向打印。</span><br></pre></td></tr></table></figure><p>   使用方法：</p><p>   在命令行中输入:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   c:/printer/printword.exe path=<span class="string">&quot;d:/app data/test.doc&quot;</span> ip=192.168.0.101 orientation=1</span><br></pre></td></tr></table></figure><p>   该命令行就是使用c:/printer/printword.exe调用ip为192.168.0.101的打印机（前提是要把这个ip的打印机添加到设备中，并且重命名为192.168.0.101，如下图所示），横向打印d:/app data/test.doc这个文档。</p><p><img src="https://oscimg.oschina.net/oscnet/3912437de83eb64a6a2471265397925d579.jpg"></p><p>   既然通过命令行可以打印word了，那现在就可以通过java来执行命令行打印word了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取cmd命令 */</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String cmd=<span class="string">&quot;cmd /c c:/printer/printword.exe ip=192.168.0.101 orientation=1 path=&quot;</span> + filePath;</span><br><span class="line">System.out.println(cmd);</span><br><span class="line"><span class="type">Process</span> <span class="variable">pro</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmd); </span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(pro.getInputStream())); </span><br><span class="line"><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">while</span> ((msg = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">System.out.println(msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException exception) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">LOG.warn(<span class="string">&quot;打印完成&quot;</span>);</span><br></pre></td></tr></table></figure><p>   综上，算是使用了一个较为简便的方法实现了通过java调用指定打印机横向打印word，特分享至此，欢迎共同讨论。</p>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Word </tag>
            
            <tag> 打印 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot + @scheduled 多任务并发</title>
      <link href="/posts/2018/04/f151b914.html"/>
      <url>/posts/2018/04/f151b914.html</url>
      
        <content type="html"><![CDATA[<p>下面讲的是springboot + @scheduled 多任务并发，spring的定时任务（包括多任务并发）详解参见 <strong><a href="https://blog.csdn.net/qq_33556185/article/details/51852537">传送门</a></strong></p><h3 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h3><p>项目采用springboot搭建，想给方法添加@Scheduled注解，实现两个定时任务。可是运行发现，两个task并没有并发执行，而是执行完一个task才会执行另外一个。上代码：</p><span id="more"></span> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.autohome.contentplatform.tasks;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Configurable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Configurable</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">task1</span> &#123;</span><br><span class="line">     <span class="meta">@Scheduled(cron = &quot;0/5 * *  * * ? &quot;)</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startSchedule</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;===========1=&gt;&quot;</span>);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">                 System.out.println(<span class="string">&quot;=1==&gt;&quot;</span>+i);</span><br><span class="line">                 Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@Scheduled(cron = &quot;0/5 * *  * * ? &quot;)</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startSchedule2</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;=2==&gt;&quot;</span>+i);</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行发现任务没有并行执行。</p><h3 id="二、解决"><a href="#二、解决" class="headerlink" title="二、解决"></a>二、解决</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Configurable</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoTask</span> &#123;</span><br><span class="line">     <span class="meta">@Async</span></span><br><span class="line">     <span class="meta">@Scheduled(cron = &quot;0/5 * *  * * ? &quot;)</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startSchedule</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;===========1=&gt;&quot;</span>);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">                 System.out.println(<span class="string">&quot;=1==&gt;&quot;</span>+i);</span><br><span class="line">                 Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">     <span class="meta">@Scheduled(cron = &quot;0/5 * *  * * ? &quot;)</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startSchedule2</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;=2==&gt;&quot;</span>+i);</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给类添加注解@EnableAsync，并给方法添加注解@Async。</p><p>再次运行，发现两个任务可以并发执行了。</p><h3 id="三、参考资料："><a href="#三、参考资料：" class="headerlink" title="三、参考资料："></a>三、参考资料：</h3><p><a href="https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/scheduling.html">https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/scheduling.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC整合cxf webservice出现提示No service was found解决办法</title>
      <link href="/posts/2018/04/aadd6311.html"/>
      <url>/posts/2018/04/aadd6311.html</url>
      
        <content type="html"><![CDATA[<p><strong>一、项目环境</strong></p><p>    SpringMVC框架 版本:4.3.1</p><p>    CXF  版本:3.1.6</p><p><strong>二、问题现象</strong></p><p>   配置好相关配置文件，验证webService是否发布成功，访问：</p><p>    <code>http://localhost:8080/CXF_Spring/webservice/HelloWorld?wsdl</code></p><p>   页面提示：</p><p>    <code>No service was found</code><br>   <span id="more"></span></p><p>   后台提示：</p><p>   <code>WARNING: Can&#39;t find the the request for     http://localhost:8080/CXF_Spring/webservice/HelloWorld&#39;s Observer </code></p><p><strong>三、问题分析</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WARNING: Can&#x27;t find the the request for http://localhost:8080/CXF_Spring/webservice/HelloWorld&#x27;s Observer </span><br></pre></td></tr></table></figure><p>   出现上述提示则意味着CXF的核心控制器没起作用，CXF的核心控制器要依赖Spring的ContextLoaderListner,而SpringMVC用的是DiapacherServlet的配置方式。问题搞清楚了，那么解决方案就很明显了。</p><p><strong>四、解决方案(其实也是整合SpringMvc和cxf的完整教程)</strong></p><p>    <strong>拆分配置文件，spring-servlet.xml（DiapacherServlet配置方式）中配置Controller组件，root-context.xml(ContextLoaderListner配置方式)中配置普通bean和CXF。</strong></p><p>详细配置如下(只展示与解决这个问题有关的配置)：</p><p>web.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Define spring4.x listener.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Define applicationContext.xml location.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">classpath:root-context.xml</span><br><span class="line"><span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>SpringMVC dispatcher servlet.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Define springMVC configuration location.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>CXFServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>  </span><br><span class="line">               org.apache.cxf.transport.servlet.CXFServlet</span><br><span class="line">        <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span>  </span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>CXFServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/webservice/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>spring-servlet.xml（DiapacherServlet配置方式）</strong></p><p>该配置文件没有与CXF有关的配置，略过</p><p><strong>root-context.xml(ContextLoaderListner配置方式)</strong></p><p>在该配置文件<beans>中首先要额外加上这些链接：xmlns:jaxws=”<a href="http://cxf.apache.org/jaxws&quot;">http://cxf.apache.org/jaxws&quot;</a> 和</beans></p><p>xsi:schemaLocation=” <a href="http://cxf.apache.org/jaxws">http://cxf.apache.org/jaxws</a>   <a href="http://cxf.apache.org/schemas/jaxws.xsd&quot;">http://cxf.apache.org/schemas/jaxws.xsd&quot;</a></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 引cxf的一些核心配置 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:META-INF/cxf/cxf.xml&quot;</span> /&gt;</span> </span><br><span class="line">   <span class="comment">&lt;!--  cxf 3.1.6版本不存在如下两个xml，可能在较早版本中会存在且需要需要</span></span><br><span class="line"><span class="comment">   &lt;import resource=&quot;classpath:META-INF/cxf/cxf-extension-soap.xml&quot; /&gt;</span></span><br><span class="line"><span class="comment">   &lt;import resource=&quot;classpath:META-INF/cxf/cxf-servlet.xml&quot; /&gt;</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.dx.webservice.HelloWorldImpl&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jaxws:endpoint</span> <span class="attr">id</span>=<span class="string">&quot;helloWorld&quot;</span> <span class="attr">implementor</span>=<span class="string">&quot;#hello&quot;</span> <span class="attr">address</span>=<span class="string">&quot;/HelloWorld&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0-alpha4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.cxf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cxf-rt-frontend-jaxws<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.cxf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cxf-rt-transports-http<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.cxf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cxf-rt-transports-http-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>HelloWorld.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jws.WebService;</span><br><span class="line"><span class="keyword">import</span> javax.jws.soap.SOAPBinding;</span><br><span class="line"><span class="keyword">import</span> javax.jws.soap.SOAPBinding.Style;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebService</span></span><br><span class="line"><span class="comment">//@WebService(targetNamespace=&quot;tallent&quot;)</span></span><br><span class="line"><span class="comment">//如果不写targetNamespace的值时，默认是包反转，比如服务器项目中包是com.gstd.hw，那么默认值为hw.gstd.com，如果在另外  </span></span><br><span class="line"><span class="comment">//的项目客户端中调用，则创建接口类HelloWorld时，类名可以不一样，但是targetNamespace必须一样。不然调用不成功！最好自己定义一个名称  </span></span><br><span class="line"><span class="meta">@SOAPBinding(style = Style.RPC)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">String <span class="title function_">sayHi</span><span class="params">(String text)</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>HelloWorldImpl.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jws.WebParam;</span><br><span class="line"><span class="keyword">import</span> javax.jws.WebService;</span><br><span class="line"><span class="keyword">import</span> javax.jws.soap.SOAPBinding;</span><br><span class="line"><span class="keyword">import</span> javax.jws.soap.SOAPBinding.Style;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebService(endpointInterface = &quot;com.dx.webservice.HelloWorld&quot;)</span><span class="comment">////这里指定服务的接口类的路径，也可以不写  </span></span><br><span class="line"><span class="meta">@SOAPBinding(style = Style.RPC)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldImpl</span> <span class="keyword">implements</span> <span class="title class_">HelloWorld</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">sayHi</span><span class="params">(<span class="meta">@WebParam(name = &quot;text&quot;)</span>String text)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;sayHi called&quot;</span>);   </span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + text;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述配置完成后，访问 <a href="http://localhost:8080/CXF_Spring/webservice/HelloWorld?wsdl%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E5%8F%91%E5%B8%83%E7%9A%84webservice%E7%9A%84xml%E4%BA%86%E3%80%82">http://localhost:8080/CXF_Spring/webservice/HelloWorld?wsdl即可看到发布的webservice的xml了。</a></p><p>访问<a href="http://localhost:8080/CXF_Spring/webservice/%E5%8F%AF%E6%9F%A5%E7%9C%8B%E5%8F%91%E5%B8%83%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%88%97%E8%A1%A8%E3%80%82">http://localhost:8080/CXF_Spring/webservice/可查看发布的接口列表。</a></p>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中使用xmlbeans解析xml开发总结</title>
      <link href="/posts/2018/04/472be5ab.html"/>
      <url>/posts/2018/04/472be5ab.html</url>
      
        <content type="html"><![CDATA[<p>   最近在工作中用到了webservice，需要解析webservice接口返回的各种xml格式报文。xml的解析一向是很伤脑筋的，而Java语言里解析xml的传统方式：dom解析和sax解析，对我而言实在是太过于死板僵硬望之却步，多方研究后在本项目中采用了apache提供的xml解析解决方案：xmlbeans，特在此总结xmlbeans的使用方法。</p><p><strong>一、关于xmlbeans</strong></p><p>   xmlbeans通过利用XML Schema的功能来提供结构化和约束性数据类型，开发者可以像Java对象那样直接访问XML文档。通过使用XMLBeans，Java开发者不需要花时间来编写导入/导出和有效性检验代码。<br>   <span id="more"></span></p><p><strong>二、下载配置xmlbeans</strong></p><p>这里我选择的是xmlbeans-2.4.0</p><p>a. 下载xmlbeans，从apache xmlbeans官网 <a href="http://xmlbeans.apache.org/">http://xmlbeans.apache.org/</a>  或者 csdn链接：<a href="https://download.csdn.net/download/dong707/10379022">下载xmlbeans-2.4.0</a>。假定下载到C:\xmlbeans-2.4.0<br>b. 设置环境变量XMLBEANS_HOME= C:\xmlbeans-2.4.0<br>c. 在path中加入%XMLBEANS_HOME%\bin</p><p><strong>三、生成XML Schema文件</strong></p><p>   什么是XML Schema文件? 正常情况下,每个XML文件都有一个Schema文件,XML Schema文件是一个XML的约束文件,它定义了 XML文件的结构和元素.以及对元素和结构的约束. 通俗地讲,如果说XML文件是数据库里的记录,那么Schema就是表结构定义.  <br>  <br>   为什么需要这个文件? xmlbeans需要通过这个文件知道一个XML文件的结构以及约束,比如数据类型等. 利用这个Schema文 件,xmlbeans将会产生一系列相关的Java Classes来实现对XML的操作。</p><p>   虽然有工具可以通过xml直接生成XML Schema文件，但是这种直接生成的通常不能直接使用，需要修改后才能使用。推荐在理解xml结构的基础上用Eclipse图形化界面操作直接生成XML Schema文件，方便快捷。</p><p>   以登录接口返回xml为例：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LoginResponse</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://tempuri.org/&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">LoginResult</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">SHINE</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">RESULT</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">RESULTCODE</span>&gt;</span>0<span class="tag">&lt;/<span class="name">RESULTCODE</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">RESULTMSG</span>&gt;</span>操作成功<span class="tag">&lt;/<span class="name">RESULTMSG</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">RESULT</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">QUEUETYPELIST</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">QUEUE_TYPE</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">SOURCE_ID</span>&gt;</span>001001<span class="tag">&lt;/<span class="name">SOURCE_ID</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">DISPLAY_NAME</span>&gt;</span>第五房间<span class="tag">&lt;/<span class="name">DISPLAY_NAME</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">NAME</span>&gt;</span>第五房间<span class="tag">&lt;/<span class="name">NAME</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">QUEUE_TYPE_ID</span>&gt;</span>7<span class="tag">&lt;/<span class="name">QUEUE_TYPE_ID</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">QUEUE_TYPE</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">QUEUETYPELIST</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">SHINE</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">LoginResult</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LoginResponse</span>&gt;</span></span><br></pre></td></tr></table></figure><p>根据上述xml，写出如下XML Schema文件：</p><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/hexo7.png" alt><p>LoginResponse是根节点，其中最关键的SHINEConfig的配置如下：</p><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/hexo8.png" alt><p>这里定义的数据约束如下：RESULTConfig的约束是[1..1],QUEUETYPELISTConfig的约束是[0..1]，QUEUE_TYPEConfig的约束是[1…*]。这里是由于在这个xml结构里RESULT元素只会出现一次，QUEUETYPELIST元素在有QUENE_TYPE数据时才会出现否则不出现，QUENE_TYPE元素至少出现一次。</p><p>CallLogin.xsd文件内容如下:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="attr">targetNamespace</span>=<span class="string">&quot;http://webservice.test.com/CallLogin&quot;</span> <span class="attr">xmlns:tns</span>=<span class="string">&quot;http://webservice.test.com/CallLogin&quot;</span> <span class="attr">elementFormDefault</span>=<span class="string">&quot;qualified&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">complexType</span> <span class="attr">name</span>=<span class="string">&quot;SHINEConfig&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequence</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&quot;RESULT&quot;</span> <span class="attr">type</span>=<span class="string">&quot;tns:RESULTConfig&quot;</span> <span class="attr">maxOccurs</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">minOccurs</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&quot;QUEUETYPELIST&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">&quot;tns:QUEUETYPELISTConfig&quot;</span> <span class="attr">maxOccurs</span>=<span class="string">&quot;1&quot;</span> <span class="attr">minOccurs</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sequence</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">complexType</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">complexType</span> <span class="attr">name</span>=<span class="string">&quot;RESULTConfig&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequence</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&quot;RESULTCODE&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&quot;RESULTMSG&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sequence</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">complexType</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&quot;LoginResponse&quot;</span> <span class="attr">type</span>=<span class="string">&quot;tns:LoginResponseConfig&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">complexType</span> <span class="attr">name</span>=<span class="string">&quot;LoginResultConfig&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequence</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&quot;SHINE&quot;</span> <span class="attr">type</span>=<span class="string">&quot;tns:SHINEConfig&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sequence</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">complexType</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">complexType</span> <span class="attr">name</span>=<span class="string">&quot;QUEUETYPELISTConfig&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequence</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&quot;QUEUE_TYPE&quot;</span> <span class="attr">type</span>=<span class="string">&quot;tns:QUEUE_TYPEConfig&quot;</span> <span class="attr">maxOccurs</span>=<span class="string">&quot;unbounded&quot;</span> <span class="attr">minOccurs</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sequence</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">complexType</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">complexType</span> <span class="attr">name</span>=<span class="string">&quot;QUEUE_TYPEConfig&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequence</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&quot;SOURCE_ID&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&quot;DISPLAY_NAME&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&quot;NAME&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&quot;QUEUE_TYPE_ID&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sequence</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">complexType</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">complexType</span> <span class="attr">name</span>=<span class="string">&quot;LoginResponseConfig&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequence</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&quot;LoginResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;tns:LoginResultConfig&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sequence</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">complexType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>四、利用scomp命令来编译XML Schema文件生成jar</strong></p><p>   scomp是xmlbeans提供的一个编译工具,它在bin的目录下. 通过这个工具,  <br>       我们可以将以上的Schema文件生成Java Classes.  <br>       scomp的语法如下:-    </p><p>       scomp [options] [dirs]* [schemaFile.xsd]* [service.wsdl]* [config.xsdconfig]*  <br>   <br>       主要参数说明:  <br>       -src [dir]                  – 生成的Java Classes存放目录  <br>       -srconly                  – 不编译Java Classes,不产生Jar文件  <br>       -out [jarFileName]  – 生成的Jar文件,缺省是xmltypes.jar  <br>       -compiler                 – Java编译器的路径,即Javac的位置  <br>       schemaFile.xsd    – XML Schema文件位置  <br>       config.xsdconfig   – xsdconfig文件的位置, 这个文件主要用来制定生成的Java Class 的一些文件名规则和Package的名称 </p><p>命令行中运行:   </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scomp -out c:\xsd\CallSystem.jar c:\xsd\*.xsd  -compiler <span class="string">&quot;C:\Program Files\Java\jdk1.7.0_80\bin\javac&quot;</span></span><br></pre></td></tr></table></figure><p>这个命令行的意思是告诉scomp在C:\xsd目录生成CallSystem.jar, 要解析的Schema文件是C:\xsd目录下的所有xsd。</p><p><strong>注：这是一个很实用的批量打包的命令，可以将多个xsd文件生成的java class打包进一个jar里。单独编译某个xsd的话直接在scope命令里指定xsd文件名即可。</strong></p><p>执行结果如下：</p><img src="https://fastly.jsdelivr.net/gh/dong706/dong706.github.io@latest/images/hexo9.png" alt><p>scomp命令还可以跟上xsdconfig文件，用于配置生成的class的package。（本例中在xsd中文件中已根据包路径配置了命名空间<a href="http://webservice.test.com/CallLogin%EF%BC%8C%E9%82%A3%E4%B9%88%E7%94%9F%E6%88%90%E7%9A%84jar%E9%87%8C%E7%9A%84%E5%8C%85%E8%B7%AF%E5%BE%84%E5%B0%B1%E6%98%AFcom.test.webservice.callLogin%EF%BC%8C%E6%89%80%E4%BB%A5%E6%AD%A4%E5%A4%84%E5%BF%BD%E7%95%A5%E4%BA%86xsdconfig%E9%85%8D%E7%BD%AE%E3%80%82%EF%BC%89">http://webservice.test.com/CallLogin，那么生成的jar里的包路径就是com.test.webservice.callLogin，所以此处忽略了xsdconfig配置。）</a>  </p><p>config.xsdconfig内容如下:  </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xb:config</span> <span class="attr">xmlns:xb</span>=<span class="string">&quot;http://xml.apache.org/xmlbeans/2004/02/xbean/config&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">xb:namespace</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">xb:package</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">xb:package</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">xb:namespace</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">xb:config</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>将xmlbeans/lib下的包和生成的CallSystem.jar包加入到Project的ClassPath中</p><p>pom.xml配置如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.xmlbeans<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xmlbeans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>五、Java程序中读取/构造xml</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.webservice.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.test.webservice.callLogin.LoginResponseConfig;</span><br><span class="line"><span class="keyword">import</span> com.test.webservice.callLogin.LoginResponseDocument;</span><br><span class="line"><span class="keyword">import</span> com.test.webservice.callLogin.LoginResultConfig;</span><br><span class="line"><span class="keyword">import</span> com.test.webservice.callLogin.QUEUETYPEConfig;</span><br><span class="line"><span class="keyword">import</span> com.test.webservice.callLogin.QUEUETYPELISTConfig;</span><br><span class="line"><span class="keyword">import</span> com.test.webservice.callLogin.RESULTConfig;</span><br><span class="line"><span class="keyword">import</span> com.test.webservice.callLogin.SHINEConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCallLogin</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">String xml=<span class="string">&quot;&lt;LoginResponse xmlns=\&quot;http://tempuri.org/\&quot;&gt;&quot;</span></span><br><span class="line">+<span class="string">&quot;&lt;LoginResult&gt;&quot;</span></span><br><span class="line">+<span class="string">&quot;&lt;SHINE&gt;&quot;</span></span><br><span class="line">+<span class="string">&quot;  &lt;RESULT&gt;&quot;</span></span><br><span class="line">+<span class="string">&quot;    &lt;RESULTCODE&gt;0&lt;/RESULTCODE&gt;&quot;</span></span><br><span class="line">+<span class="string">&quot;    &lt;RESULTMSG&gt;操作成功&lt;/RESULTMSG&gt;&quot;</span></span><br><span class="line">+<span class="string">&quot;  &lt;/RESULT&gt;&quot;</span></span><br><span class="line">+<span class="string">&quot;  &lt;QUEUETYPELIST&gt;&quot;</span></span><br><span class="line">+<span class="string">&quot;    &lt;QUEUE_TYPE&gt;&quot;</span></span><br><span class="line">+<span class="string">&quot;      &lt;SOURCE_ID&gt;001001&lt;/SOURCE_ID&gt;&quot;</span></span><br><span class="line">+<span class="string">&quot;      &lt;DISPLAY_NAME&gt; 第五房间&lt;/DISPLAY_NAME&gt;&quot;</span></span><br><span class="line">+<span class="string">&quot;      &lt;NAME&gt; 第五房间&lt;/NAME&gt;&quot;</span></span><br><span class="line">+<span class="string">&quot;      &lt;QUEUE_TYPE_ID&gt;7&lt;/QUEUE_TYPE_ID&gt;&quot;</span></span><br><span class="line">+<span class="string">&quot;    &lt;/QUEUE_TYPE&gt;&quot;</span></span><br><span class="line">+<span class="string">&quot;    &lt;QUEUE_TYPE&gt;&quot;</span></span><br><span class="line">+<span class="string">&quot;      &lt;SOURCE_ID&gt;001002&lt;/SOURCE_ID&gt;&quot;</span></span><br><span class="line">+<span class="string">&quot;      &lt;DISPLAY_NAME&gt; 第六房间&lt;/DISPLAY_NAME&gt;&quot;</span></span><br><span class="line">+<span class="string">&quot;      &lt;NAME&gt; 第六房间&lt;/NAME&gt;&quot;</span></span><br><span class="line">+<span class="string">&quot;      &lt;QUEUE_TYPE_ID&gt;8&lt;/QUEUE_TYPE_ID&gt;&quot;</span></span><br><span class="line">+<span class="string">&quot;    &lt;/QUEUE_TYPE&gt;&quot;</span></span><br><span class="line">+<span class="string">&quot;  &lt;/QUEUETYPELIST&gt;&quot;</span></span><br><span class="line">+<span class="string">&quot;&lt;/SHINE&gt;&lt;/LoginResult&gt;&lt;/LoginResponse&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">LoginResponseDocument</span> <span class="variable">loginResponseDocument</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">xml=xml.replace(<span class="string">&quot;http://tempuri.org/&quot;</span>, <span class="string">&quot;http://webservice.test.com/CallLogin&quot;</span>);</span><br><span class="line"></span><br><span class="line">loginResponseDocument=LoginResponseDocument.Factory.parse(xml);</span><br><span class="line"></span><br><span class="line">LoginResponseConfig loginResponseConfig=loginResponseDocument.getLoginResponse();</span><br><span class="line"></span><br><span class="line">LoginResultConfig callNextResultConfig=loginResponseConfig.getLoginResult();</span><br><span class="line"></span><br><span class="line">SHINEConfig shineConfig=callNextResultConfig.getSHINE();</span><br><span class="line"></span><br><span class="line">RESULTConfig resultConfig=shineConfig.getRESULT();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;RESULTCODE():&quot;</span>+resultConfig.getRESULTCODE());</span><br><span class="line">System.out.println(<span class="string">&quot;RESULTMSG():&quot;</span>+resultConfig.getRESULTMSG());</span><br><span class="line"></span><br><span class="line">QUEUETYPELISTConfig queuetypelistConfig=shineConfig.getQUEUETYPELIST();</span><br><span class="line"><span class="keyword">if</span>(queuetypelistConfig!=<span class="literal">null</span>)&#123;</span><br><span class="line">QUEUETYPEConfig[] queuetypeConfigs= queuetypelistConfig.getQUEUETYPEArray();</span><br><span class="line"><span class="keyword">for</span> (QUEUETYPEConfig queuetypeConfig : queuetypeConfigs) &#123;</span><br><span class="line">System.out.print(queuetypeConfig.getSOURCEID()+<span class="string">&quot;\t&quot;</span>+queuetypeConfig.getDISPLAYNAME()+<span class="string">&quot;\t&quot;</span></span><br><span class="line">+queuetypeConfig.getNAME()+<span class="string">&quot;\t&quot;</span>+queuetypeConfig.getQUEUETYPEID()+<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// TODO 自动生成 catch 块</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注：其中有xml=xml.replace(“<a href="http://tempuri.org/&quot;">http://tempuri.org/&quot;</a>, “<a href="http://webservice.test.com/CallLogin&quot;)%E8%BF%99%E4%B9%88%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%EF%BC%8C%E8%BF%99%E6%98%AF%E7%94%B1%E4%BA%8E%E5%A4%9A%E4%B8%AAwebservice%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E7%9A%84xml%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E9%83%BD%E6%98%AF">http://webservice.test.com/CallLogin&quot;)这么一段代码，这是由于多个webservice接口返回的xml命名空间都是</a> <a href="http://tempuri.org/">http://tempuri.org/</a> ，但是编写xsd时必须为各个xsd指定不同的命名空间防止生成jar包里存在冲突。所以在拿到webservice接口返回的xml时，必须把原始的命名空间<a href="http://tempuri.org/%E8%BD%AC%E6%8D%A2%E6%88%90xsd%E4%B8%AD%E5%AE%9E%E9%99%85%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4http://webservice.test.com/CallLogin%E6%89%8D%E8%83%BD%E8%A2%AB%E6%AD%A3%E5%B8%B8%E8%A7%A3%E6%9E%90%E3%80%82">http://tempuri.org/转换成xsd中实际的命名空间http://webservice.test.com/CallLogin才能被正常解析。</a></p><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RESULTCODE():0</span><br><span class="line">RESULTMSG():操作成功</span><br><span class="line">001001 第五房间 第五房间7</span><br><span class="line">001002 第六房间 第六房间8</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   可以看到引入xmlbeans根据xsd文件生成的jar包后，就能轻轻松松的以访问对象的方式去访问xml了。这里我只写了读xml的操作，写xml操作其实也是一样的简单，后续有时间我会继续更新。</p><p>**五、结束语  **   </p><p>   xmlbeans能帮助我们轻易读写XML,这将有助于我们降低XML的学习和使用,有了这个基础,开发人员将为学习更多地XML相关技术和Web Services,JMS等其他J2EE技术打下良好地基础。</p><p>   欢迎共同探讨。</p>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> xml </tag>
            
            <tag> xmlbeans </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Corba开发总结(六)---常见问题解决办法</title>
      <link href="/posts/2018/03/15547.html"/>
      <url>/posts/2018/03/15547.html</url>
      
        <content type="html"><![CDATA[<p>  由于公司新项目要求，做了一段时间的CORBA接口（中兴+华为）开发，踩了各种大大小小的坑，也算积累了一些经验，特分享至此，经验所限难免会有疏漏，欢迎讨论完善。</p><h4 id="一、初始化管理器报异常-org-omg-CORBA-NO-PERMISSION-vmcid-0x0-minor-code-0-completed-No"><a href="#一、初始化管理器报异常-org-omg-CORBA-NO-PERMISSION-vmcid-0x0-minor-code-0-completed-No" class="headerlink" title="一、初始化管理器报异常 org.omg.CORBA.NO_PERMISSION: vmcid: 0x0 minor code: 0 completed: No"></a>一、初始化管理器报异常 org.omg.CORBA.NO_PERMISSION: vmcid: 0x0 minor code: 0 completed: No</h4><p>     产生该异常的可能原因有两种：（1）使用的账号权限不足，通过网管平台授予更高权限即可；（2）当将账号权限设置为最高权限即管理员权限时也无法解决问题，那么问题可能是华为lisence过期，需联系华为采购licence。</p><span id="more"></span><p><strong>二、获取EmsSession引用对象，异常！—ProcessingFailureException—</strong></p><p>     产生该异常的原因一般是当前使用的登录用户的用户名密码错误，或者权限不够，或者已登录的用户还未退出，或者之前调用corba服务后未关闭连接导致该用户名还在登录状态。</p>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
          <category> Corba开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Corba </tag>
            
            <tag> JacORB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Corba开发总结(五)---中兴CORBA接口-获取历史告警文件</title>
      <link href="/posts/2018/03/56607.html"/>
      <url>/posts/2018/03/56607.html</url>
      
        <content type="html"><![CDATA[<p><strong>一、历史告警文件准备请求（requireHistoryAlarmFileTransfer）</strong></p><ul><li>  接口定义</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void requireHistoryAlarmFileTransfer (</span><br><span class="line"></span><br><span class="line">in string destination,</span><br><span class="line"></span><br><span class="line">in string userName,</span><br><span class="line"></span><br><span class="line">in string passWord,</span><br><span class="line"></span><br><span class="line">in alarmMgr::QueryAlarmFilter_T queryCondition)</span><br><span class="line"></span><br><span class="line">raises (globaldefs::ProcessingFailureException);</span><br></pre></td></tr></table></figure><ul><li>  说明</li></ul><p>历史告警文件准备请求。NMS向EMS发出大数据量历史告警文件文件传输准备的请求，让EMS开始准备相应数据。当EMS按照要求完成了文件准备之后，将向NMS发送’文件准备好’通知。如果在文件的准备中发生了异常，将向NMS发送’文件准备错误’通知。此方法属于FileTransferMgr_I接口。</p><span id="more"></span><ul><li>  输入参数</li></ul><p>        in string destination</p><p>        ——表示文件在NMS上的存放位置。格式定义请参考Destination_T</p><p>        in string userName</p><p>        ——表示FTP使用的用户名称</p><p>        in string passWord</p><p>        ——表示FTP使用的用户口令</p><p>        in alarmMgr:: QueryAlarmFilter_T queryCondition</p><p>        ——表示查询条件。EMS将根据查询条件准备文件</p><ul><li>  输出参数</li></ul><p>        无</p><ul><li>  返回值</li></ul><p>        无</p><ul><li>  异常</li></ul><p>        EXCPT_INTERNAL_ERROR。—EMS内部错误</p><p>        EXCPT_INVALID_INPUT  —输入参数无效不合法.</p><p>        EXCPT_NOT_IMPLEMENTED  — EMS不支持该操作</p><p>        EXCPT_UNABLE_TO_COMPLY  —超时或EMS不能响应操作</p><p><strong>二、接口分析</strong></p><p> 调用<strong>requireHistoryAlarmFileTransfer</strong>接口后，EMS会根据传入的查询条件得到相应的数据并按照固定的格式组织成文件，然后再通过FTP把文件传输给调用者指定的FTP服务器的指定目录里。</p><p><strong>三、中兴CORBA调用requireHistoryAlarmFileTransfer接口示例代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">emsSession =ZxEmsSession.getInstance().getEmsSession();</span><br><span class="line"><span class="comment">//System.out.println(&quot;EMSsession ---&quot; + emsSession.toString());</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(emsSession!=<span class="literal">null</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;初始化 FileTransfer 管理器!&quot;</span>);</span><br><span class="line"><span class="type">Common_IHolder</span> <span class="variable">mgrHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Common_IHolder</span>();</span><br><span class="line">emsSession.getManager(<span class="string">&quot;FileTransfer&quot;</span>, mgrHolder);</span><br><span class="line">fileTransferMgr = FileTransferMgr_IHelper.narrow(mgrHolder.value);</span><br><span class="line"></span><br><span class="line"><span class="type">QueryAlarmFilter_T</span> <span class="variable">queryCondition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryAlarmFilter_T</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Duration_T</span> <span class="variable">duration_T</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Duration_T</span>();</span><br><span class="line">duration_T.fromTime = startdate;</span><br><span class="line">duration_T.toTime = enddate;</span><br><span class="line">queryCondition.raiseTimeDuration = duration_T;</span><br><span class="line"></span><br><span class="line">queryCondition.alarmTypeSelect = <span class="keyword">new</span> <span class="title class_">AlarmType_T</span>[<span class="number">0</span>];</span><br><span class="line">queryCondition.alarmSourceSelect = <span class="keyword">new</span> <span class="title class_">NameAndStringValue_T</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">queryCondition.perceivedSeveritySelect = <span class="keyword">new</span> <span class="title class_">PerceivedSeverity_T</span>[<span class="number">0</span>];</span><br><span class="line">queryCondition.probableCauseSelect = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>];</span><br><span class="line"><span class="type">Duration_T</span> <span class="variable">duration_T2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Duration_T</span>();</span><br><span class="line">duration_T2.fromTime = <span class="string">&quot;&quot;</span>;</span><br><span class="line">duration_T2.toTime = <span class="string">&quot;&quot;</span>;</span><br><span class="line">queryCondition.clearTimeDuration = duration_T2;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;/alarm/&quot;</span> + duration_T.fromTime + <span class="string">&quot;_&quot;</span>+ duration_T.toTime + <span class="string">&quot;.dat&quot;</span>;</span><br><span class="line"></span><br><span class="line">fileTransferMgr.requireHistoryAlarmFileTransfer(<span class="string">&quot;本地FTP服务器IP|&quot;</span>+fileName+<span class="string">&quot;|本地FTP服务器端口&quot;</span>, <span class="string">&quot;本地FTP服务器用户名&quot;</span>, <span class="string">&quot;本地FTP服务器密码&quot;</span>, queryCondition);</span><br><span class="line"></span><br><span class="line">fileTransferMgr._release();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">LOG.error(<span class="string">&quot;未获取到emsSession&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ProcessingFailureException e) &#123;</span><br><span class="line">LOG.error(e);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
          <category> Corba开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Corba </tag>
            
            <tag> JacORB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Corba开发总结(四)---华为CORBA接口开发</title>
      <link href="/posts/2018/03/57045.html"/>
      <url>/posts/2018/03/57045.html</url>
      
        <content type="html"><![CDATA[<p><strong>一、华为CORBA接口开发过程</strong></p><p>流程与中兴类似：</p><ol><li> 建立连接、建立消息通道</li><li> 获取名字服务</li><li> 获取EMSSession工厂（注意这里传入的NameComponent参数与中兴不同）</li><li> 登录并获取EMSSession</li><li> 使用EMSSession初始化管理器对象</li><li> 管理器对象调用接口获取数据</li><li> 关闭连接<span id="more"></span></li></ol><p>     <strong>注：调用corba接口需要用到EMESession对象，如果在你的应用里要多次访问corba接口，那么多次建立连接和获取EMSSession是非常浪费服务器资源且效率低下的，并且一个corba用户名和密码在同一时间只能被一个连接使用。为了优化访问效率、避免登录冲突和减少重连开销，此处应当在服务启动时就建立连接和获取EMSSession（即步骤1、2、3、4），并不断发送心跳维持连接，在服务关闭时关闭连接即可。就这样就实现了一个corba连接的重复使用，可以用单例模式实现。</strong></p><p><strong>二、管理器对象定义</strong></p><p>    高层网管如果要通过U2000 CORBA接口获取数据或交互请求，必须首先获取到相应的CORBA接口管理对象，即CORBA对象，然后通过该管理对象提供的方法来交互请求。目前U2000 CORBA接口中定义的管理对象以及对应的管理对象的名字如表：</p><table><thead><tr><th><strong>管理对象定义</strong></th><th><strong>管理对象名称</strong></th></tr></thead><tbody><tr><td>EMSMgr_I</td><td>“EMS”</td></tr><tr><td>ManagedElementMgr_I</td><td>“ManagedElement”</td></tr><tr><td>PerformanceManagementMgr_I</td><td>“PerformanceManagement”</td></tr><tr><td>待完善…</td><td></td></tr></tbody></table><p>注：该管理器对象定义只适用于华为corba接口。</p><p><strong>三、华为CORBA接口开发示例</strong></p><p>demo github地址：<a href="https://github.com/dong706/CorbaDemo">https://github.com/dong706/CorbaDemo</a></p><p>调用ManagedElement管理器对象的获取所有网元信息接口（getAllManagedElements）示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dx.corba.hw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.omg.CORBA.ORB;</span><br><span class="line"><span class="keyword">import</span> org.omg.CORBA.SystemException;</span><br><span class="line"><span class="keyword">import</span> org.omg.CosNaming.NameComponent;</span><br><span class="line"><span class="keyword">import</span> org.omg.CosNaming.NamingContext;</span><br><span class="line"><span class="keyword">import</span> org.omg.CosNaming.NamingContextHelper;</span><br><span class="line"><span class="keyword">import</span> org.omg.CosNaming.NamingContextPackage.NotFound;</span><br><span class="line"><span class="keyword">import</span> org.omg.PortableServer.POA;</span><br><span class="line"><span class="keyword">import</span> org.omg.PortableServer.POAHelper;</span><br><span class="line"><span class="keyword">import</span> org.omg.hw.common.Common_IHolder;</span><br><span class="line"><span class="keyword">import</span> org.omg.hw.emsSession.EmsSession_I;</span><br><span class="line"><span class="keyword">import</span> org.omg.hw.emsSession.EmsSession_IHolder;</span><br><span class="line"><span class="keyword">import</span> org.omg.hw.emsSessionFactory.EmsSessionFactory_I;</span><br><span class="line"><span class="keyword">import</span> org.omg.hw.emsSessionFactory.EmsSessionFactory_IHelper;</span><br><span class="line"><span class="keyword">import</span> org.omg.hw.managedElement.ManagedElementIterator_IHolder;</span><br><span class="line"><span class="keyword">import</span> org.omg.hw.managedElement.ManagedElementList_THolder;</span><br><span class="line"><span class="keyword">import</span> org.omg.hw.managedElementManager.ManagedElementMgr_I;</span><br><span class="line"><span class="keyword">import</span> org.omg.hw.managedElementManager.ManagedElementMgr_IHelper;</span><br><span class="line"><span class="keyword">import</span> org.omg.hw.nmsSession.NmsSession_I;</span><br><span class="line"><span class="keyword">import</span> org.omg.hw.nmsSession.NmsSession_IPOATie;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Module: HelloClient.java Description: 客户端的初始化以及调用的代码 Company: Version: 1.0.0</span></span><br><span class="line"><span class="comment"> * Author: pantp Date: Jul 8, 2012</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HwDemo</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">EmsSession_I</span> <span class="variable">emsSession</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ManagedElementMgr_I</span> <span class="variable">meMgr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args1)</span> &#123;</span><br><span class="line">Object[] objects = getEmsSession();</span><br><span class="line"><span class="type">POA</span> <span class="variable">rootpoa</span> <span class="operator">=</span> rootpoa = (POA) objects[<span class="number">0</span>];</span><br><span class="line">emsSession = (EmsSession_I) objects[<span class="number">1</span>];</span><br><span class="line"><span class="type">ORB</span> <span class="variable">orb</span> <span class="operator">=</span> (ORB) objects[<span class="number">2</span>];</span><br><span class="line">System.out.println(<span class="string">&quot;EMSsession ---&quot;</span> + emsSession.toString());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;初始化 ManagedElement 管理器!&quot;</span>);</span><br><span class="line"><span class="type">Common_IHolder</span> <span class="variable">mgrHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Common_IHolder</span>();</span><br><span class="line">emsSession.getManager(<span class="string">&quot;ManagedElement&quot;</span>, mgrHolder);</span><br><span class="line">meMgr = ManagedElementMgr_IHelper.narrow(mgrHolder.value);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception pfe) &#123;</span><br><span class="line">System.out</span><br><span class="line">.println(<span class="string">&quot;初始化 ManagedElement 管理器异常!---ProcessingFailureException---&quot;</span>);</span><br><span class="line">System.out.println(pfe.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">ManagedElementList_THolder</span> <span class="variable">meList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ManagedElementList_THolder</span>();</span><br><span class="line"><span class="type">ManagedElementIterator_IHolder</span> <span class="variable">meIt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ManagedElementIterator_IHolder</span>();</span><br><span class="line">meMgr.getAllManagedElements(<span class="number">100</span>, meList, meIt);</span><br><span class="line">System.out.println(meList.value.length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, size = meList.value.length; i &lt; size; i++) &#123;</span><br><span class="line">System.out.println(meList.value[i].nativeEMSName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//meMgr._release();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (orb != <span class="literal">null</span>) &#123;</span><br><span class="line">orb.destroy();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line"><span class="keyword">if</span> (emsSession != <span class="literal">null</span>) &#123;</span><br><span class="line">emsSession.endSession();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rootpoa != <span class="literal">null</span>) &#123;</span><br><span class="line">rootpoa.destroy(<span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (orb != <span class="literal">null</span>) &#123;</span><br><span class="line">orb.shutdown(<span class="literal">true</span>);</span><br><span class="line">orb.destroy();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;关闭华为corba连接....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object[] getEmsSession() &#123;</span><br><span class="line">Object[] objects = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">3</span>];</span><br><span class="line"><span class="type">ORB</span> <span class="variable">orb</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">EmsSession_I</span> <span class="variable">emsSession</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 建立连接登录、建立消息通道</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String[] args = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">2</span>];</span><br><span class="line">args[<span class="number">0</span>] = <span class="string">&quot;-ORBInitRef&quot;</span>;</span><br><span class="line">args[<span class="number">1</span>] = <span class="string">&quot;NameService=corbaloc::&quot;</span> + <span class="string">&quot;CORBA服务器IP&quot;</span> + <span class="string">&quot;:&quot;</span> + <span class="string">&quot;CORBA服务器端口&quot;</span></span><br><span class="line">+ <span class="string">&quot;/NameService&quot;</span>;<span class="comment">// 此处使用命名端口</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;初始化ORB对象的启动参数为： arg[&quot;</span> + i + <span class="string">&quot;] = &quot;</span></span><br><span class="line">+ args[i]);</span><br><span class="line">&#125;</span><br><span class="line">orb = org.omg.CORBA.ORB.init(args, <span class="literal">null</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;成功初始化ORB对象!－－－－Initialize Orb&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SystemException ex) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;初始化ORB对象异常！&quot;</span>);</span><br><span class="line">System.out.println(ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (orb == <span class="literal">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;orb == null&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Get Nameservice reference</span></span><br><span class="line"><span class="type">NamingContext</span> <span class="variable">nsRootContext</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">org.omg.CORBA.<span class="type">Object</span> <span class="variable">objRef</span> <span class="operator">=</span> orb</span><br><span class="line">.resolve_initial_references(<span class="string">&quot;NameService&quot;</span>);</span><br><span class="line">nsRootContext = NamingContextHelper.narrow(objRef);</span><br><span class="line">System.out.println(<span class="string">&quot;成功获取取名字服务!－－－－Get Nameservice reference&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (org.omg.CORBA.ORBPackage.InvalidName ex) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;取名字服务索引异常!&quot;</span>);</span><br><span class="line">ex.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nsRootContext == <span class="literal">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;nsRootContext == null&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.1 Get Reference to EMSSessionFactory</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * org.omg.CORBA.Object obj = null; NameComponent[] name = new</span></span><br><span class="line"><span class="comment"> * NameComponent[1]; name[0] = new</span></span><br><span class="line"><span class="comment"> * NameComponent(strConfigEmsFactoryName, &quot;EMSFactory&quot;); obj =</span></span><br><span class="line"><span class="comment"> * nsRootContext.resolve(name); EmsSessionFactory_I emsSessionFactory =</span></span><br><span class="line"><span class="comment"> * EmsSessionFactory_IHelper.narrow(obj);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NameComponent[] name = <span class="keyword">new</span> <span class="title class_">NameComponent</span>[<span class="number">5</span>];</span><br><span class="line">name[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">NameComponent</span>(<span class="string">&quot;TMF_MTNM&quot;</span>, <span class="string">&quot;Class&quot;</span>);</span><br><span class="line">name[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">NameComponent</span>(<span class="string">&quot;HUAWEI&quot;</span>, <span class="string">&quot;Vendor&quot;</span>);</span><br><span class="line">name[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">NameComponent</span>(<span class="string">&quot;Huawei/U2000&quot;</span>, <span class="string">&quot;EmsInstance&quot;</span>);</span><br><span class="line">name[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">NameComponent</span>(<span class="string">&quot;2.0&quot;</span>, <span class="string">&quot;Version&quot;</span>);</span><br><span class="line">name[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">NameComponent</span>(<span class="string">&quot;Huawei/U2000&quot;</span>, <span class="string">&quot;EmsSessionFactory_I&quot;</span>);</span><br><span class="line"><span class="comment">// System.out.println(&quot;NameComponent: &#x27;&quot; + &quot;ZTE/T3 &quot; +</span></span><br><span class="line"><span class="comment">// &quot;&#x27;,&#x27;EMSFactory&#x27;&quot;);</span></span><br><span class="line">org.omg.CORBA.<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">obj = nsRootContext.resolve(name);</span><br><span class="line">System.out</span><br><span class="line">.println(<span class="string">&quot;成功获取EMSSession工厂!   Get Reference to EMSSessionFactory&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NotFound ex) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;取EMSSession工厂异常!---NotFound---&quot;</span>);</span><br><span class="line">ex.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (org.omg.CosNaming.NamingContextPackage.InvalidName ex) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;取EMSSession工厂异常!---InvalidName---&quot;</span>);</span><br><span class="line">ex.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (org.omg.CosNaming.NamingContextPackage.CannotProceed ex) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;取EMSSession工厂异常!---CannotProceed---&quot;</span>);</span><br><span class="line">ex.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始准备登陆并且获取EmsSession!</span></span><br><span class="line"><span class="type">EmsSessionFactory_I</span> <span class="variable">m_emsFactory</span> <span class="operator">=</span> EmsSessionFactory_IHelper</span><br><span class="line">.narrow(obj);</span><br><span class="line"><span class="type">NmsSession_I</span> <span class="variable">csession</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">POA</span> <span class="variable">rootpoa</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// get reference to rootpoa &amp; activate the POAManager</span></span><br><span class="line">System.out.println(<span class="string">&quot;取得rootpoa并激活POAManager!&quot;</span>);</span><br><span class="line">rootpoa = POAHelper.narrow(orb</span><br><span class="line">.resolve_initial_references(<span class="string">&quot;RootPOA&quot;</span>));</span><br><span class="line">rootpoa.the_POAManager().activate();</span><br><span class="line"><span class="comment">// create servant and register it with the ORB</span></span><br><span class="line">System.out.println(<span class="string">&quot;注册NmsSession到ORB!&quot;</span>);</span><br><span class="line"><span class="type">NmsSessionImpl</span> <span class="variable">nmsSessionImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NmsSessionImpl</span>();</span><br><span class="line"><span class="comment">// nmsSessionImpl.setORB(orb);</span></span><br><span class="line"><span class="type">byte</span>[] objectID = rootpoa.activate_object(nmsSessionImpl);</span><br><span class="line"><span class="comment">// create a tie, with servant being the delegate.</span></span><br><span class="line">System.out.println(<span class="string">&quot;创建NmsSession并且托管给POA!&quot;</span>);</span><br><span class="line"><span class="type">NmsSession_IPOATie</span> <span class="variable">tie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NmsSession_IPOATie</span>(nmsSessionImpl,</span><br><span class="line">rootpoa);</span><br><span class="line"></span><br><span class="line"><span class="comment">// obtain the objectRef for the tie</span></span><br><span class="line"><span class="comment">// this step also implicitly activates the the object</span></span><br><span class="line">System.out.println(<span class="string">&quot;在orb上激活NmsSession对象!&quot;</span>);</span><br><span class="line">csession = tie._this(orb);</span><br><span class="line"></span><br><span class="line">objects[<span class="number">0</span>] = rootpoa;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;创建NmsSession对象过程,执行异常!&quot;</span>);</span><br><span class="line">System.out.println(ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">EmsSession_IHolder</span> <span class="variable">sessionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmsSession_IHolder</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;获取EmsSession引用对象&quot;</span>);</span><br><span class="line">m_emsFactory.getEmsSession(<span class="string">&quot;CORBA服务用户名&quot;</span>, <span class="string">&quot;CORBA服务密码&quot;</span>, csession,</span><br><span class="line">sessionHolder);</span><br><span class="line">emsSession = sessionHolder.value;</span><br><span class="line">objects[<span class="number">1</span>] = emsSession;</span><br><span class="line"><span class="comment">// System.out.println(&quot;NMSsession ---&quot; + csession.toString());</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (org.omg.hw.globaldefs.ProcessingFailureException ex) &#123;</span><br><span class="line">System.out</span><br><span class="line">.println(<span class="string">&quot;获取EmsSession引用对象，异常！---ProcessingFailureException---&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;可能是用户名或者密码错误，或者权限不够，或者已登陆的用户还未退出！&quot;</span>);</span><br><span class="line">System.out.println(ex.toString());</span><br><span class="line">&#125;</span><br><span class="line">objects[<span class="number">2</span>] = orb;</span><br><span class="line"><span class="comment">// System.out.println(&quot;EMSsession ---&quot; + emsSession.toString());</span></span><br><span class="line"><span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
          <category> Corba开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Corba </tag>
            
            <tag> JacORB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Corba开发总结(三)---基于ZTECORBA的Client程序</title>
      <link href="/posts/2018/03/18052.html"/>
      <url>/posts/2018/03/18052.html</url>
      
        <content type="html"><![CDATA[<p>1 获得CORBA Adapter所使用的Naming Service的对象引用，</p><p>2 获得所连接的EMS所对应的在NamingService中注册用的名字，记为nameOfEms。(注：即为名字树图中的id值)，id值为“ZTE/E300”，kind为“EMSFactory”.</p><p>3 根据名字树图构造name, 通过步骤1中得到的NamingService去获取EmsSessionFactory_I对象的引用。</p><p>4 获得访问EMS所需的用户名和密码后，在client端构造emsSession_I CORBA对象，并实现emsSession_I接口定义的四个方法，便于Server端能够检测通讯情况和向Client端报告事件通道的可用情况。调用EmsSessionFactory_I对象引用 的getEmsSession 方法得到EmsSession_I对象引用。</p><span id="more"></span><p>5 调用emsSession_I对象的getEventChannel()获取eventChannel。此步骤也可以省略。</p><p>6 调用emsSession_I对象的getSupportedManagers操作，获取EMS所支持的所有管理者的名称。</p><p>7 根据各个管理者的名称，调用emsSession_I对象的getManager操作，分别获取各个管理者的对象引用，以便对各个管理者所提供的方法进行操作。</p><p>8 对于通知上报：client端需实现StructuredPushConsumer对象，同时可以设置过滤条件。过滤条件的设置必须符合CORBA 2.3的通知服务规范，然后调用管理者“Subscriber”对象提供的subscribe方法。以上就完成了某个通知的订阅。若要暂停或停止通知订阅的话，可以根据先前返回的订阅ID，调用“Subscriber”对象的suspendSubscription和unsubscribe方法。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.zte.application.idl;</span><br><span class="line"></span><br><span class="line">import nmsSession.NmsSession_I;</span><br><span class="line"></span><br><span class="line">import nmsSession.NmsSession_IPOATie;</span><br><span class="line"></span><br><span class="line">import org.omg.CORBA.IntHolder;</span><br><span class="line"></span><br><span class="line">import org.omg.CORBA.ORB;</span><br><span class="line"></span><br><span class="line">import org.omg.CORBA.SystemException;</span><br><span class="line"></span><br><span class="line">import org.omg.CosNaming.NameComponent;</span><br><span class="line"></span><br><span class="line">import org.omg.CosNaming.NamingContext;</span><br><span class="line"></span><br><span class="line">import org.omg.CosNaming.NamingContextHelper;</span><br><span class="line"></span><br><span class="line">import org.omg.CosNaming.NamingContextPackage.NotFound;</span><br><span class="line"></span><br><span class="line">import org.omg.CosNotifyComm.StructuredPushConsumerHelper;</span><br><span class="line"></span><br><span class="line">import org.omg.PortableServer.POA;</span><br><span class="line"></span><br><span class="line">import org.omg.PortableServer.POAHelper;</span><br><span class="line"></span><br><span class="line">import org.omg.PortableServer.POAPackage.WrongPolicy;</span><br><span class="line"></span><br><span class="line">import subscription.EMSSubscriptionMgr_I;</span><br><span class="line"></span><br><span class="line">import subscription.EMSSubscriptionMgr_IHelper;</span><br><span class="line"></span><br><span class="line">import common.Common_IHolder;</span><br><span class="line"></span><br><span class="line">import emsMgr.EMSMgr_I;</span><br><span class="line"></span><br><span class="line">import emsMgr.EMSMgr_IHelper;</span><br><span class="line"></span><br><span class="line">import emsSession.EmsSession_I;</span><br><span class="line"></span><br><span class="line">import emsSession.EmsSession_IHolder;</span><br><span class="line"></span><br><span class="line">import emsSession.EmsSession_IPackage.managerNames_THolder;</span><br><span class="line"></span><br><span class="line">import emsSessionFactory.EmsSessionFactory_I;</span><br><span class="line"></span><br><span class="line">import emsSessionFactory.EmsSessionFactory_IHelper;</span><br><span class="line"></span><br><span class="line">import globaldefs.ProcessingFailureException;</span><br><span class="line"></span><br><span class="line">import managedElement.ManagedElementList_THolder;</span><br><span class="line"></span><br><span class="line">import managedElementManager.ManagedElementMgr_I;</span><br><span class="line"></span><br><span class="line">import managedElementManager.ManagedElementMgr_IHelper;</span><br><span class="line"></span><br><span class="line">public class test</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">static ORB orb;</span><br><span class="line"></span><br><span class="line">static EMSMgr_I emsMgr = null;</span><br><span class="line"></span><br><span class="line">static EmsSession_I emsSession=null;</span><br><span class="line"></span><br><span class="line">s</span><br><span class="line"></span><br><span class="line">tatic ManagedElementMgr_I meMgr = null;</span><br><span class="line"></span><br><span class="line">static EMSSubscriptionMgr_I emsSpMgr = null;</span><br><span class="line"></span><br><span class="line">public static boolean testTai()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">//建立连接登录、建立消息通道</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">String[] args = new String[2];</span><br><span class="line"></span><br><span class="line">args[0] = &quot;-ORBInitRef&quot;;</span><br><span class="line"></span><br><span class="line">args[1] = &quot;NameService=corbaloc::&quot; + &quot;10.217.1.1&quot; + &quot;:&quot; + &quot;6004&quot; + &quot;/NameService&quot;;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;初始化ORB对象的启动参数为： arg[&quot; + i + &quot;] = &quot; + args[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">orb = org.omg.CORBA.ORB.init(args, null);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;成功初始化ORB对象!－－－－Initialize Orb&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">catch (SystemException ex) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;初始化ORB对象异常！&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(ex.getMessage());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (orb == null) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;orb == null&quot;);</span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Get Nameservice reference</span><br><span class="line"></span><br><span class="line">NamingContext nsRootContext = null;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">org.omg.CORBA.Object objRef = orb.resolve_initial_references(</span><br><span class="line"></span><br><span class="line">NameService);</span><br><span class="line"></span><br><span class="line">nsRootContext = NamingContextHelper.narrow(objRef);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;成功获取取名字服务!－－－－Get Nameservice reference&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">catch (org.omg.CORBA.ORBPackage.InvalidName ex) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;取名字服务索引异常!&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(ex.getMessage());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3.1 Get Reference to EMSSessionFactory</span><br><span class="line"></span><br><span class="line">NameComponent[] name = new NameComponent[1];</span><br><span class="line"></span><br><span class="line">name[0] = new NameComponent(&quot;ZTE/E300&quot;, &quot;EMSFactory&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;NameComponent: &#x27;&quot; + &quot;ZTE/E300 &quot;+ &quot;&#x27;,&#x27;EMSFactory&#x27;&quot;);</span><br><span class="line"></span><br><span class="line">org.omg.CORBA.Object obj = null;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">obj = nsRootContext.resolve(name);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;成功获取EMSSession工厂! Get Reference to EMSSessionFactory&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">catch (NotFound ex) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;取EMSSession工厂异常!---NotFound---&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(ex.getMessage());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">catch (org.omg.CosNaming.NamingContextPackage.InvalidName ex) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;取EMSSession工厂异常!---InvalidName---&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(ex.getMessage());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">catch (org.omg.CosNaming.NamingContextPackage.CannotProceed ex) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;取EMSSession工厂异常!---CannotProceed---&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(ex.getMessage());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//开始准备登陆并且获取EmsSession!</span><br><span class="line"></span><br><span class="line">EmsSessionFactory_I m_emsFactory = EmsSessionFactory_IHelper.narrow(obj);</span><br><span class="line"></span><br><span class="line">NmsSession_I csession = null;</span><br><span class="line"></span><br><span class="line">POA rootpoa = null;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">// get reference to rootpoa &amp; activate the POAManager</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;取得rootpoa并激活POAManager!&quot;);</span><br><span class="line"></span><br><span class="line">rootpoa = POAHelper.narrow(orb.resolve_initial_references(&quot;RootPOA&quot;));</span><br><span class="line"></span><br><span class="line">rootpoa.the_POAManager().activate();</span><br><span class="line"></span><br><span class="line">// create servant and register it with the ORB</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;注册NmsSession到ORB!&quot;);</span><br><span class="line"></span><br><span class="line">NmsSessionImpl nmsSessionImpl = new NmsSessionImpl();</span><br><span class="line"></span><br><span class="line">// nmsSessionImpl.setORB(orb);</span><br><span class="line"></span><br><span class="line">byte [] objectID=rootpoa.activate_object(nmsSessionImpl);</span><br><span class="line"></span><br><span class="line">// create a tie, with servant b</span><br><span class="line"></span><br><span class="line">eing the delegate.</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;创建NmsSession并且托管给POA!&quot;);</span><br><span class="line"></span><br><span class="line">NmsSession_IPOATie tie = new NmsSession_IPOATie(nmsSessionImpl,</span><br><span class="line"></span><br><span class="line">rootpoa);</span><br><span class="line"></span><br><span class="line">// obtain the objectRef for the tie</span><br><span class="line"></span><br><span class="line">// this step also implicitly activates the the object</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;在orb上激活NmsSession对象!&quot;);</span><br><span class="line"></span><br><span class="line">csession = tie._this(orb);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">catch (Exception ex) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;创建NmsSession对象过程,执行异常!&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(ex.getMessage());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EmsSession_IHolder sessionHolder = new EmsSession_IHolder();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;获取EmsSession引用对象&quot;);</span><br><span class="line"></span><br><span class="line">m_emsFactory.getEmsSession(&quot;root&quot;,&quot;&quot;, csession, sessionHolder);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;NMSsession ---&quot; + csession.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">catch (globaldefs.ProcessingFailureException ex) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;获取EmsSession引用对象，异常！---ProcessingFailureException---&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;可能是用户名或者密码错误，或者权限不够，或者已登陆的用户还未退出！&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(ex.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">emsSession = sessionHolder.value;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;EMSsession ---&quot; + emsSession.toString());</span><br><span class="line"></span><br><span class="line">//获得所支持的管理器</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">managerNames_THolder mgrHolder = new managerNames_THolder();</span><br><span class="line"></span><br><span class="line">emsSession.getSupportedManagers(mgrHolder);</span><br><span class="line"></span><br><span class="line">String[] manages = mgrHolder.value;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; manages.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;管理器--Manager &quot; + i + &quot; &quot; + manages[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">catch (ProcessingFailureException pfe) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;获得所支持的管理器,异常！---ProcessingFailureException---&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(pfe.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">emsSession.ping();</span><br><span class="line"></span><br><span class="line">// 初始化 ManagedElement 管理器</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;初始化 ManagedElement 管理器!&quot;);</span><br><span class="line"></span><br><span class="line">Common_IHolder mgrHolder = new Common_IHolder();</span><br><span class="line"></span><br><span class="line">emsSession.getManager(&quot;ManagedElement&quot;, mgrHolder);</span><br><span class="line"></span><br><span class="line">meMgr = ManagedElementMgr_IHelper.narrow(mgrHolder.value);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">catch (ProcessingFailureException pfe) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(</span><br><span class="line"></span><br><span class="line">初始化 ManagedElement 管理器异常!---ProcessingFailureException---);</span><br><span class="line"></span><br><span class="line">System.out.println(pfe.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 初始化 EquipmentInventory 管理器</span><br><span class="line"></span><br><span class="line">// try &#123;</span><br><span class="line"></span><br><span class="line">// System.out.println(&quot;初始化 EquipmentInventory 管理器!&quot;);</span><br><span class="line"></span><br><span class="line">// Common_IHolder mgrHolder = new Common_IHolder();</span><br><span class="line"></span><br><span class="line">// emsSession.getManager(&quot;EquipmentInventory&quot;, mgrHolder);</span><br><span class="line"></span><br><span class="line">// eiMgr = EquipmentInventoryMgr_IHelper.narrow(mgrHolder.value);</span><br><span class="line"></span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// catch (ProcessingFailureException pfe) &#123;</span><br><span class="line"></span><br><span class="line">// System.out.println(</span><br><span class="line"></span><br><span class="line">// 初始化 EquipmentInventory 管理器异常!---ProcessingFailureException---);</span><br><span class="line"></span><br><span class="line">// System.out.println(pfe);</span><br><span class="line"></span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// 初始化 MultiLayerSubnetwork 管理器</span><br><span class="line"></span><br><span class="line">// try &#123;</span><br><span class="line"></span><br><span class="line">// System.out.println(&quot;初始化 MultiLayerSubnetwork 管理器!&quot;);</span><br><span class="line"></span><br><span class="line">// Common_IHolder mgrHolder = new Common_IHolder();</span><br><span class="line"></span><br><span class="line">// emsSession.getManager(&quot;MultiLayerSubnetw</span><br><span class="line"></span><br><span class="line">ork&quot;, mgrHolder);</span><br><span class="line"></span><br><span class="line">// mlsMgr = MultiLayerSubnetworkMgr_IHelper.narrow(mgrHolder.value);</span><br><span class="line"></span><br><span class="line">// // mlsMgr.getAllSubnetworkConnections();</span><br><span class="line"></span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// catch (ProcessingFailureException pfe) &#123;</span><br><span class="line"></span><br><span class="line">// System.out.println(</span><br><span class="line"></span><br><span class="line">// 初始化 MultiLayerSubnetwork 管理器异常!---ProcessingFailureException---);</span><br><span class="line"></span><br><span class="line">// System.out.println(pfe);</span><br><span class="line"></span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// 初始化 EMS 管理器</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;初始化 EMS 管理器!&quot;);</span><br><span class="line"></span><br><span class="line">Common_IHolder mgrHolder = new Common_IHolder();</span><br><span class="line"></span><br><span class="line">emsSession.getManager(&quot;EMS&quot;, mgrHolder);</span><br><span class="line"></span><br><span class="line">emsMgr = EMSMgr_IHelper.narrow(mgrHolder.value);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;EMS_Manager To String ---&quot; + emsMgr.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">catch (ProcessingFailureException pfe) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;初始化 EMS 管理器异常!---ProcessingFailureException---&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(pfe.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//初始化事件信道管理器（注意这是非标准的自定义管理器！！！！）</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;初始化事件信道管理器!&quot;);</span><br><span class="line"></span><br><span class="line">//我方在IDL中定义的一个基类</span><br><span class="line"></span><br><span class="line">Common_IHolder mgrHolder = new Common_IHolder();</span><br><span class="line"></span><br><span class="line">//获取注册通道管理者(这个对象我方在IDL定义的一个接口）</span><br><span class="line"></span><br><span class="line">emsSession.getManager(&quot;Subscriber&quot;, mgrHolder);</span><br><span class="line"></span><br><span class="line">emsSpMgr = EMSSubscriptionMgr_IHelper.narrow(mgrHolder.value);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;EMSSubscriptionMgr To String ---&quot; + emsSpMgr.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">catch (ProcessingFailureException pfe) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;初始化事件信道管理器!---ProcessingFailureException---&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(pfe.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">try&#123;</span><br><span class="line"></span><br><span class="line">initEvent(emsMgr, rootpoa);</span><br><span class="line"></span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void initEvent(EMSMgr_I emsMgr, POA rootpoa) &#123;</span><br><span class="line"></span><br><span class="line">// 通过远程对象获取网元信息</span><br><span class="line"></span><br><span class="line">ManagedElementList_THolder meList = null;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">meList = new ManagedElementList_THolder();</span><br><span class="line"></span><br><span class="line">meMgr.getAllManagedElements(meList);</span><br><span class="line"></span><br><span class="line">for(int i=0,size=meList.value.length;i&lt;size;i++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(meList.value[i].name[1].value);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;获得节点列表!&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">catch (ProcessingFailureException ex) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(ex.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String args[]) &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">test ss = new test();</span><br><span class="line"></span><br><span class="line">ss.testTai();</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
          <category> Corba开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Corba </tag>
            
            <tag> JacORB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Corba开发总结(二)---中兴CORBA接口开发</title>
      <link href="/posts/2018/03/375.html"/>
      <url>/posts/2018/03/375.html</url>
      
        <content type="html"><![CDATA[<p>    由于公司新项目要求，做了一段时间的CORBA接口（中兴+华为）开发，踩了各种大大小小的坑，也算积累了一些经验，特分享至此，经验所限难免会有疏漏，欢迎讨论完善。</p><p><strong>一、中兴CORBA接口开发过程</strong></p><ol><li> 建立连接、建立消息通道</li><li> 获取名字服务</li><li> 获取EMSSession工厂</li><li> 登录并获取EMSSession</li><li> 使用EMSSession初始化管理器对象</li><li> 管理器对象调用接口获取数据<span id="more"></span></li></ol><p>     <strong>注：调用corba接口需要用到EMESession对象，如果在你的应用里要多次访问corba接口，那么多次建立连接和获取EMSSession是非常浪费服务器资源且效率低下的，并且一个corba用户名和密码在同一时间只能被一个连接使用。为了优化访问效率、避免登录冲突和减少重连开销，此处应当在服务启动时就建立连接和获取EMSSession（即步骤1、2、3、4），并不断发送心跳维持连接。就这样就实现了一个corba连接的重复使用，可以用单例模式实现。</strong></p><p><strong>二、管理器对象定义</strong></p><p>高层网管如果要通过NetNumen NBI CORBA接口获取数据或交互请求，必须首先获取到相应的CORBA接口管理对象，即CORBA对象，然后通过该管理对象提供的方法来交互请求。目前NetNumen NBI CORBA接口中定义的管理对象以及对应的管理对象的名字如表：</p><table><thead><tr><th><strong>管理对象定义</strong></th><th><strong>管理对象名称</strong></th></tr></thead><tbody><tr><td>EMSMgr_I</td><td>“EMS”</td></tr><tr><td>EMSSubscriptionMgr_I</td><td>“Subscriber”</td></tr><tr><td>EquipmentInventoryMgr_I</td><td>“EquipmentInventory”</td></tr><tr><td>Ethernet_I</td><td>“Ethernet”</td></tr><tr><td>FileTransferMgr_I</td><td>“FileTransfer”</td></tr><tr><td>FlowDomainMgr_I</td><td>“FlowDomain”</td></tr><tr><td>HeartbeatServiceMgr_I</td><td>“CommService”</td></tr><tr><td>ManagedElementMgr_I</td><td>“ManagedElement”</td></tr><tr><td>MSTPCommon_I</td><td>“MSTPCommon”</td></tr><tr><td>MultiLayerSubnetworkMgr_I</td><td>“MultiLayerSubnetwork”</td></tr><tr><td>PerformanceManagementMgr_I</td><td>“PerformanceManagement”</td></tr><tr><td>ProtectionMgr_I</td><td>“Protection”</td></tr><tr><td>TrailNtwProtMgr_I</td><td>“TrailNetworkProtection”</td></tr><tr><td>MaintenanceMgr_I</td><td>“maintenance”</td></tr></tbody></table><p>注：该管理器对象定义只适用于中兴corba接口。</p><p><strong>三、中兴CORBA接口开发示例</strong></p><p>demo github地址：<a href="https://github.com/dong706/CorbaDemo">https://github.com/dong706/CorbaDemo</a></p><p>调用EMS管理器对象的获取所有网元信息接口（getAllManagedElements）和获取所有拓扑连接接口（getAllTopLevelTopologicalLinks）示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dx.corba;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.omg.CORBA.ORB;</span><br><span class="line"><span class="keyword">import</span> org.omg.CORBA.SystemException;</span><br><span class="line"><span class="keyword">import</span> org.omg.CosNaming.NameComponent;</span><br><span class="line"><span class="keyword">import</span> org.omg.CosNaming.NamingContext;</span><br><span class="line"><span class="keyword">import</span> org.omg.CosNaming.NamingContextHelper;</span><br><span class="line"><span class="keyword">import</span> org.omg.CosNaming.NamingContextPackage.NotFound;</span><br><span class="line"><span class="keyword">import</span> org.omg.PortableServer.POA;</span><br><span class="line"><span class="keyword">import</span> org.omg.PortableServer.POAHelper;</span><br><span class="line"><span class="keyword">import</span> org.omg.zx.common.Common_IHolder;</span><br><span class="line"><span class="keyword">import</span> org.omg.zx.emsMgr.EMSMgr_I;</span><br><span class="line"><span class="keyword">import</span> org.omg.zx.emsMgr.EMSMgr_IHelper;</span><br><span class="line"><span class="keyword">import</span> org.omg.zx.emsSession.EmsSession_I;</span><br><span class="line"><span class="keyword">import</span> org.omg.zx.emsSession.EmsSession_IHolder;</span><br><span class="line"><span class="keyword">import</span> org.omg.zx.emsSessionFactory.EmsSessionFactory_I;</span><br><span class="line"><span class="keyword">import</span> org.omg.zx.emsSessionFactory.EmsSessionFactory_IHelper;</span><br><span class="line"><span class="keyword">import</span> org.omg.zx.globaldefs.NameAndStringValue_T;</span><br><span class="line"><span class="keyword">import</span> org.omg.zx.globaldefs.ProcessingFailureException;</span><br><span class="line"><span class="keyword">import</span> org.omg.zx.managedElement.ManagedElementList_THolder;</span><br><span class="line"><span class="keyword">import</span> org.omg.zx.managedElementManager.ManagedElementMgr_I;</span><br><span class="line"><span class="keyword">import</span> org.omg.zx.nmsSession.NmsSession_I;</span><br><span class="line"><span class="keyword">import</span> org.omg.zx.nmsSession.NmsSession_IPOATie;</span><br><span class="line"><span class="keyword">import</span> org.omg.zx.subscription.EMSSubscriptionMgr_I;</span><br><span class="line"><span class="keyword">import</span> org.omg.zx.topologicalLink.TopologicalLinkList_THolder;</span><br><span class="line"><span class="keyword">import</span> org.omg.zx.topologicalLink.TopologicalLink_T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZxDemo</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ORB orb;</span><br><span class="line"><span class="keyword">static</span> <span class="type">EMSMgr_I</span> <span class="variable">emsMgr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">EmsSession_I</span> <span class="variable">emsSession</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">ManagedElementMgr_I</span> <span class="variable">meMgr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">EMSSubscriptionMgr_I</span> <span class="variable">emsSpMgr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">invoke</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 建立连接登录、建立消息通道</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String[] args = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">2</span>];</span><br><span class="line">args[<span class="number">0</span>] = <span class="string">&quot;-ORBInitRef&quot;</span>;</span><br><span class="line">args[<span class="number">1</span>] = <span class="string">&quot;NameService=corbaloc::&quot;</span> + <span class="string">&quot;CORBA服务器IP&quot;</span> + <span class="string">&quot;:&quot;</span></span><br><span class="line">+ <span class="string">&quot;CORBA服务器端口&quot;</span> + <span class="string">&quot;/NameService&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;初始化ORB对象的启动参数为： arg[&quot;</span> + i + <span class="string">&quot;] = &quot;</span></span><br><span class="line">+ args[i]);</span><br><span class="line">&#125;</span><br><span class="line">orb = org.omg.CORBA.ORB.init(args, <span class="literal">null</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;成功初始化ORB对象!－－－－Initialize Orb&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SystemException ex) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;初始化ORB对象异常！&quot;</span>);</span><br><span class="line">System.out.println(ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (orb == <span class="literal">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;orb == null&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Get Nameservice reference</span></span><br><span class="line"><span class="type">NamingContext</span> <span class="variable">nsRootContext</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">org.omg.CORBA.<span class="type">Object</span> <span class="variable">objRef</span> <span class="operator">=</span> orb</span><br><span class="line">.resolve_initial_references(<span class="string">&quot;NameService&quot;</span>);</span><br><span class="line">nsRootContext = NamingContextHelper.narrow(objRef);</span><br><span class="line">System.out.println(<span class="string">&quot;成功获取取名字服务!－－－－Get Nameservice reference&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (org.omg.CORBA.ORBPackage.InvalidName ex) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;取名字服务索引异常!&quot;</span>);</span><br><span class="line">System.out.println(ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.1 Get Reference to EMSSessionFactory</span></span><br><span class="line">NameComponent[] name = <span class="keyword">new</span> <span class="title class_">NameComponent</span>[<span class="number">1</span>];</span><br><span class="line">name[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">NameComponent</span>(<span class="string">&quot;ZTE/T3&quot;</span>, <span class="string">&quot;EMSFactory&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;NameComponent: &#x27;&quot;</span> + <span class="string">&quot;ZTE/T3 &quot;</span> + <span class="string">&quot;&#x27;,&#x27;EMSFactory&#x27;&quot;</span>);</span><br><span class="line">org.omg.CORBA.<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">obj = nsRootContext.resolve(name);</span><br><span class="line">System.out</span><br><span class="line">.println(<span class="string">&quot;成功获取EMSSession工厂!   Get Reference to EMSSessionFactory&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NotFound ex) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;取EMSSession工厂异常!---NotFound---&quot;</span>);</span><br><span class="line">ex.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (org.omg.CosNaming.NamingContextPackage.InvalidName ex) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;取EMSSession工厂异常!---InvalidName---&quot;</span>);</span><br><span class="line">ex.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (org.omg.CosNaming.NamingContextPackage.CannotProceed ex) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;取EMSSession工厂异常!---CannotProceed---&quot;</span>);</span><br><span class="line">ex.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始准备登陆并且获取EmsSession!</span></span><br><span class="line"><span class="type">EmsSessionFactory_I</span> <span class="variable">m_emsFactory</span> <span class="operator">=</span> EmsSessionFactory_IHelper</span><br><span class="line">.narrow(obj);</span><br><span class="line"><span class="type">NmsSession_I</span> <span class="variable">csession</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">POA</span> <span class="variable">rootpoa</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// get reference to rootpoa &amp; activate the POAManager</span></span><br><span class="line">System.out.println(<span class="string">&quot;取得rootpoa并激活POAManager!&quot;</span>);</span><br><span class="line">rootpoa = POAHelper.narrow(orb</span><br><span class="line">.resolve_initial_references(<span class="string">&quot;RootPOA&quot;</span>));</span><br><span class="line">rootpoa.the_POAManager().activate();</span><br><span class="line"><span class="comment">// create servant and register it with the ORB</span></span><br><span class="line">System.out.println(<span class="string">&quot;注册NmsSession到ORB!&quot;</span>);</span><br><span class="line"><span class="type">NmsSessionImpl</span> <span class="variable">nmsSessionImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NmsSessionImpl</span>();</span><br><span class="line"><span class="comment">// nmsSessionImpl.setORB(orb);</span></span><br><span class="line"><span class="type">byte</span>[] objectID = rootpoa.activate_object(nmsSessionImpl);</span><br><span class="line"><span class="comment">// create a tie, with servant being the delegate.</span></span><br><span class="line">System.out.println(<span class="string">&quot;创建NmsSession并且托管给POA!&quot;</span>);</span><br><span class="line"><span class="type">NmsSession_IPOATie</span> <span class="variable">tie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NmsSession_IPOATie</span>(nmsSessionImpl,rootpoa);</span><br><span class="line"><span class="comment">// obtain the objectRef for the tie</span></span><br><span class="line"><span class="comment">// this step also implicitly activates the the object</span></span><br><span class="line">System.out.println(<span class="string">&quot;在orb上激活NmsSession对象!&quot;</span>);</span><br><span class="line">csession = tie._this(orb);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;创建NmsSession对象过程,执行异常!&quot;</span>);</span><br><span class="line">System.out.println(ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">EmsSession_IHolder</span> <span class="variable">sessionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmsSession_IHolder</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;获取EmsSession引用对象&quot;</span>);</span><br><span class="line">m_emsFactory.getEmsSession(<span class="string">&quot;CORBA服务用户名&quot;</span>, <span class="string">&quot;CORBA服务密码&quot;</span>, csession,</span><br><span class="line">sessionHolder);</span><br><span class="line">System.out.println(<span class="string">&quot;NMSsession ---&quot;</span> + csession.toString());</span><br><span class="line">&#125; <span class="keyword">catch</span> (org.omg.zx.globaldefs.ProcessingFailureException ex) &#123;</span><br><span class="line">System.out</span><br><span class="line">.println(<span class="string">&quot;获取EmsSession引用对象，异常！---ProcessingFailureException---&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;可能是用户名或者密码错误，或者权限不够，或者已登陆的用户还未退出！&quot;</span>);</span><br><span class="line">System.out.println(ex.toString());</span><br><span class="line">&#125;</span><br><span class="line">emsSession = sessionHolder.value;</span><br><span class="line">System.out.println(<span class="string">&quot;EMSsession ---&quot;</span> + emsSession.toString());</span><br><span class="line">emsSession.ping();</span><br><span class="line"><span class="comment">// 初始化 EMS 管理器</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;初始化 EMS 管理器!&quot;</span>);</span><br><span class="line"><span class="type">Common_IHolder</span> <span class="variable">mgrHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Common_IHolder</span>();</span><br><span class="line">emsSession.getManager(<span class="string">&quot;EMS&quot;</span>, mgrHolder);</span><br><span class="line">emsMgr = EMSMgr_IHelper.narrow(mgrHolder.value);</span><br><span class="line">System.out.println(<span class="string">&quot;EMS_Manager To String ---&quot;</span> + emsMgr.toString());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ProcessingFailureException pfe) &#123;</span><br><span class="line">System.out</span><br><span class="line">.println(<span class="string">&quot;初始化 EMS 管理器异常!---ProcessingFailureException---&quot;</span>);</span><br><span class="line">System.out.println(pfe.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">initEvent(emsMgr, rootpoa);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initEvent</span><span class="params">(EMSMgr_I emsMgr, POA rootpoa)</span> &#123;</span><br><span class="line"><span class="comment">// 通过远程对象获取网元信息</span></span><br><span class="line"><span class="type">ManagedElementList_THolder</span> <span class="variable">meList</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">meList = <span class="keyword">new</span> <span class="title class_">ManagedElementList_THolder</span>();</span><br><span class="line">meMgr.getAllManagedElements(meList);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, size = meList.value.length; i &lt; size; i++) &#123;</span><br><span class="line"></span><br><span class="line">System.out.print(Stringformat(meList.value[i].meType) + <span class="string">&quot;\t&quot;</span></span><br><span class="line">+ Stringformat(meList.value[i].userLabel) + <span class="string">&quot;\t&quot;</span></span><br><span class="line">+ Stringformat(meList.value[i].nativeEMSName) + <span class="string">&quot;\t&quot;</span></span><br><span class="line">+ meList.value[i].hardwareVersion + <span class="string">&quot;\t&quot;</span></span><br><span class="line">+ meList.value[i].productName + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">NameAndStringValue_T[] arr = meList.value[i].name;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">System.out.print(meList.value[i].name[j].name + <span class="string">&quot;:&quot;</span></span><br><span class="line">+ meList.value[i].name[j].value + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">TopologicalLinkList_THolder</span> <span class="variable">topoList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TopologicalLinkList_THolder</span>();</span><br><span class="line">emsMgr.getAllTopLevelTopologicalLinks(topoList);</span><br><span class="line">TopologicalLink_T[] a = topoList.value;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, size = a.length; i &lt; size; i++) &#123;</span><br><span class="line">System.out.println(Stringformat(a[i].userLabel));</span><br><span class="line"></span><br><span class="line">NameAndStringValue_T[] aa = a[i].name;</span><br><span class="line"><span class="keyword">for</span> (NameAndStringValue_T nameAndStringValue_T : aa) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;aa:&quot;</span> + nameAndStringValue_T.name + <span class="string">&quot;~&quot;</span></span><br><span class="line">+ nameAndStringValue_T.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NameAndStringValue_T[] b = a[i].aEndTP;</span><br><span class="line"><span class="keyword">for</span> (NameAndStringValue_T nameAndStringValue_T : b) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a:&quot;</span> + nameAndStringValue_T.name + <span class="string">&quot;~&quot;</span></span><br><span class="line">+ nameAndStringValue_T.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NameAndStringValue_T[] c = a[i].zEndTP;</span><br><span class="line"><span class="keyword">for</span> (NameAndStringValue_T nameAndStringValue_T : c) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;z:&quot;</span> + nameAndStringValue_T.name + <span class="string">&quot;~&quot;</span></span><br><span class="line">+ nameAndStringValue_T.value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ProcessingFailureException ex) &#123;</span><br><span class="line">System.out.println(ex.toString());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符集转换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">Stringformat</span><span class="params">(String value)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(value.getBytes(<span class="string">&quot;ISO8859_1&quot;</span>), <span class="string">&quot;GB2312&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">ZxDemo</span> <span class="variable">zxDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZxDemo</span>();</span><br><span class="line">zxDemo.invoke();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
          <category> Corba开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Corba </tag>
            
            <tag> JacORB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Corba开发总结(一)---JacORB的安装与编译</title>
      <link href="/posts/2018/03/30490.html"/>
      <url>/posts/2018/03/30490.html</url>
      
        <content type="html"><![CDATA[<p>   由于公司新项目要求，做了一段时间的CORBA接口（中兴+华为）开发，踩了各种大大小小的坑，也算积累了一些经验，特分享至此，经验所限难免会有疏漏，欢迎讨论完善。</p><p>iManager<strong>CORBA</strong>网管<strong>北向接口</strong>（以下简称<strong>CORBA 接口</strong>） 用于连接 iManager M2000 移动网网元综合管理系统 （以下简称 M2000） 与上级网管系统 （NMS） 提供 M2000 ， 与 NMS 之间的<strong>接口</strong>转换和业务转换功能。</p><p><strong>一、CORBA技术说明</strong></p><p>CORBA（Common Object Request Broker Architecture，公共对象请求代理体系）是吸收了软件界面向对象技术、分布式计算技术、多层体系结构技术以及接口技术的一种综合技术，是一种对象间通信的工业标准。</p><span id="more"></span><p>CORBA规范包含：</p><ul><li>  接口定义语言 （IDL,Interface Definition Language）</li><li>  IDL语言和高级编程语言之间的映射</li><li>  IIOP（Internet Inter-ORB Protocol）通信协议</li><li>  可透过网络传递的对象引用格式</li></ul><p>CORBA的基本特征：</p><ul><li>  跨平台、跨语言、跨ORB（Object Request Broker）的互操作性</li><li>  即插即用的分布式特性</li></ul><p><strong>二、JacORB安装配置</strong></p><p>1、到<a href="http://www.jacorb.org/download.html%E4%B8%8B%E8%BD%BD%E5%90%88%E9%80%82%E7%9A%84%E7%89%88%E6%9C%AC%E5%B9%B6%E8%A7%A3%E5%8E%8B%E5%88%B0%E6%9C%AC%E5%9C%B0%EF%BC%8C%E6%88%91%E9%80%89%E7%94%A8%E7%9A%84%E6%98%AFJacORB-2.2.4%E7%89%88%E6%9C%AC%E3%80%82">http://www.jacorb.org/download.html下载合适的版本并解压到本地，我选用的是JacORB-2.2.4版本。</a></p><p>本地目录:D:\Programming\JAR\JacORB\JacORB-2.2.4</p><p>2、设置环境变量</p><p>确保有java环境和JAVA_HOME变量，我本地使用的是Java6环境。</p><p>添加D:\Programming\JAR\JacORB\JacORB-2.2.4\bin到环境变量path</p><p>创建JACORB_HOME变量为D:\Programming\JAR\JacORB\JacORB-2.2.4</p><p>ps：此处也可以不用设置系统环境变量，直接在idl.bat里设置。</p><p>3、修改idl.bat</p><p>%JACORB_HOME%\bin目录下会自带一个idl.bat的文件，该文件只是一个示例，需要修改文件内容。</p><p>原内容:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">java -classpath <span class="string">&quot;C:\JacORB-2.2.4\lib\idl.jar;C:\JacORB-2.2.4\lib\logkit-1.2.jar;%CLASSPATH%&quot;</span> org.jacorb.idl.parser %*</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改后【我自己的版本】：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off </span><br><span class="line">rem @JAVA_CMD@ -classpath <span class="string">&quot;@JACORB_HOME@/lib/idl.jar;@JACORB_HOME@/lib/logkit-1.2.jar;%CLASSPATH%&quot;</span> org.jacorb.idl.parser %* </span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> JACORB_HOME=D:/Programming/JAR/JacORB/JacORB-2.2.4</span><br><span class="line"><span class="built_in">set</span> JAVA_HOME=D:/Programming/JDK/jdk1.6.0_31</span><br><span class="line"><span class="built_in">set</span> path=%JAVA_HOME%/bin;%path% </span><br><span class="line"><span class="built_in">set</span> CLASSPATH=%JAVA_HOME%/lib/rt.jar </span><br><span class="line"><span class="built_in">set</span> CLASSPATH=%JACORB_HOME%/lib/antlr-2.7.2.jar;%JACORB_HOME%/lib/avalon-framework-4.1.5.jar;%JACORB_HOME%/lib/concurrent-1.3.2.jar;%JACORB_HOME%/lib/idl.jar;%JACORB_HOME%/lib/jacorb.jar;%JACORB_HOME%/lib/logkit-1.2.jar;%JACORB_HOME%/lib/picocontainer-1.2-021105.jar;%JACORB_HOME%/lib/wrapper-3.1.0.jar;%JACORB_HOME%/classes;%CLASSPATH% </span><br><span class="line">%JAVA_HOME%/bin/java -<span class="built_in">cp</span> %CLASSPATH% org.jacorb.idl.parser %* </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4、在%JACORB_HOME%\bin目录执行命令行 idl -h，显示帮助信息，说明已配置完成。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\Programming\JAR\JacORB\JacORB-2.2.4\bin&gt;idl -h</span><br><span class="line">        -h|<span class="built_in">help</span>         these few lines of <span class="built_in">help</span></span><br><span class="line">        -v|version      <span class="built_in">print</span> version information</span><br><span class="line">        -d <span class="built_in">dir</span>          root of directory tree <span class="keyword">for</span> output</span><br><span class="line">        -Dx             define preprocessor symbol x with value 1</span><br><span class="line">        -Dx=y           define preprocessor symbol x with value y</span><br><span class="line">        -Idir           <span class="built_in">set</span> include path <span class="keyword">for</span> idl files</span><br><span class="line">        -U&lt;symbol&gt;              undefine preprocessor symbol</span><br><span class="line">        -W [1..4]       debug level</span><br><span class="line">        -all            generate code <span class="keyword">for</span> all IDL files, even included ones</span><br><span class="line">        -forceOverwrite generate code even <span class="keyword">if</span> IDL has not changed</span><br><span class="line">        -ami_callback           generate AMI reply handlers and sendc methods</span><br><span class="line">        -ami_polling            generate AMI poller and sendp methods</span><br><span class="line">        -backend classname              use classname as code generator</span><br><span class="line">        -i2jpackage x:a.b.c      replace IDL package name x by a.b.c <span class="keyword">in</span> generate</span><br><span class="line">d Java code (e.g. CORBA:org.omg.CORBA)</span><br><span class="line">        -i2jpackagefile &lt;filename&gt;       replace IDL package names using list fr</span><br><span class="line">om &lt;filename&gt;. Format as above.</span><br><span class="line">        -ir             generate information required by the Interface Repositor</span><br><span class="line">y</span><br><span class="line">        -nofinal        generated Java code will contain no final class definiti</span><br><span class="line">ons</span><br><span class="line">        -unchecked_narrow               use unchecked_narrow <span class="keyword">in</span> generated code f</span><br><span class="line">or IOR parameters <span class="keyword">in</span> operations</span><br><span class="line">        -noskel         disables generation of POA skeletons</span><br><span class="line">        -nostub         disables generation of client stubs</span><br><span class="line">        -cldc10         code generation compatible with J2ME/CLDC 1.0</span><br><span class="line">        -sloppy_forward allow forward declarations wo. later definitions</span><br><span class="line">        -sloppy_names   less strict checking of module name scoping</span><br><span class="line">        -permissive_rmic        tolerate dubious IDL generated by JDK<span class="string">&#x27;s rmic, in</span></span><br><span class="line"><span class="string">cludes -sloppy_names.</span></span><br><span class="line"><span class="string">        -syntax         syntax check only, no code generation</span></span><br><span class="line"><span class="string">        &lt;filelist&gt;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p><strong>三、编译IDL文件</strong></p><p>执行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#编译中兴IDL</span></span><br><span class="line"><span class="comment">#D:\Programming\JAR\JacORB\JacORB-2.2.4\idl\omg 是编译中兴idl时要依赖的idl文件</span></span><br><span class="line"><span class="comment">#D:\idl\zhongxing\*.idl是中兴idl文件目录</span></span><br><span class="line"><span class="comment">#org.omg.zx是中兴idl编译生成的java服务端接口文件的包名</span></span><br><span class="line"><span class="comment">#c:/corba/zx 是生成中兴idl服务端接口文件所在的目录</span></span><br><span class="line">idl -all -d c:/corba/zx  -ID:\Programming\JAR\JacORB\JacORB-2.2.4\idl\omg -i2jpackage :org.omg.zx -<span class="keyword">in</span> D:\idl\zhongxing\*.idl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#编译华为IDL</span></span><br><span class="line"><span class="comment">#D:\idl\huawei\OMG 是编译华为idl时要依赖的idl文件</span></span><br><span class="line"><span class="comment">#D:\idl\huawei\*.idl是华为idl文件目录</span></span><br><span class="line"><span class="comment">#org.omg.zx是华为idl编译生成的java服务端接口文件的包名</span></span><br><span class="line"><span class="comment">#c:/corba/hw 是生成华为idl服务端接口文件所在的目录</span></span><br><span class="line">idl -all -d c:/corba/hw  -ID:\idl\huawei\OMG -i2jpackage :org.omg.hw -<span class="keyword">in</span> D:\idl\huawei\*.idl</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>IDL编译完成后即可在c:/corba/zx和c:/corba/hw目录下看到对应的java接口文件，将org.omg.zx和org.omg.hw两个目录都导入项目中就可以开始corba接口的开发了。</p><p><a href="https://github.com/dong706/CorbaDemo">开发corba接口所需idl下载</a></p>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
          <category> Corba开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Corba </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java使用zxing识别二维码</title>
      <link href="/posts/2018/01/bad81be1.html"/>
      <url>/posts/2018/01/bad81be1.html</url>
      
        <content type="html"><![CDATA[<p>最近公司要求扫描二维码和生成二维码的功能。而群里部分网友也提到了。我这里就写了一个demo，和大家分享。代码很简介，希望大家能够喜欢。</p><p>网友表示在网上搜索了很多，发现不是代码不全，就是jar不匹配。</p><p>我这里共享了一个zxing的2.2版本（支持JDK6）的例子，也提供了下载地址。实现代码如下：</p><span id="more"></span> <p>Zxing2.2（支持JDK6） 下载地址：<a href="http://download.csdn.net/download/dong707/10210016">http://download.csdn.net/download/dong707/10210016</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.herman.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.zxing.BarcodeFormat;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.BinaryBitmap;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.DecodeHintType;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.EncodeHintType;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.MultiFormatReader;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.MultiFormatWriter;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.NotFoundException;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.WriterException;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.client.j2se.BufferedImageLuminanceSource;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.client.j2se.MatrixToImageWriter;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.common.HybridBinarizer;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二维码工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Herman.Xiong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2015-7-10 上午10:52:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> jdk 1.6,tomcat 6.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZxingUtil</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;EncodeHintType, ErrorCorrectionLevel&gt; encodeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;EncodeHintType, ErrorCorrectionLevel&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;DecodeHintType, ErrorCorrectionLevel&gt; decodeMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;DecodeHintType, ErrorCorrectionLevel&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String charset=<span class="string">&quot;UTF-8&quot;</span>,format=<span class="string">&quot;png&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> size=<span class="number">150</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ZxingUtil</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成二维码图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Herman.Xiong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2015-7-10 上午10:26:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> WriterException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createQRCode</span><span class="params">(String data, File file)</span></span><br><span class="line"><span class="keyword">throws</span> WriterException, IOException &#123;</span><br><span class="line">MatrixToImageWriter.writeToFile(<span class="keyword">new</span> <span class="title class_">MultiFormatWriter</span>().encode(</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(data.getBytes(charset), charset),</span><br><span class="line">BarcodeFormat.QR_CODE, size, size, encodeMap), format, file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取二维码信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Herman.Xiong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2015-7-10 上午10:25:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filePath 二维码图片路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NotFoundException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readQRCode</span><span class="params">(String filePath)</span></span><br><span class="line"><span class="keyword">throws</span> FileNotFoundException, IOException, NotFoundException &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MultiFormatReader</span>().decode(<span class="keyword">new</span> <span class="title class_">BinaryBitmap</span>(<span class="keyword">new</span> <span class="title class_">HybridBinarizer</span>(<span class="keyword">new</span> <span class="title class_">BufferedImageLuminanceSource</span>(ImageIO.read(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath))))),decodeMap).getText();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] arg)</span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">createQRCode(<span class="string">&quot;http://blog.csdn.net/xmtblog&quot;</span>, <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\111.png&quot;</span>));</span><br><span class="line">System.out.println(readQRCode(<span class="string">&quot;D:\\111.png&quot;</span>));</span><br><span class="line"><span class="comment">//源码下载地址：http://download.csdn.net/detail/xmt1139057136/8886473</span></span><br><span class="line"><span class="comment">//欢迎大家关注我的博客！如有疑问,请加QQ群：454796847共同学习！</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> zxing </tag>
            
            <tag> 二维码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA类初始化顺序</title>
      <link href="/posts/2012/08/fefafa71.html"/>
      <url>/posts/2012/08/fefafa71.html</url>
      
        <content type="html"><![CDATA[<p>* 1 父类static 变量/代码块 初始化(即使父类static是private的也会初始化，只会初始化一次)</p><p> * 2 子类static 变量/代码块 初始化</p><p> * 3 父类可执行代码块(即 {…})</p><p> * 4  父类构造方法</p><p> * 5 子类可执行代码块(即 {…})</p><p> * 6 子类构造方法</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TestMain &#123;</span><br><span class="line">public static void main(String []args)&#123;</span><br><span class="line">new Children();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Parent&#123;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;A&quot;);</span><br><span class="line">&#125;</span><br><span class="line">static&#123;</span><br><span class="line">System.out.println(&quot;B&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public Parent()&#123;</span><br><span class="line">System.out.println(&quot;C&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Children extends Parent&#123;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">static&#123;</span><br><span class="line">System.out.println(&quot;2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public Children()&#123;</span><br><span class="line">System.out.println(&quot;3&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的执行结果为：B 2 A C 1 3</p>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具类获取Spring的ApplicationContext对象</title>
      <link href="/posts/2012/07/bd127a33.html"/>
      <url>/posts/2012/07/bd127a33.html</url>
      
        <content type="html"><![CDATA[<p>springMVC想直接获取jdbcTemplate，很苦逼的折腾了一天没解决，好吧，我承认我很菜….最后在网上搜到此方法，亲测可用，遂转发于此，以飨诸位。</p><p>这个方法初始化很慢，ApplicationContext context = new ClassPathXmlApplicationContext();当时我觉得没有这个必要，浪费内存。后来我终于想出了一个解决方法。在此拿来给大家参考下，希望对大家有帮助。</p><p>我写的代码如下：</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.task.common;</span><br><span class="line"></span><br><span class="line">import java.util.Locale;</span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.ApplicationContextAware;</span><br><span class="line">/**</span><br><span class="line"> * 获取Spring上下文及国际化</span><br><span class="line"> * @author bingchuan --&gt;www.vijun.com</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public final class SpringContextUtil implements ApplicationContextAware  &#123;</span><br><span class="line">    private static ApplicationContext context;</span><br><span class="line">    </span><br><span class="line">    @SuppressWarnings(&quot;static-access&quot;)</span><br><span class="line">    public void setApplicationContext(ApplicationContext contex) throws BeansException &#123;</span><br><span class="line">        this.context=contex;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Object getBean(String beanName)&#123;</span><br><span class="line">        return context.getBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static String getMessage(String key)&#123;</span><br><span class="line">        return context.getMessage(key, null, Locale.getDefault());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面可以获取ApplicationContext及国际化内容，使用方法如下：</p><p>1.首先在spring配置文件中中初始化  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt; bean class = &quot;com.task.common.SpringContextUtil&quot; id = &quot;springContextUtil&quot; /&gt;</span><br></pre></td></tr></table></figure><p>2.使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JdbcTemplate jdbcTemplate= (JdbcTemplate)SpringContextUtil.getBean(&quot;jdbcTemplate&quot;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apache检查httpd.conf的语法错误的方法</title>
      <link href="/posts/2012/05/326e3d8b.html"/>
      <url>/posts/2012/05/326e3d8b.html</url>
      
        <content type="html"><![CDATA[<p>修改了apache httpd.conf文件之后，怎么样验证其语法是否正确呢？当然，我们可以重新启动apache服务器，但这样一来，如果万一存在错误，apache服务器将不能正常启动，也不能提供正常服务。</p><p>所以我们在修改了apache的配置文件之后，最好对其验证，确保了其语法上正确无误之后，才重新启动apache服务器。  </p><span id="more"></span> <p>apache httpd.conf语法验证可以通过下面的命令来验证。<br><strong>Windows环境：</strong><br><code>httpd -t  </code><br>或者：<br><code>httpd.exe -w -t -f &quot;C:\\Apache2.2\\conf\\httpd.conf&quot; -d &quot;C:\\Apache2.2\\.&quot;  </code></p><p><strong>Linux环境：</strong><br><code>apachectl configtest </code><br>或<br><code>apache2ctl configtest  </code><br>SuSE等系统的apache2，可能为apache2ctl命令。  </p><p>如果你不能确认自己的apache服务器到底使用哪个命令，你可以使用<br><code>find / -name &quot;apachectl&quot;  </code><br>或者<br><code>find / -name &quot;apache2ctl&quot;  </code><br>来查找一下。  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@myserver bin\]#find / -name &quot;apachectl&quot;  </span><br><span class="line">/usr/local/apache/bin/apachectl                      </span><br></pre></td></tr></table></figure><p>如果正确无误，会显示Syntax OK信息。  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@myserver bin]# ./apachectl configtest  </span><br><span class="line">Syntax</span><br><span class="line">OK                                                 ``` </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">如果存在错误，则会显示出错的行号以及错误信息，如下：  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>[root@myserver bin]# ./apachectl configtest<br>Syntax error on line 134</p><p>```                     </p><p> |</p>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Apache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个漂亮的表白方式</title>
      <link href="/posts/2012/03/14968.html"/>
      <url>/posts/2012/03/14968.html</url>
      
        <content type="html"><![CDATA[<p>首先请按ctrl+f 然后输入9 点击全部高亮显示，奇迹出现了有木有！ </p><p>99669999996669999996699666699666999966699666699<br>99699999999699999999699666699669966996699666699<br>99669999999999999996699666699699666699699666699<br>99666699999999999966666999966699666699699666699<br>99666666999999996666666699666699666699699666699<br>99666666669999666666666699666669966996699666699<br>9966666666699666666666669966666699996666999999…</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA异常:java.io.EOFException: No content to map to Object due to end of input</title>
      <link href="/posts/2012/03/21a6ab48.html"/>
      <url>/posts/2012/03/21a6ab48.html</url>
      
        <content type="html"><![CDATA[<p>开发过程中碰到一个异常：<br><code>java.io.EOFException: No content to map to Object due to end of input</code></p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">完整java异常：</span><br><span class="line"></span><br><span class="line">java.io.EOFException: No content to map to Object due to end of input</span><br><span class="line"></span><br><span class="line">org.codehaus.jackson.map.ObjectMapper._initForReading(ObjectMapper.java:2433) [jackson-mapper-asl-1.8.1.jar:1.8.1] </span><br><span class="line"></span><br><span class="line">at org.codehaus.jackson.map.ObjectMapper._readValue(ObjectMapper.java:2366) [jackson-mapper-asl-1.8.1.jar:1.8.1]</span><br><span class="line"></span><br><span class="line"> at org.codehaus.jackson.map.ObjectMapper.readValue(ObjectMapper.java:1162) [jackson-mapper-asl-1.8.1.jar:1.8.1] </span><br><span class="line"></span><br><span class="line">at org.codehaus.jackson.jaxrs.JacksonJsonProvider.readFrom(JacksonJsonProvider.java:410) [jackson-jaxrs-1.8.1.jar:1.8.1]</span><br></pre></td></tr></table></figure><p> 这个问题困扰了我很久，最后发现原因是：</p><p>   Content-Type我设置为 application/json charset=utf-8，但是实际传递参数至服务端时并没有传递json参数，导致at org.codehaus.jackson.map.ObjectMapper._readValue读取不到json数据导致报错。</p><p>   解决办法：当不传递json数据时，’Content-Type’设置为’application/x-www-form-urlencoded charset=utf-8’即可。</p>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Datatables使用笔记</title>
      <link href="/posts/2012/02/8e95b651.html"/>
      <url>/posts/2012/02/8e95b651.html</url>
      
        <content type="html"><![CDATA[<p>​<br>1.若对Datatables提供的css不够满意，可以自己修改page.css和table.css.</p><p>比如，单元格的内容过多会导致自动换行，我修改成了过多内容以省略号代替，同时增加了left类：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">table.css</span><br><span class="line">table.display td.center &#123;</span><br><span class="line">text-align: center;</span><br><span class="line">white-space: nowrap;</span><br><span class="line">text-overflow:ellipsis;</span><br><span class="line">overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">table.display td.left &#123;</span><br><span class="line">text-align: left;</span><br><span class="line">white-space: nowrap;</span><br><span class="line">text-overflow:ellipsis;</span><br><span class="line">overflow: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p> <br>2.Datatables原有的列属性无法满足我的要求，因此想自己修改jquery.dataTables.js达到自定义列属性的效果。</p><p>   尝试修改_fnAjaxParameters方法,尝试成功，分享如下：</p><p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;aoColumns&quot;: [&#123;&quot;sTitle&quot;: &quot;任务编号&quot;,&quot;sWidth&quot;: &quot;80px&quot;,&quot;dropName&quot;:&quot;123&quot;&#125;]</span><br></pre></td></tr></table></figure> </p><p>如上所示，我想个列属性里增加 dropName属性.故修改_fnAjaxParameters方法如下：</p><p> </p><p> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for ( i=0 ; i&lt;iColumns ; i++ )</span><br><span class="line">&#123;</span><br><span class="line">mDataProp = oSettings.aoColumns[i].mDataProp;</span><br><span class="line">dropName  = oSettings.aoColumns[i].dropName;//新添加代码</span><br><span class="line">aoData.push( &#123; &quot;name&quot;: &quot;mDataProp_&quot;+i, &quot;value&quot;: typeof(mDataProp)===&quot;function&quot; ? &#x27;function&#x27; : mDataProp &#125; );</span><br><span class="line">aoData.push( &#123; &quot;name&quot;: &quot;dropName&quot;+i, &quot;value&quot;: dropName?dropName:&quot;&quot; &#125; );//新添加代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><p> </p><p>然后，后台就可以接收dropName参数并解析了!</p><p> 3.无法拖拽调整列宽，这是一个要解决的问题。</p><p> 4.无法进行多条件查询，这个另一个要解决的问题！当然还有个多列过滤…</p><p> 5.表格中的超链接，单选框、下拉条等等也可以如此实现.</p><p>   </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;sTitle&quot;: &quot;任务编号&quot;,&quot;sWidth&quot;: &quot;80px&quot;,</span><br><span class="line"></span><br><span class="line">                &quot;fnRender&quot;: function(obj) &#123;</span><br><span class="line"></span><br><span class="line">                  var s = obj.aData[obj.iDataColumn];</span><br><span class="line"></span><br><span class="line">                         s=&quot;&lt;a href=&#x27;http://www.baidu.com&#x27; target=&#x27;_blank&#x27;&gt;&quot;+s+&quot;&lt;/a&gt;&quot;;</span><br><span class="line"></span><br><span class="line">                      return s;</span><br><span class="line"></span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p> </p><p> </p><p> </p><p> 6.单独给某列定制排序方法</p><p>  <a href="http://datatables.net/plug-ins/sorting#how_to_data_source">http://datatables.net/plug-ins/sorting#how_to_data_source</a></p><p> </p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> Web技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
